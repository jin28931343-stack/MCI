<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <!-- PWA 設定 -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#050505">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="MCI Sim">
    <link rel="apple-touch-icon" href="PIC/MCI_game.png">
    <!-- Google SEO 搜尋引擎優化設定  -->
    <meta name="description"
        content="MCI (Mass Casualty Incident) 大量傷患事件模擬演練系統。透過互動式遊戲學習 START 檢傷分類法 (Simple Triage and Rapid Treatment)，提升災難現場檢傷分類 (Triage) 與緊急處置能力。">
    <meta name="keywords" content="MCI, triage, START, mass casualty incidents, 大量傷患, 檢傷分類, 災難模擬, 緊急醫療, EMT">
    <meta name="author" content="MCI Simulation">
    <!-- Google 搜尋與社群分享預覽圖片  -->
    <meta property="og:image" content="https://jin28931343-stack.github.io/MCI/PIC/MCI_game.png">
    <meta name="image" content="https://jin28931343-stack.github.io/MCI/PIC/MCI_game.png">

    <!-- Open Graph (社交媒體分享優化) -->
    <meta property="og:title" content="MCI 大量傷患模擬演練">
    <meta property="og:description" content="互動式大量傷患 (MCI) 檢傷分類 (Triage) 訓練模擬器。">
    <meta property="og:type" content="website">

    <!--  已更正為標準 URL -->
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Press+Start+2P&display=swap"
        rel="stylesheet">

    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

    <!-- 標題 -->
    <title>MCI 模擬 - 大量傷患檢傷分類 (Triage) 演練</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* === 新增：點擊提示文字樣式 === */
        .click-hint {
            position: absolute;
            bottom: 15%;
            /* 位於畫面下方 */
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'DotGothic16', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 2px;
            animation: blink 1.5s infinite;
            /* 使用既有的 blink 動畫 */
            z-index: 60;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            /* Safari */
            touch-action: none;
            /* 禁止預設觸控行為，防止畫面滑動 */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 確保 Canvas 渲染品質 */
        canvas {
            image-rendering: auto;
            /* 或 pixelated 視風格而定 */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            /* 增加陰影讓邊界更明顯 */

        }

        ::-webkit-scrollbar {
            display: none;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        .animate-blink {
            animation: blink 1s infinite;
        }

        /* ★★★ 新增：音訊視覺化波形動畫 ★★★ */
        @keyframes sound-wave {
            0% {
                height: 3px;
            }

            50% {
                height: 15px;
            }

            100% {
                height: 3px;
            }
        }

        .playing-wave .bar {
            animation: sound-wave 0.5s infinite ease-in-out;
        }

        .playing-wave .bar:nth-child(1) {
            animation-delay: 0.0s;
        }

        .playing-wave .bar:nth-child(2) {
            animation-delay: 0.1s;
        }

        .playing-wave .bar:nth-child(3) {
            animation-delay: 0.2s;
        }

        .playing-wave .bar:nth-child(4) {
            animation-delay: 0.3s;
        }

        /* ★★★ 虛擬搖桿 UI ★★★ */
        .joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 150px;
            height: 150px;
            z-index: 100;
            touch-action: none;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* ★★★ 手機版功能按鈕 ★★★ */
        .mobile-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            font-weight: bold;
            font-size: 14px;
            backdrop-filter: blur(5px);
            touch-action: manipulation;
            user-select: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        .btn-interact {
            bottom: 40px;
            right: 40px;
            border-color: #f1c40f;
            color: #f1c40f;
        }

        .btn-cancel {
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .btn-inventory {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            border-color: #3498db;
            color: #3498db;
        }

        /* ★★★ 自定義像素箭頭鼠標 CSS ★★★ */
        .cursor-pixel {
            /* 使用 SVG Data URI 繪製像素風格箭頭 (白底黑邊) */
            cursor: url("data:image/svg+xml,%3Csvg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='shadow' x='-2' y='-2' width='200%25' height='200%25'%3E%3CfeDropShadow dx='1' dy='1' stdDeviation='1' flood-color='rgba(0,0,0,0.5)'/%3E%3C/filter%3E%3Cpath d='M2 2 L2 20 L6 16 L10 25 L13 23 L9 14 L15 14 L2 2 Z' fill='white' stroke='black' stroke-width='2' stroke-linejoin='round' filter='url(%23shadow)'/%3E%3C/svg%3E") 2 2, auto;
        }

        /* === 開頭動畫樣式 (新增) === */
        :root {
            --bg-color: #1a1a2e;
            --ruin-color: #0f0f1a;
            --fire-color: #e94560;
        }

        /* 動畫容器覆蓋層 */
        #intro-app-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            z-index: 99999;
            /* 確保在最上層 */
            font-family: 'DotGothic16', sans-serif;
            user-select: none;
        }

        #intro-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            background: linear-gradient(to bottom, #111 0%, #332 100%);
        }

        /* === 背景建築樣式 === */
        .ruins-bg {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            /* 自動高度以保持圖片比例 */
            max-height: 100%;
            /* 限制最大高度，避免遮擋到標題 */
            object-fit: cover;
            /* 確保圖片適當填滿 */
            z-index: 1;
            /* 移除原本的 background-color 和 clip-path */
        }

        .smoke {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #555;
            box-shadow: 10px -10px 0 #444, 20px 0 0 #666;
            opacity: 0.6;
            animation: floatUp 4s infinite linear;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 0.6;
            }

            100% {
                transform: translateY(-100px) scale(2);
                opacity: 0;
            }
        }

        .road {
            position: absolute;
            bottom: 5%;
            width: 100%;
            height: 60px;
            z-index: 5;
        }

        .vehicle {
            position: absolute;
            bottom: 0;
            left: 100%;
            filter: drop-shadow(4px 4px 0px rgba(0, 0, 0, 0.5));
            height: auto;
            object-fit: contain;
        }

        /* 定義各車輛圖片的大小與層級  */
        #police {
            width: 140px;
            /* 警車圖片寬度 */
            z-index: 12;
        }

        #ambulance {
            width: 180px;
            /* 救護車圖片寬度 */
            z-index: 11;
        }

        #fire {
            width: 240px;
            /* 消防車圖片寬度 */
            z-index: 10;
        }

        @keyframes driveBy {
            0% {
                left: 100%;
                transform: scaleX(1);
            }

            40% {
                left: 40%;
                transform: scaleX(1) skewX(10deg);
            }

            100% {
                left: -20%;
                transform: scaleX(1);
            }
        }

        .siren-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            mix-blend-mode: overlay;
        }

        @keyframes sirenFlash {
            0% {
                background-color: rgba(255, 0, 0, 0.4);
                opacity: 0.6;
            }

            50% {
                background-color: rgba(0, 0, 255, 0.4);
                opacity: 0.6;
            }

            100% {
                background-color: rgba(255, 0, 0, 0.4);
                opacity: 0.6;
            }
        }

        #transition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
        }

        #title-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 30;
            opacity: 0;
            width: 100%;
        }

        .main-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 2.5rem;
            /* 調整大小以適應較長的標題 */
            color: #ffd700;
            text-shadow: 4px 4px 0 #000;
            margin-bottom: 40px;
            letter-spacing: 2px;
            line-height: 1.4;
            text-transform: uppercase;
            padding: 0 20px;
            /* 防止在小螢幕貼邊 */
        }



        .start-btn {
            background-color: #000000;
            color: rgb(255, 213, 0);
            border: 4px solid #fff;
            padding: 15px 30px;
            font-family: 'DotGothic16', sans-serif;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 4px 4px 0 #000;
            transition: transform 0.1s;
            animation: pulse 1.5s infinite;
        }

        .start-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 0 0 0 #000;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
        }

        @keyframes shake {

            10%,
            90% {
                transform: translate3d(-1px, 0, 0);
            }

            20%,
            80% {
                transform: translate3d(2px, 0, 0);
            }

            30%,
            50%,
            70% {
                transform: translate3d(-4px, 0, 0);
            }

            40%,
            60% {
                transform: translate3d(4px, 0, 0);
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef, useState } = React;

        const IconAlert = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" /><path d="M12 9v4" /><path d="M12 17h.01" /></svg>;
        const IconMapPin = () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z" /><circle cx="12" cy="10" r="3" /></svg>;
        const IconActivity = () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2" /></svg>;
        // ★★★ 音量圖示 ★★★
        const IconVolume = ({ muted }) => muted ?
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><line x1="23" y1="9" x2="17" y2="15" /><line x1="17" y1="9" x2="23" y2="15" /></svg> :
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" /></svg>;
        // ★★★ 新增：人物選擇畫面元件 ★★★
        const CharacterSelection = ({ onSelect }) => {
            return (
                <div className="fixed inset-0 bg-black z-[100] flex flex-col items-center justify-center font-mono text-white animate-fade-in">
                    <h2 className="text-3xl mb-12 font-bold tracking-widest text-yellow-400 drop-shadow-[0_0_10px_rgba(250,204,21,0.5)]">
                        選擇角色 / SELECT CHARACTER
                    </h2>
                    <div className="flex gap-10 md:gap-24">
                        {/* 男性選項 */}
                        <div
                            onClick={() => onSelect('男')}
                            className="group flex flex-col items-center cursor-pointer transition-all duration-300 hover:scale-110"
                        >
                            <div className="w-48 h-64 border-4 border-blue-500 rounded-xl flex items-center justify-center bg-slate-900 relative overflow-hidden group-hover:border-blue-300 group-hover:shadow-[0_0_30px_rgba(59,130,246,0.6)] transition-all">
                                {/* 預留插圖位置：男性 */}
                                <img
                                    src="PIC/player_man.png"
                                    alt="Male Agent"
                                    className="w-full h-full object-cover"
                                    onError={(e) => {
                                        e.target.style.display = 'none';
                                        e.target.nextSibling.style.display = 'flex';
                                    }}
                                />
                                {/* 圖片讀取失敗時的替代顯示 */}
                                <div className="hidden absolute inset-0 flex-col items-center justify-center text-blue-500">
                                    <span className="text-6xl mb-2">♂</span>
                                    <span className="text-xs">NO IMAGE</span>
                                </div>
                                <div className="absolute inset-0 bg-blue-500/10 group-hover:bg-blue-500/0 transition-colors"></div>
                            </div>
                            <span className="mt-6 text-2xl font-bold text-blue-500 group-hover:text-blue-300 tracking-wider">
                                男 (MALE)
                            </span>
                        </div>

                        {/* 女性選項 */}
                        <div
                            onClick={() => onSelect('女')}
                            className="group flex flex-col items-center cursor-pointer transition-all duration-300 hover:scale-110"
                        >
                            <div className="w-48 h-64 border-4 border-pink-500 rounded-xl flex items-center justify-center bg-slate-900 relative overflow-hidden group-hover:border-pink-300 group-hover:shadow-[0_0_30px_rgba(236,72,153,0.6)] transition-all">
                                {/* 預留插圖位置：女性 */}
                                <img
                                    src="PIC/player_woman.png"
                                    alt="Female Agent"
                                    className="w-full h-full object-cover"
                                    onError={(e) => {
                                        e.target.style.display = 'none';
                                        e.target.nextSibling.style.display = 'flex';
                                    }}
                                />
                                {/* 圖片讀取失敗時的替代顯示 */}
                                <div className="hidden absolute inset-0 flex-col items-center justify-center text-pink-500">
                                    <span className="text-6xl mb-2">♀</span>
                                    <span className="text-xs">NO IMAGE</span>
                                </div>
                                <div className="absolute inset-0 bg-pink-500/10 group-hover:bg-pink-500/0 transition-colors"></div>
                            </div>
                            <span className="mt-6 text-2xl font-bold text-pink-500 group-hover:text-pink-300 tracking-wider">
                                女 (FEMALE)
                            </span>
                        </div>
                    </div>
                    <div className="mt-16 text-gray-500 text-sm animate-pulse">
                        請點擊角色以開始任務
                    </div>
                </div>
            );
        };
        // 需預載的資源清單 (放在 IntroScreen 之前) 
        const PRELOAD_ASSETS = [
            'PIC/survivor_man.png', 'PIC/survivor_woman.png',
            'PIC/player_man.png', 'PIC/player_woman.png',
            'PIC/fire.png', 'PIC/water.png', 'PIC/breaker.png', 'PIC/emt.png',
            'PIC/firefighter.png', 'PIC/firetruck.png', 'PIC/ambulance.png', 'PIC/police.png',
            'PIC/minibus.png', 'PIC/sedan.png', 'PIC/truck.png', 'PIC/suv.png', 'PIC/van.png', 'PIC/jeep.png',
            'PIC/oil.png', 'PIC/glass.png', 'PIC/metal.png', 'PIC/energy_drink.png',
            'PIC/black_zone.png', 'PIC/red_zone.png', 'PIC/yellow_zone.png', 'PIC/green_zone.png',
            'PIC/command_post1.png', 'PIC/decon1.png', 'PIC/ambulance_staging1.png',
            'PIC/icon_green.png', 'PIC/icon_yellow.png', 'PIC/icon_red.png', 'PIC/icon_black.png',
            'PIC/BASIC.png', 'PIC/Pulse.png', 'PIC/consciousness.png'
        ];
        // === IntroScreen 組件 ===
        const IntroScreen = ({ onStart }) => {
            const [showStartBtn, setShowStartBtn] = useState(false);
            // 追蹤是否已互動 (點擊) 的狀態 
            const [hasInteracted, setHasInteracted] = useState(false);
            // 背景預載邏輯 
            // 利用開頭動畫的時間，偷偷在背景載入圖片至瀏覽器快取
            useEffect(() => {
                PRELOAD_ASSETS.forEach(src => {
                    const img = new Image();
                    img.src = src;
                    // 圖片載入後會存於快取中，進入主遊戲時再次請求即無需等待
                });
            }, []);
            // 開頭動畫音樂控制邏輯 
            useEffect(() => {
                // 建立 Audio 物件
                const introAudio = new Audio('PIC/intro.mp3');
                introAudio.loop = true; // 設定循環播放
                introAudio.volume = 0.5; // 設定音量

                // ★★★ 修正函式：啟動按鈕顯示倒數 ★★★
                const startButtonSequence = () => {
                    // 確保只執行一次
                    removeInteractionListeners();

                    // 設定為已互動，隱藏提示文字
                    setHasInteracted(true);

                    // 點擊或自動播放後，延遲 6 秒才顯示開始按鈕
                    setTimeout(() => {
                        setShowStartBtn(true);
                    }, 6000);
                };

                // 定義啟動音樂的函式
                const playMusic = () => {
                    introAudio.play().then(() => {
                        // ★★★ 修正點：自動播放成功時，也要執行按鈕倒數邏輯 ★★★
                        startButtonSequence();
                    }).catch(e => {
                        console.log("等待使用者互動...", e);
                        addInteractionListeners();
                    });
                };

                // 當使用者互動後嘗試播放的函式
                const handleInteraction = () => {
                    // 使用者互動後，再次呼叫 playMusic
                    // 這時 play() 會成功，進而觸發 .then() 裡面的 startButtonSequence()
                    playMusic();
                };

                const addInteractionListeners = () => {
                    window.addEventListener('click', handleInteraction);
                    window.addEventListener('keydown', handleInteraction);
                    window.addEventListener('touchstart', handleInteraction);
                };

                const removeInteractionListeners = () => {
                    window.removeEventListener('click', handleInteraction);
                    window.removeEventListener('keydown', handleInteraction);
                    window.removeEventListener('touchstart', handleInteraction);
                };

                // 嘗試自動播放
                playMusic();

                // 定義停止音樂函式 (組件卸載用)
                const stopMusic = () => {
                    introAudio.pause();
                    introAudio.currentTime = 0;
                    removeInteractionListeners();
                };

                // 按下任意鍵停止音樂 (除錯用，可保留或移除)
                const handleStopKey = (e) => {
                    if (!introAudio.paused) {
                        stopMusic();
                        window.removeEventListener('keydown', handleStopKey);
                    }
                };

                setTimeout(() => {
                    window.addEventListener('keydown', handleStopKey);
                }, 500);

                // 組件卸載時清理
                return () => {
                    stopMusic();
                    window.removeEventListener('keydown', handleStopKey);
                    removeInteractionListeners();
                };
            }, []);
            useEffect(() => {
                const police = document.getElementById('police');
                const ambulance = document.getElementById('ambulance');
                const fire = document.getElementById('fire');
                const sirenOverlay = document.getElementById('siren-overlay');
                const appContainer = document.getElementById('intro-app-container');
                const transitionOverlay = document.getElementById('transition-overlay');
                const titleContainer = document.getElementById('title-container');

                const createSmokeParticles = () => {
                    const container = document.getElementById('smoke-container');
                    if (!container) return;
                    for (let i = 0; i < 15; i++) {
                        let smoke = document.createElement('div');
                        smoke.className = 'smoke';
                        smoke.style.left = Math.random() * 100 + '%';
                        smoke.style.bottom = (Math.random() * 20 + 10) + '%';
                        smoke.style.animationDelay = Math.random() * 2 + 's';
                        smoke.style.animationDuration = (Math.random() * 3 + 3) + 's';
                        container.appendChild(smoke);
                    }
                };

                const runIntroSequence = () => {
                    createSmokeParticles();

                    // 啟動警示燈
                    if (sirenOverlay) sirenOverlay.style.animation = "sirenFlash 0.3s infinite";

                    // 車輛移動序列
                    if (police) police.style.animation = "driveBy 1.5s linear forwards";

                    setTimeout(() => {
                        if (ambulance) ambulance.style.animation = "driveBy 1.5s linear forwards";
                        if (appContainer) appContainer.classList.add('shake');
                    }, 800);

                    setTimeout(() => {
                        if (fire) fire.style.animation = "driveBy 1.5s linear forwards";
                        if (appContainer) {
                            appContainer.classList.remove('shake');
                            void appContainer.offsetWidth; // trigger reflow
                            appContainer.classList.add('shake');
                        }
                    }, 1600);

                    setTimeout(() => {
                        if (sirenOverlay) {
                            sirenOverlay.style.animation = "none";
                            sirenOverlay.style.opacity = "0";
                        }
                        if (transitionOverlay) {
                            transitionOverlay.style.transition = "opacity 0.5s ease-in";
                            transitionOverlay.style.backgroundColor = "black";
                            transitionOverlay.style.opacity = "1";
                        }
                    }, 3200);

                    setTimeout(() => {
                        if (transitionOverlay) {
                            transitionOverlay.style.transition = "none";
                            transitionOverlay.style.backgroundColor = "white";

                            setTimeout(() => {
                                transitionOverlay.style.transition = "opacity 1.5s ease-out";
                                transitionOverlay.style.opacity = "0";
                                if (titleContainer) {
                                    titleContainer.style.transition = "opacity 2s ease-in";
                                    titleContainer.style.opacity = "1";
                                }

                            }, 100);
                        }
                    }, 4000);
                };

                runIntroSequence();
            }, []);

            const handleStart = () => {
                // 只有當按鈕顯示時才允許觸發 (多一層防護)
                if (!showStartBtn) return;

                const transitionOverlay = document.getElementById('transition-overlay');
                const introLayer = document.getElementById('intro-layer');

                if (transitionOverlay) {
                    transitionOverlay.style.backgroundColor = "black";
                    transitionOverlay.style.transition = "opacity 1s ease-in";
                    transitionOverlay.style.opacity = "1";
                }

                setTimeout(() => {
                    if (introLayer) introLayer.style.display = "none";
                    // 觸發父組件的開始遊戲回調
                    onStart();
                }, 1000);
            };

            return (
                <div id="intro-app-container">
                    <div id="intro-layer">
                        <div id="smoke-container"></div>
                        <div className="ruins-bg"></div>
                        {/* 更換為圖片標籤以預留插圖位置  */}
                        {/*  PIC 資料夾內有對應的背景圖片 (如 city_ruins.png) */}
                        <img
                            className="ruins-bg"
                            src="PIC/city_ruins.png"
                            alt="Background Ruins"
                            onError={(e) => {
                                // 圖片讀取失敗時的 fallback (可選：隱藏或顯示替代色塊)
                                e.target.style.display = 'none';
                            }}
                        />
                        {/* 閃爍提示文字 (只有在尚未互動時顯示) */}
                        {!hasInteracted && (
                            <div className="click-hint" style={{ pointerEvents: 'none' }}>請點擊畫面任意處開始</div>
                        )}
                        <div id="siren-overlay" className="siren-overlay"></div>
                        <div className="road">
                            {/* 請確保 PIC 資料夾內有對應的圖片檔案，或是修改 src 為您想要的路徑 */}
                            <img id="police" className="vehicle" src="PIC/tittle_police.png" alt="Police Car" />
                            <img id="ambulance" className="vehicle" src="PIC/tittle_ambulance.png" alt="Ambulance" />
                            <img id="fire" className="vehicle" src="PIC/tittle_firetruck.png" alt="Fire Truck" />
                        </div>
                        <div id="title-container">
                            <h1 className="main-title">Mass Casualty Triage Sim</h1>
                            {/* 按鈕樣式，預設透明且不可點擊  */}
                            <button
                                className="start-btn"
                                onClick={handleStart}
                                style={{
                                    opacity: showStartBtn ? 1 : 0,           // 控制透明度
                                    pointerEvents: showStartBtn ? 'auto' : 'none', // 控制是否可點擊 (關鍵！)
                                    transition: 'opacity 1s ease-in'         // 淡入效果
                                }}
                            >
                                點擊開始 START
                            </button>
                            <div style={{
                                position: 'fixed',
                                bottom: '20px',
                                right: '20px',
                                textAlign: 'right',
                                color: 'rgba(255, 255, 255, 0.5)',
                                fontSize: '12px',
                                fontFamily: "'Press Start 2P', cursive",
                                textShadow: '2px 2px 0 #000',
                                pointerEvents: 'none',
                                lineHeight: '1.8'
                            }}>
                                <div>Ver: 1.3.0</div>
                                <div>Author:莊進宏</div>
                            </div>
                        </div>
                    </div>
                    <div id="transition-overlay"></div>
                </div>
            );
        };

        function App() {
            const canvasRef = useRef(null);
            const [gameStarted, setGameStarted] = useState(false);
            // ★★★ 控制人物選擇畫面的狀態 ★★★
            const [showCharacterSelect, setShowCharacterSelect] = useState(false);
            const [missionComplete, setMissionComplete] = useState(false);
            const [resultStats, setResultStats] = useState(null);
            const [survivorCount, setSurvivorCount] = useState(0);
            const [evacuatedCount, setEvacuatedCount] = useState(0);
            const [selectedSlot, setSelectedSlot] = useState(0);
            // 專門用於強制畫面更新的 state，避免汙染 survivorCount 
            const [updateCount, forceUpdate] = useState(0);
            //   Ref 來追蹤 selectedSlot，解決 Event Listener 讀不到最新狀態的問題 ★★★
            const selectedSlotRef = useRef(selectedSlot);
            const [showRadioPanel, setShowRadioPanel] = useState(false);
            // 檢傷流程圖狀態控制 
            const [showFlowchart, setShowFlowchart] = useState(false);
            const [flowchartIndex, setFlowchartIndex] = useState(0);
            // 必須加入此 useEffect，讓 Ref 跟隨 State 更新
            useEffect(() => {
                selectedSlotRef.current = selectedSlot;
            }, [selectedSlot]);
            const [gameOver, setGameOver] = useState(false);
            const [showMatSelector, setShowMatSelector] = useState(false);
            // 控制道具欄顯示的狀態 (預設隱藏，按 I 切換) 
            const [showInventory, setShowInventory] = useState(false);
            // 音訊控制修改： MP3 播放 
            const bgmRef = useRef(null); // 用於儲存 Audio 物件
            const [isMuted, setIsMuted] = useState(true);
            const [score, setScore] = useState(0);
            // 全域禁止右鍵選單 (鎖定右鍵) 
            useEffect(() => {
                const handleGlobalContextMenu = (e) => {
                    e.preventDefault();
                };
                window.addEventListener('contextmenu', handleGlobalContextMenu);
                return () => {
                    window.removeEventListener('contextmenu', handleGlobalContextMenu);
                };
            }, []);
            //  虛擬搖桿與按鈕 Ref 
            const joystickRef = useRef({ active: false, identifier: null, baseX: 0, baseY: 0, vecX: 0, vecY: 0 });
            const [joystickUI, setJoystickUI] = useState({ x: 0, y: 0, active: false });
            // 用於將 useEffect 內部的 handler 暴露給外部 JSX 使用
            const keyDownHandlerRef = useRef(null);
            const cancelActionRef = useRef(null);

            // ★★★ 初始化 BGM (MP3) ★★★
            useEffect(() => {
                // 建立 Audio 物件，路徑設定為 PIC/.mp3
                const audio = new Audio('PIC/bgm.mp3');
                audio.loop = true; // 設定循環播放
                audio.volume = 0.5; // 設定音量 (0.0 ~ 1.0)
                bgmRef.current = audio;

                // 組件卸載時的清理
                return () => {
                    if (bgmRef.current) {
                        bgmRef.current.pause();
                        bgmRef.current = null;
                    }
                };
            }, []);

            // ★★★ 開關音樂函式 (MP3 版本) ★★★
            const toggleAudio = () => {
                const newVal = !isMuted;
                setIsMuted(newVal);

                if (bgmRef.current) {
                    if (!newVal) { // 開啟音樂 (解除靜音)
                        // 使用 catch 處理可能的瀏覽器自動播放限制錯誤
                        bgmRef.current.play().catch(e => console.error("BGM 播放失敗 (請確認 PIC 資料夾內有 bgm.mp3):", e));
                    } else { // 靜音 (暫停)
                        bgmRef.current.pause();
                    }
                }
            };

            const handleJoystickTouchStart = (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const rect = e.currentTarget.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                joystickRef.current = {
                    active: true,
                    identifier: touch.identifier,
                    baseX: centerX,
                    baseY: centerY,
                    vecX: 0,
                    vecY: 0
                };
                setJoystickUI({ x: 0, y: 0, active: true });
            };
            const handleJoystickTouchEnd = (e) => {
                e.preventDefault();
                joystickRef.current = { ...joystickRef.current, active: false, vecX: 0, vecY: 0 };
                setJoystickUI({ x: 0, y: 0, active: false });
            };
            const handleJoystickTouchMove = (e) => {
                e.preventDefault();
                if (!joystickRef.current.active) return;

                const touchList = e.changedTouches;
                let touch = null;
                // 尋找對應的 touch ID
                for (let i = 0; i < touchList.length; i++) {
                    if (touchList[i].identifier === joystickRef.current.identifier) {
                        touch = touchList[i];
                        break;
                    }
                }
                if (!touch) return;

                const rect = e.currentTarget.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // 計算相對於搖桿中心的偏移量
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;

                const maxDist = 35; // 搖桿最大移動半徑
                const dist = Math.hypot(dx, dy);

                // 限制在圓形範圍內
                if (dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio;
                    dy *= ratio;
                }

                // 更新 UI 位置
                setJoystickUI({ x: dx, y: dy, active: true });

                // 更新邏輯向量 (歸一化 -1 ~ 1)供遊戲迴圈使用
                joystickRef.current.vecX = dx / maxDist;
                joystickRef.current.vecY = dy / maxDist;
            };
            // ★★★ 模擬按鍵觸發 (給 UI 按鈕用) ★★★
            const triggerKey = (keyName) => {
                if (keyDownHandlerRef.current) {
                    keyDownHandlerRef.current({ key: keyName, preventDefault: () => { } });
                }
            };
            const triggerCancel = () => {
                if (cancelActionRef.current) cancelActionRef.current();
            };

            const statsTracker = useRef({
                tourniquet: { correct: 0, total: 0 },
                airway: { correct: 0, total: 0 },
                deconCount: 0
            });

            // --- 狀態追蹤各類別已安置人數 ---
            // ★★★ 新增：控制平板 UI 顯示的狀態 ★★★
            const [showTabletUI, setShowTabletUI] = useState(false);
            // ★★★ 新增：目前在平板介面中選中的傷患 ★★★
            const [selectedPatient, setSelectedPatient] = useState(null);
            const [triageCounts, setTriageCounts] = useState({
                green: 0,
                yellow: 0,
                red: 0,
                black: 0,
            });

            const [playerStatsUI, setPlayerStatsUI] = useState({
                hp: 100, maxHp: 100,
                mp: 80, maxMp: 100,
                sp: 100, maxSp: 100
            });

            const totalSurvivors = 30;

            const gameState = useRef({
                isGameOver: false,
                keys: { w: false, s: false, a: false, d: false },
                player: {
                    x: 300, y: 600, width: 30, height: 30, speed: 1.75, dir: 3, frame: 0, moving: false, animTimer: 0,
                    gender: '男', // ★★★ 預設性別 ★★★
                    isBusy: false
                },
                camera: { x: 0, y: 0 },
                stats: { hp: 100, maxHp: 100, mp: 80, maxMp: 100, sp: 100, maxSp: 100 },
                obstacles: [],
                energyDrinks: [],      // 存放場上的飲料物件
                energySpawnTimer: 0,   // 生成計時器
                spBuffTimer: 0,        // SP 無限 Buff 計時器
                emergencyVehicles: [],
                npcGroups: [],
                firefightingSquads: [],
                staticNpcs: [],
                decorations: [],
                triageMats: [],
                hazards: [],
                particles: [],
                survivors: [],
                feedbacks: [],
                firefightingSquads: [],
                rescueSquads: [], // 破壞救援小組陣列
                staticNpcs: [],
                interactionMenu: {
                    active: false, x: 0, y: 0, target: null, mode: 'main', selectedIndex: 0
                },
                placementMode: {
                    active: false,
                    type: null,
                    color: null,
                    w: 120, h: 80,
                    valid: false,
                    x: 0, y: 0
                },
                // ★★★ 搬運系統冷卻計時器 (初始化為 0) ★★★
                carrySystemCooldown: 0,
                ambulanceCooldown: 0, // 救護車呼叫冷卻時間
                megaphoneCooldown: 0,
                survivorsFoundCount: 0,
                animationFrameId: null,
                frameCount: 0,
                npcSpawnTimer: 0
            });

            const items = [
                { name: "無線電", color: "#34495e", type: "radio", imgSrc: "PIC/radio.png" },        // 1
                { name: "檢傷平板", color: "#9b59b6", type: "tablet", imgSrc: "PIC/tablet.png" },       // 2
                { name: "檢傷地墊", color: "#27ae60", type: "mat", imgSrc: "PIC/mat.png" },          // 3
                { name: "指揮站", color: "#ffffff", type: "command_post", imgSrc: "PIC/command_post.png" }, // 4
                { name: "除汙站", color: "#95a5a6", type: "decon", imgSrc: "PIC/decon.png" },        // 5
                { name: "救護車待命區", color: "#3498db", type: "ambulance_staging", imgSrc: "PIC/ambulance_staging.png" },//6 
                { name: "大聲公", color: "#e67e22", type: "megaphone", imgSrc: "PIC/megaphone.png" }, // 7
            ];


            const handleSlotClick = (index) => {
                const item = items[index];
                if (selectedSlotRef.current === index) {
                    setSelectedSlot(-1);
                    setShowMatSelector(false);
                    setShowTabletUI(false);
                    setShowRadioPanel(false); // 關閉無線電面板
                    setSelectedPatient(null);
                    gameState.current.placementMode.active = false;
                    // (移除舊的 interactionMenu 清除邏輯，因為不再使用了)
                    return;
                }
                if (!item) return;
                else if (item.type === 'megaphone') {
                    setShowMatSelector(false);
                    setShowTabletUI(false);
                    setShowRadioPanel(false);
                    gameState.current.placementMode.active = false;
                    gameState.current.interactionMenu.active = false;

                    const state = gameState.current;

                    // 檢查冷卻 (30秒)
                    if (state.megaphoneCooldown > 0) {
                        state.feedbacks.push({
                            x: state.player.x,
                            y: state.player.y - 50,
                            text: `大聲公冷卻中 (${Math.ceil(state.megaphoneCooldown / 60)}s)`,
                            color: "#bdc3c7",
                            life: 30,
                            vy: -0.5
                        });
                        return;
                    }

                    // 設定冷卻時間 (30秒 * 60 FPS)
                    state.megaphoneCooldown = 1800;

                    // 邏輯：搜尋畫面內的綠色傷患，並觸發移動
                    const camX = state.camera.x;
                    const camY = state.camera.y;
                    const viewW = 960; // 遊戲寬度
                    const viewH = 540; // 遊戲高度
                    let count = 0;
                    state.survivors.forEach(s => {
                        // ★★★ 修改：只要是「實際輕傷 (Green)」且「在畫面內」，不論是否已檢傷，都強制處理 ★★★
                        const isInView = s.x >= camX && s.x <= camX + viewW && s.y >= camY && s.y <= camY + viewH;

                        if (isInView && s.data.severity === 'green' && !s.hasArrived && !s.onAmbulance) {

                            // 1. 強制檢傷邏輯：如果尚未被標記為綠色，自動標記並加分
                            if (s.triageTag !== 'green') {
                                s.triageTag = 'green';
                                s.found = true;

                                // 補上加分邏輯 (比照手動檢傷正確 +100)
                                if (!s.hasBeenScored) {
                                    setScore(prev => prev + 100);
                                    state.feedbacks.push({
                                        x: s.x, y: s.y - 50, text: "強制檢傷 +100", color: "#f1c40f", life: 60, vy: -0.5
                                    });
                                    s.hasBeenScored = true;
                                }
                            }

                            // 2. 觸發移動邏輯
                            if (!s.isEvacuating) {
                                s.isEvacuating = true; // 將狀態設為移動中
                                count++;

                                // 給予個別傷患一點視覺回饋
                                state.feedbacks.push({
                                    x: s.x, y: s.y - 20, text: "收到集合指令!", color: "#2ecc71", life: 40, vy: -0.5
                                });
                            }
                        }
                    });

                    // ★★★ 更新全域檢傷計數 (因為可能有新的傷患被強制檢傷) ★★★
                    state.survivorsFoundCount = state.survivors.filter(s => s.found).length;
                    setSurvivorCount(state.survivorsFoundCount);

                    // 玩家回饋
                    state.feedbacks.push({
                        x: state.player.x,
                        y: state.player.y - 60,
                        text: count > 0 ? `廣播：${count}名輕傷者前往集合點` : "範圍內無可移動輕傷者",
                        color: "#e67e22",
                        life: 90,
                        vy: -0.5
                    });
                    // ★★★ 新增：大聲公使用後，立即手動更新分類計數 (確保 UI 同步) ★★★
                    // 修正：不再檢查 hasArrived，只要有標籤且在現場即算入
                    const counts = { green: 0, yellow: 0, red: 0, black: 0 };
                    state.survivors.forEach(s => {
                        if (s.triageTag && !s.onAmbulance) {
                            counts[s.triageTag]++;
                        }
                    });
                    setTriageCounts(counts);

                    return;
                }


                setSelectedSlot(index);
                // --- 移除 MP 檢查：點擊道具時不再檢查 MP ---
                // if (item.type === 'radio' && gameState.current.stats.mp < 10) {
                //      addFeedback(gameState.current.player.x, gameState.current.player.y - 50, "MP不足!", "#e74c3c");
                //      setSelectedSlot(-1); // 取消選擇
                //      return; 
                // }
                // ★★★ 切換道具時先關閉其他 UI ★★★
                setShowMatSelector(false);
                setShowTabletUI(false);
                gameState.current.placementMode.active = false;
                gameState.current.interactionMenu.active = false; // 切換道具時關閉互動選單
                if (item.type === "mat") {
                    setShowMatSelector(true);
                } else if (item.type === 'tablet') {
                    // ★★★ 如果是平板，開啟 UI ★★★
                    setShowTabletUI(true);
                } else if (['command_post', 'ambulance_staging', 'decon'].includes(item.type)) {
                    // ★★★ 限制特殊區域只能設置一個 ★★★
                    // 檢查場景中是否已存在相同類型的區域 (使用 color 作為識別)
                    const alreadyExists = gameState.current.triageMats.some(m => m.color === item.type);

                    if (alreadyExists) {
                        // 顯示提示訊息 (直接操作 state 因為 addFeedback 在 useEffect 內部無法直接呼叫)
                        gameState.current.feedbacks.push({
                            x: gameState.current.player.x,
                            y: gameState.current.player.y - 50,
                            text: "此區域只能設置一個",
                            color: "#e74c3c",
                            life: 60,
                            vy: -0.5
                        });
                        setSelectedSlot(-1); // 取消當前選中的道具
                        return; // 中止後續放置邏輯
                    }

                    // 設定特殊區塊的放置模式
                    gameState.current.placementMode = {
                        active: true,
                        type: 'zone',
                        color: item.type, // 使用 type 作為顏色鍵值
                        w: item.type === 'ambulance_staging' ? 250 : 160,
                        h: item.type === 'ambulance_staging' ? 180 : 120,
                        valid: false,
                        x: 0, y: 0
                    };

                } else if (item.type === 'radio') {
                    setShowRadioPanel(true); // 開啟無線電面板

                } else if (['breaker_tool', 'extinguisher_tool'].includes(item.type)) {
                    gameState.current.feedbacks.push({
                        x: gameState.current.player.x,
                        y: gameState.current.player.y - 50,
                        text: "請點擊目標使用",
                        color: item.color,
                        life: 60,
                        vy: -0.5
                    });
                }
            };

            const handleSelectMatColor = (color) => {
                setShowMatSelector(false);
                gameState.current.placementMode = {
                    active: true,
                    type: 'triage_mat',
                    color: color,
                    w: 100, h: 100,
                    valid: false,
                    x: 0, y: 0
                };
            };
            // ★★★處理人物選擇的函式 ★★★
            const handleCharacterSelect = (gender) => {
                gameState.current.player.gender = gender; // 將選擇寫入 gameState
                setShowCharacterSelect(false); // 關閉選擇畫面
                setGameStarted(true); // 正式開始遊戲
            };
            const handleRestart = () => {
                setGameOver(true);
                setTimeout(() => {
                    setMissionComplete(false); // 關閉任務完成畫面
                    setResultStats(null);      // 清除結算數據
                    setScore(0);               // 重置分數

                    // 確保 UI 上的計數器歸零 (雖然 useEffect 會重置部分，但手動確保 UI 同步更安全)
                    setSurvivorCount(0);
                    setEvacuatedCount(0);
                    setTriageCounts({ green: 0, yellow: 0, red: 0, black: 0 });

                    // 關鍵：將 gameOver 設回 false。
                    // 這會觸發依賴 [gameOver] 的 useEffect 執行初始化邏輯，生成新的傷患與場景。
                    setGameOver(false);
                }, 50);
            };

            const generateSurvivorData = (isTrapped) => {
                const sex = Math.random() > 0.5 ? '男' : '女';
                const age = Math.floor(Math.random() * (70 - 12 + 1)) + 12;

                const severityRoll = Math.random();
                let severity = 'green';
                let consciousness = '清醒';
                let resp = Math.random() > 0.5 ? '24次/min' : '12次/min';
                let pulse = '橈動脈摸的到';
                let injuryText = Math.random() > 0.5 ? '擦傷、驚嚇' : '臉部流血';
                let isBleeding = false;
                // 定義紅色傷患的呼吸速率選項 (32, 8, 24) 
                const redRespOptions = ['32次/min', '8次/min', '24次/min'];

                // 受困傷患強制設定為紅色或黑色 
                if (isTrapped) {
                    if (Math.random() > 0.7) { // 30% 機率死亡(黑)
                        severity = 'black';
                        consciousness = '無意識';
                        resp = '無';
                        pulse = '無';
                        injuryText = '嚴重擠壓變形、無生命徵象';
                        isBleeding = false;
                    } else { // 70% 機率重傷(紅)
                        severity = 'red';
                        consciousness = Math.random() > 0.5 ? '無意識' : '對痛有反應';
                        resp = redRespOptions[Math.floor(Math.random() * redRespOptions.length)];
                        pulse = Math.random() > 0.5 ? '橈動脈摸不到' : 'CRT>2秒';
                        injuryText = Math.random() > 0.5 ? '受困壓傷、懷疑內出血' : '雙腳變形';
                        isBleeding = true;
                    }
                } else {
                    if (severityRoll > 0.9) {
                        severity = 'black'; consciousness = '無意識'; resp = '無'; pulse = '無'; injuryText = '無呼吸';
                        isBleeding = false;
                    } else if (severityRoll > 0.75) {
                        severity = 'red'; consciousness = Math.random() > 0.5 ? '無意識' : '對痛有反應';
                        resp = redRespOptions[Math.floor(Math.random() * redRespOptions.length)];
                        pulse = Math.random() > 0.5 ? '橈動脈微弱,CRT>2秒' : '橈動脈摸不到'; injuryText = Math.random() > 0.5 ? '手臂變形、表情痛苦' : '臉色蒼白、多處撕裂傷';
                        isBleeding = Math.random() > 0.3;
                    } else if (severityRoll > 0.50) {
                        severity = 'yellow'; consciousness = Math.random() > 0.5 ? '對聲音有反應' : '可以聽指令'; resp = Math.random() > 0.5 ? '18次/分' : '24次/分'; pulse = Math.random() > 0.5 ? 'CRT<2sec' : '橈動脈摸的到'; injuryText = Math.random() > 0.5 ? '骨折、無法行走' : '頭暈、嘔吐無法行走';
                        isBleeding = false;
                    } else {
                        isBleeding = false;
                    }
                }

                const clothColor = `hsl(${Math.random() * 360}, 40%, 60%)`;
                // ★★★ 隨機設定是否被汙染 (例如 30% 機率) ★★★
                const isContaminated = Math.random() > 0.7;
                // ★★★ 回傳物件加入 isContaminated ★★★
                return {
                    sex, age, severity, consciousness, resp, pulse, injuryText, isBleeding, clothColor, isContaminated,
                    initialSeverity: severity,      // 記錄初始傷情 (用於計算紅色優先後送率)
                    wasContaminated: isContaminated // 記錄是否曾經汙染 (用於計算除汙率)
                };
            };

            useEffect(() => {
                if (!gameStarted || gameOver || !canvasRef.current) return;

                const canvas = canvasRef.current;
                // --- ★★★ 新增：預載檢傷分類 Icon 圖片 ★★★ ---
                const triageIcons = {};
                ['green', 'yellow', 'red', 'black'].forEach(tag => {
                    const img = new Image();
                    // 請確保 PIC 資料夾內有這些對應名稱的圖片，或是自行修改路徑
                    img.src = `PIC/icon_${tag}.png`;
                    triageIcons[tag] = img;
                });
                // ★★★ 說明：在此處補上 assets 物件定義，防止當機 ★★★
                // ★★★ 修改：初始化 assets 物件時加入 player 容器 ★★★
                const assets = { survivors: {}, player: {} };
                const consciousnessImg = new Image();
                consciousnessImg.src = 'PIC/consciousness.png';
                assets.consciousness = consciousnessImg;
                const pulseImg = new Image();
                pulseImg.src = 'PIC/Pulse.png';
                assets.pulse = pulseImg;
                const basicImg = new Image();
                basicImg.src = 'PIC/BASIC.png';
                assets.basic = basicImg;
                // 2. 載入男女傷患插圖 (★ 請在此處放入您的圖片路徑 ★)
                // 預留位置：請確保 PIC 資料夾內有 survivor_man.png 與 survivor_woman.png
                const manImg = new Image();
                manImg.src = 'PIC/survivor_man.png'; // 設定男性圖片路徑
                assets.survivors['男'] = manImg;

                const womanImg = new Image();
                womanImg.src = 'PIC/survivor_woman.png'; // 設定女性圖片路徑
                assets.survivors['女'] = womanImg;

                // ★★★ 載入玩家角色插圖 (對應選擇畫面的圖片) ★★★
                const pMan = new Image(); pMan.src = 'PIC/player_man.png'; assets.player['男'] = pMan;
                const pWoman = new Image(); pWoman.src = 'PIC/player_woman.png'; assets.player['女'] = pWoman;

                // 3. 載入火焰圖片 (用於火災危險區域)
                const fireImg = new Image();
                fireImg.src = 'PIC/fire.png'; //  PIC 資料夾內有名為 fire.png 的圖片
                assets.fire = fireImg;

                // ★★★ 載入水線 (Water) 圖片 ★★★
                const waterImg = new Image();
                waterImg.src = 'PIC/water.png'; // 請確保 PIC 資料夾內有 water.png
                assets.water = waterImg;

                // ★★★ 載入破壞器材 (Breaker) 圖片 ★★★
                const breakerImg = new Image();
                breakerImg.src = 'PIC/breaker.png'; // 請確保 PIC 資料夾內有 breaker.png
                assets.breaker = breakerImg;

                // ★★★ 載入搬運人員 (EMT) 圖片 ★★★
                const emtImg = new Image();
                emtImg.src = 'PIC/emt.png'; // 請確保 PIC 資料夾內有 emt.png 圖片
                assets.emt = emtImg;

                //  PIC 資料夾內有名為 firefighter.png 的圖片
                const firefighterImg = new Image();
                firefighterImg.src = 'PIC/firefighter.png';
                assets.firefighter = firefighterImg;

                // ★★★ 載入消防車圖片 (預留插圖位置) ★★★
                const firetruckImg = new Image();
                firetruckImg.src = 'PIC/firetruck.png'; //  PIC 資料夾內有此圖片
                assets.firetruck = firetruckImg;

                // ★★★ 載入救護車圖片 ★★★
                const ambulanceImg = new Image();
                ambulanceImg.src = 'PIC/ambulance.png'; // 請確保 PIC 資料夾內有 ambulance.png
                assets.ambulance = ambulanceImg;

                // ★★★ 載入警車圖片 (預留插圖位置) ★★★
                const policeImg = new Image();
                policeImg.src = 'PIC/police.png'; // 預留位置：請準備 police.png
                assets.police = policeImg;

                // ★★★ 載入小巴圖片 (預留插圖位置) ★★★
                const minibusImg = new Image();
                minibusImg.src = 'PIC/minibus.png'; // 預留位置：請確保 PIC 資料夾內有 minibus.png
                assets.minibus = minibusImg;

                // ★★★ 載入一般車輛插圖 (轎車/卡車) ★★★
                const sedanImg = new Image();
                sedanImg.src = 'PIC/sedan.png'; // 預留位置：請準備 sedan.png
                assets.sedan = sedanImg;

                const truckImg = new Image();
                truckImg.src = 'PIC/truck.png'; // 預留位置：請準備 truck.png
                assets.truck = truckImg;

                // ★★★ 載入 SUV 與 廂型車 插圖 ★★★
                const suvImg = new Image();
                suvImg.src = 'PIC/suv.png'; // 預留位置：請準備 suv.png
                assets.suv = suvImg;

                const vanImg = new Image();
                vanImg.src = 'PIC/van.png'; // 預留位置：請準備 van.png
                assets.van = vanImg;

                // ★★★ 預留吉普車 (Jeep) 插圖位置 ★★★
                const jeepImg = new Image();
                jeepImg.src = 'PIC/jeep.png'; // 預留位置：請準備 jeep.png
                assets.jeep = jeepImg;

                // ★★★  載入石油 (Oil) 圖片 ★★★
                const oilImg = new Image();
                oilImg.src = 'PIC/oil.png'; // 請確保 PIC 資料夾內有 oil.png
                assets.oil = oilImg;

                // ★★★ 載入碎玻璃 (Glass) 圖片 ★★★
                const glassImg = new Image();
                glassImg.src = 'PIC/glass.png'; // 請確保 PIC 資料夾內有 glass.png
                assets.glass = glassImg;

                // ★★★ 載入金屬 (Metal) 圖片 ★★★
                const metalImg = new Image();
                metalImg.src = 'PIC/metal.png'; // 請確保 PIC 資料夾內有 metal.png
                assets.metal = metalImg;

                // ★★★ 載入能量飲料 (Energy Drink) 圖片 ★★★
                const energyDrinkImg = new Image();
                energyDrinkImg.src = 'PIC/energy_drink.png'; // 預留位置：請確保 PIC 資料夾內有 energy_drink.png
                assets.energy_drink = energyDrinkImg;

                // 載入黑色區域 (Black Zone) 圖片 
                const blackZoneImg = new Image();
                blackZoneImg.src = 'PIC/black_zone.png'; // 預留位置：請確保 PIC 資料夾內有 black_zone.png
                assets.black_zone = blackZoneImg;

                // 載入紅色區域 (Red Zone) 圖片 
                const redZoneImg = new Image();
                redZoneImg.src = 'PIC/red_zone.png'; // 預留插圖位置：請確保 PIC 資料夾內有 red_zone.png
                assets.red_zone = redZoneImg;

                // 載入黃色區域 (Yellow Zone) 圖片 
                const yellowZoneImg = new Image();
                yellowZoneImg.src = 'PIC/yellow_zone.png'; // 預留插圖位置：請確保 PIC 資料夾內有 yellow_zone.png
                assets.yellow_zone = yellowZoneImg;

                //  載入綠色區域 (Green Zone) 圖片 
                const greenZoneImg = new Image();
                greenZoneImg.src = 'PIC/green_zone.png'; // 預留插圖位置：請確保 PIC 資料夾內有 green_zone.png
                assets.green_zone = greenZoneImg;


                // PIC 資料夾內有名為 command_post.png 的圖片
                const commandPostImg = new Image();
                commandPostImg.src = 'PIC/command_post1.png';
                assets.command_post = commandPostImg;

                // PIC 資料夾內有名為 decon.png 的圖片
                const deconImg = new Image();
                deconImg.src = 'PIC/decon1.png';
                assets.decon = deconImg;

                // 載入救護車待命區 (Ambulance Staging) 
                const ambulanceStagingImg = new Image();
                ambulanceStagingImg.src = 'PIC/ambulance_staging1.png'; // 請確保 PIC 資料夾內有 ambulance_staging.png
                assets.ambulance_staging = ambulanceStagingImg;

                const ctx = canvas.getContext('2d');
                const state = gameState.current;

                const GAME_WIDTH = 960;
                const GAME_HEIGHT = 540;

                // --- 設定擴張 ---
                // 左側偏移量 (約 4 台消防車寬度 + 緩衝 = 700px)
                const LEFT_EXPANSION = 700;
                // 原本世界寬度 2000，加上擴張區域
                const WORLD_WIDTH = 2000 + LEFT_EXPANSION;
                const WORLD_HEIGHT = 1200;

                // --- 重置 ---
                state.isGameOver = false;
                state.obstacles = [];
                state.emergencyVehicles = [];
                state.npcGroups = [];
                state.firefightingSquads = [];
                state.staticNpcs = [];
                state.decorations = [];
                state.triageMats = [];
                state.hazards = [];
                state.particles = [];
                state.survivors = [];
                state.feedbacks = [];
                state.energyDrinks = [];
                state.energySpawnTimer = 0;
                state.survivorsFoundCount = 0;
                state.frameCount = 0;
                state.npcSpawnTimer = 0;
                state.rescueSquads = [];
                state.ambulanceCooldown = 0; // ★★★ 救護車冷卻時間初始化 ★★★
                state.stats = { hp: 100, maxHp: 100, mp: 80, maxMp: 100, sp: 100, maxSp: 100 };

                // 玩家起始位置也跟著向右移，保持相對位置
                state.player.x = 50 + LEFT_EXPANSION;
                state.player.y = WORLD_HEIGHT / 2;

                // 攝影機初始位置可以設在擴張區邊緣，讓玩家看到空地
                state.camera = { x: LEFT_EXPANSION - 300, y: 0 }; // 稍微往左一點看
                if (state.camera.x < 0) state.camera.x = 0;

                state.interactionMenu = { active: false, x: 0, y: 0, target: null, mode: 'main' };
                state.placementMode.active = false;
                setSurvivorCount(0);
                setEvacuatedCount(0);
                setPlayerStatsUI({ ...state.stats });
                setShowMatSelector(false);
                const checkTriageCounts = () => {
                    const counts = { green: 0, yellow: 0, red: 0, black: 0 };
                    state.survivors.forEach(s => {
                        // 計算已抵達對應區域的傷患
                        // ★★★ 修正：排除已上救護車的傷患 (避免安置人數與後送人數重複計算) ★★★
                        if (s.triageTag && !s.onAmbulance) {
                            counts[s.triageTag] = counts[s.triageTag] + 1;

                        }

                    });
                    setTriageCounts(counts);
                };

                const resize = () => {
                    if (!canvas) return;
                    let winW = document.documentElement.clientWidth || window.innerWidth;
                    let winH = document.documentElement.clientHeight || window.innerHeight;
                    // 檢查是否處於「CSS強制橫屏」模式 (即手機直立時)
                    // 注意：需配合 CSS 中的 @media (orientation: portrait) 旋轉設定
                    const isForcedLandscape = window.matchMedia("(max-device-width: 1024px) and (orientation: portrait)").matches;

                    if (isForcedLandscape) {
                        // 因為 CSS 將 body 旋轉了 90 度，所以「視覺上」的寬度其實是 window.innerHeight
                        // 我們需要交換寬高來計算正確的縮放比例
                        [winW, winH] = [winH, winW];
                    }

                    // 計算縮放比例，確保填滿螢幕且不溢出
                    let scale = Math.min(winW / GAME_WIDTH, winH / GAME_HEIGHT);
                    canvas.style.width = `${GAME_WIDTH * scale}px`;
                    canvas.style.height = `${GAME_HEIGHT * scale}px`;
                };

                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;
                window.addEventListener('resize', resize);
                // 增加監聽轉向事件 (針對移動裝置)
                window.addEventListener('orientationchange', () => {
                    setTimeout(resize, 100); // 延遲一下等待瀏覽器重新排版
                });
                resize();

                const PALETTE = {
                    asphalt: '#2d3436', markingWhite: '#b2bec3', markingYellow: '#f1c40f', oil: '#000000', glass: '#81ecec',
                    carColors: ['#e74c3c', '#3498db', '#ecf0f1', '#95a5a6', '#f39c12'],
                    playerVest: '#3498db', playerReflect: '#f1c40f'
                };
                const rand = (min, max) => Math.random() * (max - min) + min;

                const addFeedback = (x, y, text, color = "#fff") => {
                    state.feedbacks.push({ x: x, y: y - 20, text: text, color: color, life: 60, vy: -0.5 });
                };

                // --- 生成車輛與障礙物 (所有X座標都要加上 LEFT_EXPANSION) ---

                // 定義消防車位置 (加上偏移)
                const firetruckData = { type: 'firetruck', x: 50 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 150, w: 300, h: 140, angle: 0.3 };

                // --- 計算消防車前後淨空區域 ---
                const ftClearanceLength = 420;
                const ftClearanceZone = {
                    minX: firetruckData.x - ftClearanceLength,
                    maxX: firetruckData.x + firetruckData.w + ftClearanceLength,
                    minY: firetruckData.y - 50,
                    maxY: firetruckData.y + firetruckData.h + 50
                };

                state.emergencyVehicles.push(firetruckData);
                // ★★★ 初始救護車加入 passengers 與 ID ★★★
                state.emergencyVehicles.push({
                    id: Math.random(), type: 'ambulance', passengers: [], state: 'waiting',
                    x: 80 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 + 100, w: 170, h: 100, angle: -0.2,
                    isStatic: true // ★★★ 標記第一台車為靜態指揮車，不可後送 ★★★
                });

                state.emergencyVehicles.push({ type: 'police', x: 30 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 + 200, w: 80, h: 40, angle: 0.1 });

                // 阻擋方塊 (加上偏移)
                state.obstacles.push({ x: 50 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 150, w: 140, h: 60, type: 'vehicle_block' });
                state.obstacles.push({ x: 80 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 + 100, w: 100, h: 50, type: 'vehicle_block' });
                state.obstacles.push({ x: 30 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 + 200, w: 80, h: 40, type: 'vehicle_block' });

                state.staticNpcs.push({ x: 100 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 70, dir: 1 });
                state.staticNpcs.push({ x: 120 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 70, dir: 1 });
                state.decorations.push({ type: 'stretcher', x: 110 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 55, angle: 0 });

                // 隨機裝飾 (Skid, Oil, Glass) - 範圍從 LEFT_EXPANSION 開始，保持左側乾淨
                for (let i = 0; i < 30; i++) state.decorations.push({ type: 'skid', x: rand(LEFT_EXPANSION, WORLD_WIDTH), y: rand(50, WORLD_HEIGHT - 50), w: rand(50, 150), h: rand(2, 4), angle: rand(-0.2, 0.2) });
                for (let i = 0; i < 30; i++) state.decorations.push({ type: 'oil', x: rand(LEFT_EXPANSION, WORLD_WIDTH), y: rand(50, WORLD_HEIGHT - 50), r: rand(20, 45) });
                for (let i = 0; i < 150; i++) state.decorations.push({ type: 'glass', x: rand(LEFT_EXPANSION, WORLD_WIDTH), y: rand(0, WORLD_HEIGHT), size: rand(1, 3) });

                // 火焰生成 (範圍調整)
                for (let i = 0; i < 8; i++) {
                    // 從 300 + LEFT_EXPANSION 開始生成，確保離起始點有距離
                    let fx = rand(300 + LEFT_EXPANSION, WORLD_WIDTH - 100);
                    let fy = rand(100, WORLD_HEIGHT - 100);

                    if (fx > ftClearanceZone.minX && fx < ftClearanceZone.maxX && fy > ftClearanceZone.minY && fy < ftClearanceZone.maxY) {
                        continue;
                    }

                    state.hazards.push({ id: i, type: 'fire', x: fx, y: fy, r: rand(30, 60), beingExtinguished: false, life: 300 });
                }

                // 金屬碎片生成 (範圍調整)
                for (let i = 0; i < 20; i++) {
                    let mx = rand(100 + LEFT_EXPANSION, WORLD_WIDTH - 100);
                    let my = rand(100, WORLD_HEIGHT - 100);

                    if (mx > ftClearanceZone.minX && mx < ftClearanceZone.maxX && my > ftClearanceZone.minY && my < ftClearanceZone.maxY) {
                        continue;
                    }
                    state.obstacles.push({ type: 'metal_debris', x: mx, y: my, w: rand(20, 40), h: rand(10, 20), angle: rand(0, Math.PI) });
                }

                // 邊界護欄 (更新寬度)
                state.obstacles.push({ x: 0, y: 0, w: WORLD_WIDTH, h: 40, type: 'guardrail' });
                state.obstacles.push({ x: 0, y: WORLD_HEIGHT - 40, w: WORLD_WIDTH, h: 40, type: 'guardrail' });
                // 牆壁位置更新
                state.obstacles.push({ x: -10, y: 0, w: 10, h: WORLD_HEIGHT, type: 'wall' });
                state.obstacles.push({ x: WORLD_WIDTH, y: 0, w: 10, h: WORLD_HEIGHT, type: 'wall' });

                // 一般車輛生成 (範圍調整)
                for (let i = 0; i < 30; i++) {
                    const vehicleTypes = ['sedan', 'truck', 'suv', 'van'];
                    let type = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];
                    // 生成範圍從 300 + LEFT_EXPANSION 開始
                    let x = rand(300 + LEFT_EXPANSION, WORLD_WIDTH - 170);
                    let y = rand(170, WORLD_HEIGHT - 170);
                    let rotated = Math.random() > 0.3;
                    let baseW = 100, baseH = 100;
                    if (type === 'truck') {
                        baseW = 130; baseH = 130;
                    } else if (type === 'suv') {
                        baseW = 110; baseH = 110; // SUV 稍大
                    } else if (type === 'van') {
                        baseW = 120; baseH = 120; // 廂型車介於中間
                    }

                    // 轎車(sedan) 維持 100x100

                    let w = (rotated ? baseH : baseW);
                    let h = (rotated ? baseW : baseH);

                    // 檢查消防車淨空區
                    if (x + w > ftClearanceZone.minX && x < ftClearanceZone.maxX && y + h > ftClearanceZone.minY && y < ftClearanceZone.maxY) {
                        continue;
                    }

                    let overlap = state.obstacles.some(o => x < o.x + o.w + 10 && x + w + 10 > o.x && y < o.y + o.h + 10 && y + h + 10 > o.y);
                    if (!overlap) {
                        state.obstacles.push({
                            x, y, w, h, type, rotated,
                            color: type === 'truck' ? '#fff' : (type === 'van' ? '#95a5a6' : PALETTE.carColors[Math.floor(Math.random() * PALETTE.carColors.length)]),
                            hitbox: { x: x + 2, y: y + 2, w: w - 4, h: h - 4 },
                            isBreached: false, breakTimer: 0
                        });
                    }
                }

                let cars = state.obstacles.filter(o => o.type !== 'guardrail' && o.type !== 'wall' && o.type !== 'vehicle_block' && o.type !== 'metal_debris');
                for (let i = 0; i < totalSurvivors; i++) {
                    let car = cars[Math.floor(Math.random() * cars.length)];
                    // 設定 30% 機率受困於車內 (需破壞)，70% 機率散落在外
                    let inCar = Math.random() > 0.7;

                    let sx, sy;

                    if (inCar && car) {
                        // 【受困車內】：強制位置與車體重疊 (位於車輛中心)
                        sx = car.x + car.w / 2;
                        sy = car.y + car.h / 2;
                    } else {
                        // 【非受困】：位置不能與車體重疊，但可以靠近
                        let validPosition = false;
                        let attempts = 0;

                        // 嘗試尋找合法位置 (最多嘗試 50 次以防無窮迴圈)
                        while (!validPosition && attempts < 50) {
                            attempts++;

                            // 決定生成區域
                            if (car && Math.random() > 0.4) {
                                // 策略 A: 在車輛「附近」生成 (範圍稍大，允許靠近)
                                sx = car.x + rand(-30, car.w + 30);
                                sy = car.y + rand(-30, car.h + 30);
                            } else {
                                // 策略 B: 全地圖隨機
                                sx = rand(350 + LEFT_EXPANSION, WORLD_WIDTH - 150);
                                sy = rand(150, WORLD_HEIGHT - 150);
                            }

                            // 1. 基礎邊界檢查
                            if (sx < 350 + LEFT_EXPANSION) sx = 350 + LEFT_EXPANSION;
                            if (sx > WORLD_WIDTH - 150) sx = WORLD_WIDTH - 150;
                            if (sy < 150) sy = 150;
                            if (sy > WORLD_HEIGHT - 150) sy = WORLD_HEIGHT - 150;

                            // 2. 避開消防車作業淨空區
                            if (sx > ftClearanceZone.minX && sx < ftClearanceZone.maxX && sy > ftClearanceZone.minY && sy < ftClearanceZone.maxY) {
                                continue;
                            }

                            // 3. 【修正】碰撞檢測：加大判定邊距 (Margin)
                            // 傷患繪製半徑約為 15~20px，設定 margin = 20 確保不會與車體重疊
                            let isOverlapping = false;
                            const safeMargin = 20; // ★★★ 修改處：加大邊距 (原為 5) ★★★

                            for (let o of state.obstacles) {
                                // 只檢查實體車輛與車輛阻擋塊
                                // ★★★ 修改：檢查所有實體車輛類型 ★★★
                                if (['sedan', 'truck', 'suv', 'van', 'vehicle_block'].includes(o.type)) {
                                    if (sx > o.x - safeMargin && sx < o.x + o.w + safeMargin &&
                                        sy > o.y - safeMargin && sy < o.y + o.h + safeMargin) {
                                        isOverlapping = true;
                                        break; // 發現重疊
                                    }
                                }
                            }

                            // 如果沒有重疊，標記為合法位置
                            if (!isOverlapping) {
                                validPosition = true;
                            }
                        }

                        // 如果嘗試 50 次都失敗 (極少見)，則強制放置在左側安全空地
                        if (!validPosition) {
                            sx = LEFT_EXPANSION + rand(50, 150);
                            sy = WORLD_HEIGHT / 2 + rand(-50, 50);
                            inCar = false; // 確保標記為非受困
                        }
                    }

                    // 生成傷患數據並加入陣列
                    const data = generateSurvivorData(inCar);
                    state.survivors.push({
                        x: sx, y: sy, found: false, triageTag: null, treatments: [], data: data,
                        // ★★★ 新增：onAmbulance 狀態，標記是否已上車 ★★★
                        tourniquetTimer: data.isBleeding ? 180 : null, isDead: false, isEvacuating: false, isBeingCarried: false, onAmbulance: false, trappedInVehicle: inCar ? car : null,
                        // ★★★ 脈搏評估狀態 ★★★
                        pulseRevealed: false, // 是否已顯示數值
                        pulseMeasuring: false,   // 是否正在倒數中
                        // ★★★ 意識評估狀態 ★★★
                        consciousnessRevealed: false, // 是否已顯示意識
                        consciousnessMeasuring: false // 是否正在評估意識中
                    });
                }
                // --- 新增：取消功能的共用邏輯 ---
                const cancelAction = () => {
                    let performed = false;
                    if (selectedSlotRef.current !== -1) {
                        setSelectedSlot(-1);        // 清除道具欄選中狀態
                        setShowTabletUI(false);     // 關閉平板 UI
                        setShowRadioPanel(false); // 關閉無線電
                        setSelectedPatient(null);   // 清除平板選中的傷患
                        setShowMatSelector(false);  // 關閉地墊選擇器

                        // 強制關閉遊戲內的放置模式
                        state.placementMode.active = false;

                        // 如果是無線電選單，也強制關閉
                        if (state.interactionMenu.mode === 'radio') {
                            state.interactionMenu.active = false;
                            state.interactionMenu.mode = 'main';
                        }

                        // ★★★改為手動推入 feedbacks 陣列，避免 addFeedback 導致當機 ★★★
                        state.feedbacks.push({
                            x: state.player.x,
                            y: state.player.y - 50,
                            text: "已取消道具",
                            color: "#bdc3c7",
                            life: 60,
                            vy: -0.5
                        });
                        performed = true;
                    }
                    // ★★★ 按 C 或右鍵時關閉平板 ★★★
                    if (showTabletUI || showRadioPanel) { // 加入 showRadioPanel 判斷
                        setShowTabletUI(false);
                        setShowRadioPanel(false); // 關閉
                        setSelectedPatient(null);
                        if (!performed && selectedSlotRef.current === -1) {
                            setSelectedSlot(-1);
                        }
                        performed = true;
                    }
                    // 1. 取消放置模式
                    if (state.placementMode.active) {
                        state.placementMode.active = false;
                        setShowMatSelector(false); // 確保UI關閉
                        // ★★★ 手動推入 feedback ★★★
                        state.feedbacks.push({
                            x: state.player.x,
                            y: state.player.y - 50,
                            text: "已取消設置",
                            color: "#bdc3c7",
                            life: 60,
                            vy: -0.5
                        });
                        performed = true;
                    }
                    // 2. 關閉互動選單
                    if (state.interactionMenu.active) {
                        state.interactionMenu.active = false;
                        state.interactionMenu.target = null;
                        state.interactionMenu.mode = 'main';
                        // 避免重複顯示提示
                        if (!performed) {
                            // ★★★ 修正：手動推入 feedback ★★★
                            state.feedbacks.push({
                                x: state.player.x,
                                y: state.player.y - 50,
                                text: "已關閉選單",
                                color: "#bdc3c7",
                                life: 60,
                                vy: -0.5
                            });
                        }
                    }
                    // 3. 補強：確保平板 UI 關閉 (針對非道具選取開啟的情況，若有的話)
                    if (showTabletUI) {
                        setShowTabletUI(false);
                        setSelectedPatient(null);
                        if (!performed && selectedSlotRef.current === -1) {
                            // 只有在還沒處理過時才執行，避免衝突
                            setSelectedSlot(-1);
                        }
                    }
                };
                // --- 新增：滑鼠右鍵處理 (取消) ---
                const handleContextMenu = (e) => {
                    e.preventDefault(); // 阻止瀏覽器預設右鍵選單
                    if (state.isGameOver) return;
                    cancelAction();
                };
                cancelActionRef.current = cancelAction;
                const handleKeyDown = (e) => {
                    const state = gameState.current;
                    if (state.isGameOver) return;
                    // 若玩家忙碌中 (如評估脈搏時)，禁止鍵盤操作 
                    if (state.player.isBusy) return;

                    const menu = state.interactionMenu;
                    const currentSlot = selectedSlotRef.current;
                    // ★★★ 新增：選單鍵盤導航邏輯 ★★★
                    if (menu.active) {
                        // 定義各模式的選項數量
                        const getOptionCount = (mode) => {
                            if (mode === 'main') return 5; // [檢傷、醫療、取消]
                            if (mode === 'triage') return 5; // [綠, 黃, 紅, 黑, 醫療]
                            if (mode === 'treatment') return 3; // [止血, 呼吸]
                            if (mode === 'radio') return 4; // [救護, 消防, 破壞, 搬運]
                            if (mode === 'hazard_fire') return 1;
                            if (mode === 'hazard_vehicle') return 1;
                            return 0;
                        };
                        const count = getOptionCount(menu.mode);

                        // 處理方向鍵 (支援 WASD 與 方向鍵)
                        let change = 0;
                        if (['ArrowLeft'].includes(e.key)) change = -1;
                        if (['ArrowRight'].includes(e.key)) change = 1;
                        if (['ArrowUp'].includes(e.key)) change = -1; // 垂直選單向上
                        if (['ArrowDown'].includes(e.key)) change = 1; // 垂直選單向下

                        if (change !== 0) {
                            menu.selectedIndex = (menu.selectedIndex + change + count) % count;
                            return; // 阻止角色移動 (因為現在 WASD 不會讓 change 變動，所以不會執行這行，角色即可移動)
                        }

                        // 按 E 鍵確認選擇 (模擬點擊該選項的位置)
                        if (e.key === 'e' || e.key === 'E' || e.key === 'Enter') {
                            let targetX = menu.x, targetY = menu.y;
                            const mx = menu.x - 40, my = menu.y - 60;

                            // 根據當前模式與 selectedIndex 計算模擬點擊座標
                            if (menu.mode === 'main') {
                                const btnSize = 40;
                                const topY = my - 45; // 使用 my 計算 topY

                                // 定義按鈕中心點供鍵盤模擬點擊使用
                                if (menu.selectedIndex === 0) { // 檢傷按鈕
                                    targetX = mx + 20; targetY = my + 20;
                                } else if (menu.selectedIndex === 1) { // 醫療按鈕
                                    targetX = mx + 65; targetY = my + 20;
                                } else if (menu.selectedIndex === 2) { // 取消按鈕
                                    targetX = mx + 110; targetY = my + 20;
                                } else if (menu.selectedIndex === 3) { // 左上按鈕 A (脈搏)
                                    targetX = mx + 20; targetY = topY + 20;
                                } else if (menu.selectedIndex === 4) { // 右上按鈕 B (意識)
                                    targetX = mx + 65; targetY = topY + 20;
                                }
                            }
                            else if (menu.mode === 'triage') {
                                if (menu.selectedIndex === 4) { // 右側醫療按鈕
                                    targetX = mx + 65; targetY = my + 20;
                                } else { // 2x2 Grid
                                    const startX = mx - 25; const startY = my - 12;
                                    const btnW = 30, btnH = 30, gap = 5;
                                    const col = menu.selectedIndex % 2;
                                    const row = Math.floor(menu.selectedIndex / 2);
                                    targetX = startX + col * (btnW + gap) + btnW / 2;
                                    targetY = startY + row * (btnH + gap) + btnH / 2;
                                }
                            }
                            if (menu.mode === 'treatment') {
                                if (menu.selectedIndex === 0) { targetX = mx + 40; targetY = my + 2.5; }
                                else if (menu.selectedIndex === 1) { targetX = mx + 40; targetY = my + 32.5; }
                                else { targetX = mx + 40; targetY = my + 62.5; } // ★★★ 新增：取消按鈕的模擬點擊座標 ★★★
                            }
                            else if (menu.mode === 'radio') {
                                const radioX = menu.x - 50; const radioY = menu.y - 120;
                                const btnH = 25, gap = 5;
                                const row = menu.selectedIndex;
                                targetX = radioX + 50;
                                targetY = (radioY + gap) + row * (btnH + gap) + btnH / 2;
                            }
                            else if (['hazard_fire', 'hazard_vehicle'].includes(menu.mode)) {
                                targetX = mx + 40; targetY = my + 20;
                            }

                            // 執行模擬點擊
                            const rect = canvasRef.current.getBoundingClientRect();
                            const scaleX = canvasRef.current.width / rect.width;
                            const scaleY = canvasRef.current.height / rect.height;
                            const clientX = ((targetX - state.camera.x) / scaleX) + rect.left;
                            const clientY = ((targetY - state.camera.y) / scaleY) + rect.top;

                            handleCanvasClick({ clientX, clientY, preventDefault: () => { } });
                            return;
                        }
                    }

                    // ... (保留原有的其他按鍵邏輯，如 C, I 等) ...
                    if (e.key >= '1' && e.key <= '9') handleSlotClick(parseInt(e.key) - 1);
                    else if (e.key === '0') handleSlotClick(9);
                    if (e.key === 'c' || e.key === 'C') { cancelAction(); }
                    if (e.key === 'i' || e.key === 'I') { setShowInventory(prev => !prev); }

                    if (e.key === 'w' || e.key === 'ArrowUp') state.keys.w = true;
                    if (e.key === 's' || e.key === 'ArrowDown') state.keys.s = true;
                    if (e.key === 'a' || e.key === 'ArrowLeft') state.keys.a = true;
                    if (e.key === 'd' || e.key === 'ArrowRight') state.keys.d = true;

                    // --- 按下 E 鍵互動 (僅當選單未開啟時) ---
                    if ((e.key === 'e' || e.key === 'E') && !menu.active) {
                        // ... (保留原有的 E 鍵互動搜尋邏輯) ...
                        const p = state.player;
                        let targetX = p.x;
                        let targetY = p.y;

                        // 1. 放置模式
                        if (state.placementMode.active) {
                            targetX = state.placementMode.x + state.placementMode.w / 2;
                            targetY = state.placementMode.y + state.placementMode.h / 2;
                        }
                        // 2. 一般模式
                        else {
                            const interactRadius = 80;
                            let minDist = Infinity;
                            let bestTarget = null;

                            // (A) 檢查火焰
                            state.hazards.forEach(h => {
                                if (!h.beingExtinguished) {
                                    const dist = Math.hypot(p.x - h.x, p.y - h.y);
                                    if (dist < interactRadius + 20 && dist < minDist) {
                                        minDist = dist; bestTarget = { x: h.x, y: h.y };
                                    }
                                }
                            });
                            // (B) 檢查車輛
                            if (!bestTarget) {
                                state.obstacles.forEach(o => {
                                    if (['sedan', 'truck', 'suv', 'van'].includes(o.type)) {
                                        const cx = o.x + o.w / 2; const cy = o.y + o.h / 2;
                                        const dist = Math.hypot(p.x - cx, p.y - cy);
                                        const survivorInside = state.survivors.find(s => s.trappedInVehicle === o);
                                        if (dist < interactRadius + 20 && survivorInside && !o.isBreached && o.breakTimer === 0) {
                                            if (dist < minDist) { minDist = dist; bestTarget = { x: cx, y: cy }; }
                                        }
                                    }
                                });
                            }
                            // (C) 檢查傷患
                            if (!bestTarget) {
                                state.survivors.forEach(s => {
                                    if ((s.trappedInVehicle && !s.trappedInVehicle.isBreached) || s.isEvacuating || s.isBeingCarried || s.onAmbulance) return;
                                    const dist = Math.hypot(p.x - s.x, p.y - s.y);
                                    if (dist < interactRadius && dist < minDist) {
                                        minDist = dist; bestTarget = { x: s.x, y: s.y };
                                    }
                                });
                            }
                            if (bestTarget) { targetX = bestTarget.x; targetY = bestTarget.y; }
                        }

                        // 執行模擬點擊來開啟選單
                        const rect = canvasRef.current.getBoundingClientRect();
                        const scaleX = canvasRef.current.width / rect.width;
                        const scaleY = canvasRef.current.height / rect.height;
                        const clientX = ((targetX - state.camera.x) / scaleX) + rect.left;
                        const clientY = ((targetY - state.camera.y) / scaleY) + rect.top;

                        handleCanvasClick({ clientX, clientY, preventDefault: () => { } });
                    }
                };

                const handleKeyUp = (e) => {
                    if (state.isGameOver) return;
                    if (e.key === 'w' || e.key === 'ArrowUp') state.keys.w = false;
                    if (e.key === 's' || e.key === 'ArrowDown') state.keys.s = false;
                    if (e.key === 'a' || e.key === 'ArrowLeft') state.keys.a = false;
                    if (e.key === 'd' || e.key === 'ArrowRight') state.keys.d = false;
                };

                const handleMouseMove = (e) => {

                };

                const handleCanvasClick = (e) => {
                    if (state.isGameOver) return;
                    // 若玩家忙碌中，禁止點擊操作 
                    if (state.player.isBusy) return;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const screenClickX = (e.clientX - rect.left) * scaleX;
                    const screenClickY = (e.clientY - rect.top) * scaleY;
                    const clickX = screenClickX + state.camera.x;
                    const clickY = screenClickY + state.camera.y;
                    const player = state.player;
                    const menu = state.interactionMenu;
                    // ★★★ 修正 1: 使用 Ref 取得最新的 selectedSlot ★★★
                    const currentSlot = selectedSlotRef.current;

                    if (state.placementMode.active) {
                        if (state.placementMode.valid) {
                            state.triageMats.push({
                                x: state.placementMode.x,
                                y: state.placementMode.y,
                                w: state.placementMode.w,
                                h: state.placementMode.h,
                                color: state.placementMode.color
                            });
                            addFeedback(state.placementMode.x + state.placementMode.w / 2, state.placementMode.y, "地墊放置完成", "#fff");
                            state.placementMode.active = false;
                        } else {
                            addFeedback(clickX, clickY, "無法放置於此", "#e74c3c");
                        }
                        return;
                    }
                    // --- 新增：工具使用邏輯 (在選單判定之前) ---
                    if (currentSlot !== -1) {
                        const item = items[currentSlot];
                        if (item && (item.type === 'breaker_tool' || item.type === 'extinguisher_tool')) {
                            // 1. 破壞器材 (MP-10)
                            if (item.type === 'breaker_tool') {
                                for (let o of state.obstacles) {
                                    if (['sedan', 'truck', 'suv', 'van'].includes(o.type)) {
                                        // 檢查點擊是否在車輛範圍內
                                        if (clickX > o.x && clickX < o.x + o.w && clickY > o.y && clickY < o.y + o.h) {
                                            if (state.rescueSquads.length > 0) {
                                                addFeedback(clickX, clickY, "破壞小組忙碌中", "#e74c3c");
                                                return;
                                            }
                                            if (!o.isBreached && o.breakTimer === 0) {
                                                if (state.stats.mp >= 10) {
                                                    state.stats.mp -= 10;
                                                    // 派遣破壞小組 (邏輯同 Radio)
                                                    state.rescueSquads.push({
                                                        x: 50 + 700, y: 540 / 2 - 100, target: o, state: 'moving_to_vehicle'
                                                    });
                                                    addFeedback(o.x + o.w / 2, o.y, "派遣破壞小組 (-10 MP)", "#e67e22");
                                                } else {
                                                    addFeedback(clickX, clickY, "MP不足 (需 10)", "#e74c3c");
                                                }
                                            } else {
                                                addFeedback(clickX, clickY, "無需/無法破壞", "#bdc3c7");
                                            }
                                            return; // 阻止後續判定
                                        }
                                    }
                                }
                            }
                            // 2. 滅火器 (MP-10)
                            if (item.type === 'extinguisher_tool') {
                                for (let h of state.hazards) {
                                    const dist = Math.hypot(clickX - h.x, clickY - h.y);
                                    if (dist < h.r) {
                                        if (!h.beingExtinguished) {
                                            if (state.stats.mp >= 10) {
                                                state.stats.mp -= 10;
                                                h.beingExtinguished = true;
                                                // 派遣消防員
                                                state.firefightingSquads.push({
                                                    x: 0, y: 600, target: h, state: 'moving_to_fire'
                                                });
                                                addFeedback(h.x, h.y, "派遣滅火 (-10 MP)", "#3498db");
                                            } else {
                                                addFeedback(clickX, clickY, "MP不足 (需 10)", "#e74c3c");
                                            }
                                        } else {
                                            addFeedback(h.x, h.y, "正在滅火中", "#bdc3c7");
                                        }
                                        return; // 阻止後續判定
                                    }
                                }
                            }
                        }
                    }
                    if (menu.active) {
                        const menuX = menu.x - 40; const menuY = menu.y - 60;

                        if (menu.mode === 'main') {
                            const btnSize = 40;
                            const topY = menuY - 45;

                            // 1. 上方按鈕 A (脈搏)
                            if (clickX >= menuX && clickX <= menuX + btnSize && clickY >= topY && clickY <= topY + btnSize) {
                                const s = menu.target;
                                if (!s.pulseRevealed && !s.pulseMeasuring) {
                                    // 開始評估
                                    s.pulseMeasuring = true;
                                    state.player.isBusy = true; // ★★★ 鎖定玩家 ★★★

                                    // ★★★ 強制停止移動 (清除按鍵狀態) ★★★
                                    state.keys = { w: false, s: false, a: false, d: false };
                                    state.player.moving = false;
                                    addFeedback(menu.x, menu.y - 80, "評估脈搏中...", "#f1c40f");

                                    // 設定 2 秒後顯示數值
                                    setTimeout(() => {
                                        // 檢查傷患是否存在 (避免遊戲重置後報錯)
                                        if (state.survivors.includes(s)) {
                                            s.pulseRevealed = true;
                                            s.pulseMeasuring = false;
                                            addFeedback(s.x, s.y - 80, "評估完成", "#2ecc71");
                                        }
                                        state.player.isBusy = false; // 倒數結束後解除鎖定 
                                    }, 2000);
                                } else if (s.pulseMeasuring) {
                                    addFeedback(menu.x, menu.y - 80, "正在評估...", "#bdc3c7");
                                } else {
                                    addFeedback(menu.x, menu.y - 80, "已完成評估", "#bdc3c7");
                                }
                                return;
                            }

                            // 2. 上方按鈕 B (意識)
                            if (clickX >= menuX + 45 && clickX <= menuX + 45 + btnSize && clickY >= topY && clickY <= topY + btnSize) {
                                const s = menu.target;
                                if (!s.consciousnessRevealed && !s.consciousnessMeasuring) {
                                    // 開始評估
                                    s.consciousnessMeasuring = true;
                                    state.player.isBusy = true; // ★★★ 鎖定玩家 ★★★

                                    // ★★★ 強制停止移動 ★★★
                                    state.keys = { w: false, s: false, a: false, d: false };
                                    state.player.moving = false;
                                    addFeedback(menu.x, menu.y - 80, "評估意識中...", "#f1c40f");

                                    // 設定 2 秒後顯示數值
                                    setTimeout(() => {
                                        // 檢查傷患是否存在 (避免遊戲重置後報錯)
                                        if (state.survivors.includes(s)) {
                                            s.consciousnessRevealed = true;
                                            s.consciousnessMeasuring = false;
                                            addFeedback(s.x, s.y - 80, "評估完成", "#2ecc71");
                                        }
                                        state.player.isBusy = false; // 倒數結束後解除鎖定 
                                    }, 2000);
                                } else if (s.consciousnessMeasuring) {
                                    addFeedback(menu.x, menu.y - 80, "正在評估...", "#bdc3c7");
                                } else {
                                    addFeedback(menu.x, menu.y - 80, "已完成評估", "#bdc3c7");
                                }
                                return;
                            }

                            // 3. 下方按鈕 1 (檢傷)
                            if (clickX >= menuX && clickX <= menuX + btnSize && clickY >= menuY && clickY <= menuY + btnSize) {
                                menu.mode = 'triage';
                                return;
                            }

                            // 4. 下方按鈕 2 (醫療)
                            if (clickX >= menuX + 45 && clickX <= menuX + 45 + btnSize && clickY >= menuY && clickY <= menuY + btnSize) {
                                menu.mode = 'treatment';
                                return;
                            }

                            // 5. 下方按鈕 3 (取消)
                            if (clickX >= menuX + 90 && clickX <= menuX + 90 + btnSize && clickY >= menuY && clickY <= menuY + btnSize) {
                                cancelAction();
                                return;
                            }
                        }
                        else if (menu.mode === 'triage') {
                            const colors = ['green', 'yellow', 'red', 'black'];
                            // 定義 2x2 按鈕參數
                            const btnW = 30;
                            const btnH = 30;
                            const gap = 5;
                            // 讓選單稍微往右移一點，避免遮擋
                            const startX = menuX - 25;
                            const startY = menuY - 12;

                            // --- 新增：檢查是否點擊了右側的「急救按鈕」 ---
                            // 位置與 Main 模式下的右側按鈕相同 (menuX + 45)
                            if (clickX >= menuX + 45 && clickX <= menuX + 85 && clickY >= menuY && clickY <= menuY + 40) {
                                menu.mode = 'treatment';
                                return;
                            }
                            for (let i = 0; i < 4; i++) {
                                // 計算 2x2 位置: 0,1第一列; 2,3第二列
                                let col = i % 2;
                                let row = Math.floor(i / 2);

                                let btnX = startX + col * (btnW + gap);
                                let btnY = startY + row * (btnH + gap);

                                if (clickX >= btnX && clickX <= btnX + btnW && clickY >= btnY && clickY <= btnY + btnH) {
                                    if (menu.target) {
                                        menu.target.triageTag = colors[i];
                                        menu.target.found = true;
                                        menu.target.hasArrived = false; // 重置抵達狀態，讓傷患能再次被搬運或移動
                                        menu.target.isEvacuating = false; // 重置移動狀態 (避免從綠卡轉紅卡時仍繼續自行移動) 
                                        state.survivorsFoundCount = state.survivors.filter(s => s.found).length;
                                        setSurvivorCount(state.survivorsFoundCount);
                                        // 比對傷患實際傷情 (data.severity) 與選擇的顏色 (colors[i])
                                        if (menu.target.data.severity === colors[i]) {
                                            if (!menu.target.hasBeenScored) {
                                                setScore(prev => prev + 100);
                                                addFeedback(menu.x, menu.y - 50, "檢傷正確 +100", "#f1c40f");
                                                menu.target.hasBeenScored = true; // 標記此傷患已獲得分數
                                            }
                                        } else {
                                            //  檢傷錯誤扣 100 分 
                                            setScore(prev => prev - 100);
                                            addFeedback(menu.x, menu.y - 50, "檢傷錯誤 -100", "#e74c3c");
                                        }
                                        addFeedback(menu.x, menu.y, "檢傷完成", colors[i] === 'black' ? '#999' : colors[i]);

                                        // --- 開始：檢查實際傷情 ---
                                        if (colors[i] === 'green') {
                                            // 只有玩家判定為綠色 且 實際傷情(data.severity)也是綠色，才會移動
                                            if (menu.target.data.severity === 'green') {
                                                menu.target.isEvacuating = true;
                                                addFeedback(menu.x, menu.y - 20, "傷患自行移動中...", "#2ecc71");
                                            } else {
                                                // 玩家判斷為輕傷，但實際傷勢較重 -> 無法移動
                                                addFeedback(menu.x, menu.y - 20, "傷勢過重無法移動", "#e74c3c");
                                            }
                                        }
                                        // 檢傷完成後立即檢查計數
                                        checkTriageCounts();
                                    }
                                    menu.active = false; menu.mode = 'main'; return;
                                }
                            }
                        }
                        else if (menu.mode === 'treatment') {
                            if (clickX >= menuX - 20 && clickX <= menuX + 100 && clickY >= menuY - 50 && clickY <= menuY + 25) {
                                statsTracker.current.tourniquet.total++; // 總嘗試次數
                                if (menu.target && menu.target.data) {
                                    if (menu.target.data.isBleeding && !menu.target.isDead) {
                                        //  10% 機率止血失敗 
                                        if (Math.random() < 0.1) {
                                            addFeedback(menu.x, menu.y, "仍再出血!", "#e74c3c");
                                        } else {
                                            setScore(prev => prev + 100);
                                            addFeedback(menu.x, menu.y - 40, "止血正確 +100", "#f1c40f");
                                            menu.target.data.isBleeding = false;
                                            menu.target.tourniquetTimer = null;
                                            addFeedback(menu.x, menu.y, "止血成功", "#2ecc71");
                                        }
                                    } else {
                                        addFeedback(menu.x, menu.y, "無需/無法止血", "#bdc3c7");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                            if (clickX >= menuX - 20 && clickX <= menuX + 100 && clickY >= menuY + 20 && clickY <= menuY + 45) {
                                statsTracker.current.airway.total++; // 總嘗試次數
                                if (menu.target && menu.target.data) {
                                    if (menu.target.isDead) {
                                        addFeedback(menu.x, menu.y, "已死亡 (無效)", "#7f8c8d");
                                    }
                                    if (menu.target.data.resp === '無') {
                                        setScore(prev => prev + 100);
                                        if (Math.random() > 0.5) {
                                            menu.target.data.resp = '恢復 (微弱)';
                                            menu.target.data.severity = 'red';
                                            menu.target.data.injuryText = '氣道阻塞解除';
                                            menu.target.triageTag = null;
                                            addFeedback(menu.x, menu.y, "恢復呼吸!", "#2ecc71");
                                        } else {
                                            addFeedback(menu.x, menu.y, "無效 (仍無呼吸)", "#bdc3c7");
                                        }
                                    } else {
                                        addFeedback(menu.x, menu.y, "呼吸道暢通", "#3498db");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                            // ★★★ 新增：取消按鈕點擊判定 (位置在呼吸道按鈕下方) ★★★
                            if (clickX >= menuX - 20 && clickX <= menuX + 100 && clickY >= menuY + 50 && clickY <= menuY + 75) {
                                cancelAction();
                                return;
                            }
                        }
                        else if (menu.mode === 'hazard_fire') {
                            if (clickX >= menuX - 10 && clickX <= menuX + 90 && clickY >= menuY && clickY <= menuY + 40) {
                                if (state.firefightingSquads.length > 0) {
                                    addFeedback(menu.x, menu.y, "消防隊忙碌中", "#e74c3c");
                                    menu.active = false; menu.mode = 'main'; return;
                                }
                                if (!menu.target.beingExtinguished) {
                                    menu.target.beingExtinguished = true;
                                    state.firefightingSquads.push({
                                        x: 0, y: 600, target: menu.target, state: 'moving_to_fire'
                                    });
                                    addFeedback(menu.x, menu.y, "請求滅火支援...", "#3498db");
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }
                        else if (menu.mode === 'hazard_vehicle') {
                            if (clickX >= menuX - 10 && clickX <= menuX + 90 && clickY >= menuY && clickY <= menuY + 40) {
                                if (state.rescueSquads.length > 0) {
                                    addFeedback(menu.x, menu.y, "破壞小組忙碌中", "#e74c3c");
                                    menu.active = false; menu.mode = 'main'; return;
                                }
                                if (!menu.target.isBreached && menu.target.breakTimer === 0) {
                                    // 修改: 檢查是否已有小組，若無則派遣
                                    const alreadyDispatched = state.rescueSquads.some(s => s.target === menu.target);
                                    if (!alreadyDispatched) {
                                        state.rescueSquads.push({
                                            // 從消防車位置附近出發 (加上偏移量)
                                            x: 50 + 700,
                                            y: 540 / 2 - 100,
                                            target: menu.target,
                                            state: 'moving_to_vehicle'
                                        });
                                        addFeedback(menu.x, menu.y, "破壞器材小組出動!", "#e67e22");
                                    } else {
                                        addFeedback(menu.x, menu.y, "支援已在途中", "#f1c40f");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }
                        // --- 新增：無線電選單處理 (在 interactionMenu.active 內) ---
                        else if (menu.mode === 'radio') {
                            const radioX = menu.x - 50;
                            const radioY = menu.y - 120;
                            const menuW = 100;
                            const menuH = 130;
                            const btnH = 25;
                            const gap = 5;
                            const btnW = menuW - 10;
                            const startX = radioX + 5;

                            // 繪製背景 (為了判斷點擊範圍)
                            // drawRoundedRect(mx, my, 100, 100, 5, 'rgba(0,0,0,0.85)');
                            // ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; ctx.strokeRect(mx, my, 100, 100);
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.font = 'bold 12px "Segoe UI"';
                            // 1. 請求救護車 (扣 MP 10)
                            if (clickX >= startX && clickX <= startX + btnW && clickY >= startY && clickY <= startY + btnH) {
                                // ★★★ 新增：檢查冷卻時間 ★★★
                                if (state.ambulanceCooldown > 0) {
                                    addFeedback(menu.x, menu.y, `調度冷卻中 (${Math.ceil(state.ambulanceCooldown / 60)}s)`, "#bdc3c7");
                                    return; // 直接結束，不執行後續
                                }
                                const stagingArea = state.triageMats.find(m => m.color === 'ambulance_staging');
                                if (!stagingArea) {
                                    // 若未設置，顯示提示並不扣 MP
                                    addFeedback(menu.x, menu.y, "無設置救護車待命區", "#e74c3c");
                                } else {
                                    if (state.stats.mp >= 10) {
                                        state.stats.mp = Math.max(0, state.stats.mp - 10);
                                        // ★★★ 修正：加入這行設定 30 秒冷卻 (60 FPS * 30 = 1800) ★★★
                                        state.ambulanceCooldown = 1500;
                                        // 隨機產生 1~3 台救護車
                                        const ambCount = Math.floor(Math.random() * 3) + 1;
                                        for (let k = 0; k < ambCount; k++) {
                                            // 在待命區範圍內隨機生成位置 (稍微保留邊距)
                                            const ax = stagingArea.x + 10 + Math.random() * (stagingArea.w - 90);
                                            const ay = stagingArea.y + 10 + Math.random() * (stagingArea.h - 60);
                                            const aw = 80;
                                            const ah = 40;
                                            // 加入視覺物件
                                            // ★★★ 修改：無線電生成的救護車加入 passengers 與 ID ★★★
                                            // ★★★ 修改：從畫面左側生成，狀態設為 'arriving' ★★★
                                            // ★★★ 修改：修正變數錯誤，使用 ax, ay 作為目標 ★★★
                                            state.emergencyVehicles.push({
                                                id: Math.random(),
                                                type: 'ambulance',
                                                passengers: [],
                                                state: 'arriving', // 設定為進場中
                                                x: state.camera.x - 150 - (k * 100), // 從畫面左邊外側生成，多台時稍微錯開
                                                y: ay, // 修正：使用 ay 作為垂直位置
                                                targetX: ax, // 修正：使用 ax 作為目標 X
                                                targetY: ay, // 修正：使用 ay 作為目標 Y
                                                w: 1200,
                                                h: 1200,
                                                angle: 0 // 進場時角度歸零
                                            });




                                        }
                                        addFeedback(menu.x, menu.y - 70, "-10 MP (救護車)", "#3498db");
                                        addFeedback(menu.x, menu.y, "救護車趕往中...", "#3498db");
                                    } else {
                                        addFeedback(menu.x, menu.y, "MP不足!", "#e74c3c");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }

                            // 2. 請求消防車 (扣 MP 10)
                            if (clickX >= startX && clickX <= startX + btnW && clickY >= startY + btnH + gap && clickY <= startY + btnH * 2 + gap) {
                                // 搜尋一個未被滅火的火焰
                                const target = state.hazards.find(h => !h.beingExtinguished);
                                if (target) {
                                    if (state.stats.mp >= 10) {
                                        state.stats.mp = Math.max(0, state.stats.mp - 10);
                                        target.beingExtinguished = true;
                                        // 派遣消防員 (從左側擴張區出發)
                                        state.firefightingSquads.push({
                                            x: 50 + 700, y: 540 / 2 - 150, target: target, state: 'moving_to_fire'
                                        });
                                        addFeedback(menu.x, menu.y - 70, "-10 MP (消防車)", "#3498db");
                                        addFeedback(menu.x, menu.y, "派遣消防車支援", "#e74c3c");
                                    } else {
                                        addFeedback(menu.x, menu.y, "MP不足!", "#e74c3c");
                                    }
                                } else {
                                    addFeedback(menu.x, menu.y, "目前無火災需處理", "#2ecc71");
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                            // 3. 請求破壞小組 (扣 MP 10)
                            if (clickX >= startX && clickX <= startX + btnW && clickY >= startY + btnH * 2 + gap * 2 && clickY <= startY + btnH * 3 + gap * 2) {
                                // 搜尋一個: 是車輛 + 未破壞 + 內有傷患 + 尚未有小組前往
                                const target = state.obstacles.find(o =>
                                    ['sedan', 'truck', 'suv', 'van'].includes(o.type) &&
                                    !o.isBreached &&
                                    o.breakTimer === 0 &&
                                    state.survivors.some(s => s.trappedInVehicle === o) &&
                                    !state.rescueSquads.some(sq => sq.target === o)
                                );

                                if (target) {
                                    if (state.stats.mp >= 10) {
                                        state.stats.mp = Math.max(0, state.stats.mp - 10);
                                        // 派遣破壞小組
                                        state.rescueSquads.push({
                                            x: 50 + 700, y: 540 / 2 - 100, target: target, state: 'moving_to_vehicle'
                                        });
                                        addFeedback(menu.x, menu.y - 70, "-10 MP (破壞小組)", "#3498db");
                                        addFeedback(menu.x, menu.y, "派遣破壞小組", "#e67e22");
                                    } else {
                                        addFeedback(menu.x, menu.y, "MP不足!", "#e74c3c");
                                    }
                                } else {
                                    addFeedback(menu.x, menu.y, "無受困車輛需處理", "#bdc3c7");
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                            // ★★★ 新增：4. 請求搬運人員 (扣 MP 10) ★★★
                            // Y軸位置：從第3個按鈕下方開始 (btnH * 3 + gap * 3)
                            if (clickX >= startX && clickX <= startX + btnW && clickY >= startY + btnH * 3 + gap * 3 && clickY <= startY + btnH * 4 + gap * 3) {
                                // 限制：最多 2 組 (自動生成的也會算在內)
                                if (state.npcGroups.length >= 2) {
                                    addFeedback(menu.x, menu.y, "搬運人力已達上限 (2組)", "#e74c3c");
                                    menu.active = false; menu.mode = 'main'; return;
                                }
                                // 搜尋一個：已檢傷(紅黃黑) + 未移動 + 未抵達 + 無人搬運 + 無受困/已破壞 + 安全(無火)
                                const unassignedTargets = state.survivors.filter(s =>
                                    s.triageTag &&
                                    ['red', 'yellow', 'black'].includes(s.triageTag) &&
                                    !s.isEvacuating &&
                                    !s.hasArrived &&
                                    !s.isBeingCarried &&
                                    !state.npcGroups.some(g => g.target === s) &&
                                    (!s.trappedInVehicle || s.trappedInVehicle.isBreached) &&
                                    !state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30)
                                );
                                if (unassignedTargets.length > 0) {
                                    if (state.stats.mp >= 10) {
                                        state.stats.mp = Math.max(0, state.stats.mp - 10);

                                        // 優先順序排序 (黑 > 紅 > 黃)
                                        unassignedTargets.sort((a, b) => {
                                            const p = { 'black': 3, 'red': 2, 'yellow': 1 };
                                            return p[b.triageTag] - p[a.triageTag];
                                        });
                                        const target = unassignedTargets[0];

                                        // 派遣搬運小組 (從左側出現)
                                        state.npcGroups.push({
                                            leaderX: 20 + 700, leaderY: 600,
                                            followerX: 0 + 700, followerY: 600,
                                            target: target,
                                            state: 'moving_to_target',
                                            carrying: false
                                        });

                                        addFeedback(menu.x, menu.y - 70, "-10 MP (搬運人員)", "#3498db");
                                        addFeedback(menu.x, menu.y, "增派搬運人員支援", "#9b59b6");
                                    } else {
                                        addFeedback(menu.x, menu.y, "MP不足!", "#e74c3c");
                                    }
                                } else {
                                    addFeedback(menu.x, menu.y, "目前無傷患需搬運", "#bdc3c7");
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                            // 如果點擊了選單以外的地方...
                            if (clickX < radioX || clickX > radioX + menuW || clickY < radioY || clickY > radioY + menuH) {
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }


                    }



                    const interactRadius = 60;
                    let clickedSomething = false;

                    // 檢查火焰
                    if (!clickedSomething) {
                        for (let h of state.hazards) {
                            const dist = Math.hypot(clickX - h.x, clickY - h.y);
                            if (dist < h.r) {
                                clickedSomething = true;
                                const distToPlayer = Math.hypot(player.x - h.x, player.y - h.y);
                                if (distToPlayer < interactRadius + 50) {
                                    menu.active = true; menu.mode = 'hazard_fire';
                                    menu.x = h.x; menu.y = h.y; menu.target = h;
                                    menu.selectedIndex = 0;
                                } else {
                                    addFeedback(h.x, h.y, "太遠了!", "#e74c3c");
                                }
                                return;
                            }
                        }
                    }

                    // 檢查車輛
                    if (!clickedSomething) {
                        for (let o of state.obstacles) {
                            // 排除非車輛的障礙物
                            if (o.type !== 'guardrail' && o.type !== 'wall' && o.type !== 'vehicle_block' && o.type !== 'metal_debris') {
                                // 檢查點擊座標是否在車輛範圍內
                                if (clickX > o.x && clickX < o.x + o.w && clickY > o.y && clickY < o.y + o.h) {

                                    // ★★★ 修改重點：檢查互動有效性 ★★★
                                    const survivorInside = state.survivors.find(s => s.trappedInVehicle === o);

                                    // 如果「車體已破壞」或「車內無傷患受困」，則視為無互動目標
                                    // 使用 continue 跳過，讓點擊事件可以穿透車輛，被後續的傷患偵測捕捉
                                    if (o.isBreached || !survivorInside) {
                                        continue;
                                    }

                                    // --- 只有「未破壞」且「有人受困」的車輛，才攔截點擊 ---
                                    clickedSomething = true;
                                    const distToPlayer = Math.hypot(player.x - (o.x + o.w / 2), player.y - (o.y + o.h / 2));

                                    if (distToPlayer < interactRadius + 40) {
                                        // 距離足夠，開啟互動選單
                                        menu.active = true;
                                        menu.mode = 'hazard_vehicle';
                                        menu.x = o.x + o.w / 2;
                                        menu.y = o.y;
                                        menu.target = o;
                                        menu.selectedIndex = 0;
                                    } else {
                                        // 距離太遠的提示
                                        addFeedback(o.x + o.w / 2, o.y, "靠近查看", "#e74c3c");
                                    }
                                    return; // 攔截點擊，不再往下檢查傷患
                                }
                            }
                        }
                    }


                    // 檢查傷患
                    for (let s of state.survivors) {
                        const dist = Math.hypot(clickX - s.x, clickY - s.y);
                        if (dist < 25) {
                            clickedSomething = true;
                            let blockedByFire = state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30);
                            if (blockedByFire) { addFeedback(s.x, s.y, "前方有火!", "#e74c3c"); return; }

                            if (s.trappedInVehicle && !s.trappedInVehicle.isBreached) { addFeedback(s.x, s.y, "受困車內!", "#e74c3c"); return; }

                            const distToPlayer = Math.hypot(player.x - s.x, player.y - s.y);
                            if (distToPlayer < interactRadius) {
                                menu.active = true; menu.mode = 'main';
                                menu.x = s.x; menu.y = s.y; menu.target = s;
                                menu.selectedIndex = 0;
                            } else {
                                addFeedback(s.x, s.y, "太遠了!", "#e74c3c");
                            }
                            return;
                        }
                    }

                    if (!clickedSomething && !state.placementMode.active) {
                        addFeedback(clickX, clickY, "●", "rgba(255,255,255,0.5)");
                        player.targetX = clickX;
                        player.targetY = clickY;
                        player.movingToTarget = true;
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                canvas.addEventListener('click', handleCanvasClick);
                window.addEventListener('contextmenu', handleContextMenu);  // 新增：監聽右鍵
                window.addEventListener('mousemove', handleMouseMove);

                const drawRect = (x, y, w, h, color) => { ctx.fillStyle = color; ctx.fillRect(x, y, w, h); };
                const drawCircle = (x, y, r, color) => { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); };

                const drawRoundedRect = (x, y, w, h, r, color) => {
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                    ctx.lineTo(x + r, y + h);
                    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                    ctx.lineTo(x, y + r);
                    ctx.quadraticCurveTo(x, y, x + r, y);
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                };

                const drawFirefighterHighRes = (x, y, angle, color = '#1a253a', frame = 0, moving = false) => {
                    if (color === '#e67e22' && assets.firefighter && assets.firefighter.complete && assets.firefighter.naturalWidth !== 0) {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle);

                        // 設定圖片尺寸 (寬 40 x 高 40，可依據你的圖片比例自行調整)
                        const w = 160;
                        const h = 80;

                        // 簡單的走路搖晃動畫
                        if (moving) {
                            const wobble = Math.sin(frame * 0.2) * 5; // 搖晃角度
                            ctx.rotate(wobble * Math.PI / 180);
                        }

                        // 繪製圖片 (置中)
                        ctx.drawImage(assets.firefighter, -w / 2, -h / 2, w, h);

                        ctx.restore();
                        return; // ★★★ 若成功繪製圖片，直接結束函式，不再畫原本的向量圖 ★★★
                    }
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5;
                    const walkCycle = moving ? Math.sin(frame * 0.2) : 0;
                    const leftLegOffset = walkCycle * 3;
                    const rightLegOffset = -walkCycle * 3;
                    ctx.fillStyle = '#1a253a';
                    ctx.beginPath();
                    drawRoundedRect(-8, -5 + leftLegOffset, 6, 12, 3, '#1a253a');
                    drawRoundedRect(2, -5 + rightLegOffset, 6, 12, 3, '#1a253a');

                    const jacketGrad = ctx.createLinearGradient(-10, -10, 10, 10);
                    jacketGrad.addColorStop(0, '#1a253a'); jacketGrad.addColorStop(1, '#2c3e50');
                    ctx.fillStyle = jacketGrad;
                    ctx.beginPath();
                    ctx.moveTo(-11, -8); ctx.lineTo(11, -8); ctx.lineTo(10, 8); ctx.lineTo(-10, 8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 2; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(-8, -6); ctx.lineTo(8, 6); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(8, -6); ctx.lineTo(-8, 6); ctx.stroke();

                    drawRoundedRect(-4, -4, 8, 12, 3, '#f39c12'); ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.stroke();

                    const helmetGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, 10);
                    helmetGrad.addColorStop(0, '#e74c3c'); helmetGrad.addColorStop(1, '#c0392b');
                    ctx.fillStyle = helmetGrad;
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#922b21'; ctx.beginPath(); ctx.arc(0, 2, 8, 0, Math.PI, false); ctx.fill();
                    ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(0, 8); ctx.stroke();
                    ctx.fillStyle = '#1a253a'; ctx.beginPath(); ctx.arc(-11, -2, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(11, -2, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#95a5a6'; ctx.beginPath(); ctx.arc(-11, 4 + leftLegOffset * 0.5, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(11, 4 + rightLegOffset * 0.5, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                };
                // --- ★★★ 改用插圖繪製傷患 (區分男女) ★★★ ---
                const drawSurvivorHighRes = (s) => {
                    if (s.trappedInVehicle && !s.trappedInVehicle.isBreached) return;
                    ctx.save();
                    ctx.translate(s.x, s.y);

                    // 1. 取得對應性別的圖片
                    // s.data.sex 在生成時已設定為 '男' 或 '女'
                    const survivorImg = assets.survivors[s.data.sex];

                    // 設定圖片繪製尺寸 (根據您的圖片比例進行調整，例如 40x40 或 32x48)
                    const w = 40;
                    const h = 40;

                    // 檢查圖片是否已載入完成
                    if (survivorImg && survivorImg.complete) {
                        // 繪製圖片 (將中心點置於 0,0)
                        // 假設圖片是正面的，若需要隨移動方向旋轉，可自行加入 ctx.rotate()
                        ctx.drawImage(survivorImg, -w / 2, -h / 2, w, h);
                    } else {
                        // (Fallback) 若圖片讀取失敗或尚未載入，顯示替代圓點，避免隱形
                        ctx.fillStyle = s.data.sex === '男' ? '#3498db' : '#e91e63';
                        ctx.beginPath();
                        ctx.arc(0, 0, 10, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // --- ★★★ 修改處：檢傷分類標記改為旋轉圖片 ★★★ ---
                    if (s.triageTag) {
                        const iconImg = triageIcons[s.triageTag];

                        // 確保圖片已載入才繪製，否則使用原本的圓圈作為備案
                        if (iconImg && iconImg.complete) {
                            ctx.save();
                            // 移動到原本圓圈的中心點位置 (0, 2)
                            ctx.translate(0, 2);
                            // 執行旋轉 (速度可調整 0.05)
                            const swayAngle = Math.sin(state.frameCount * 0.1) * 0.3;
                            ctx.rotate(swayAngle);

                            // 設定 Icon 大小 (例如 48x48)
                            const iconSize = 48;
                            // 繪製圖片 (置中)
                            ctx.drawImage(iconImg, -iconSize / 2, -iconSize / 2, iconSize, iconSize);

                            ctx.restore();
                        } else {
                            // (備案) 若圖片讀取失敗或尚未載入，顯示原本的圓圈
                            ctx.strokeStyle = { 'green': '#2ecc71', 'yellow': '#f1c40f', 'red': '#e74c3c', 'black': '#2d3436' }[s.triageTag];
                            ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 2, 22, 0, Math.PI * 2); ctx.stroke();
                        }
                    }

                    // --- 死亡狀態繪製 (保持不變) ---
                    if (s.isDead) {
                        ctx.fillStyle = 'rgba(230,230,230,0.9)';
                        ctx.beginPath(); ctx.ellipse(0, 8, 12, 26, 0, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 1; ctx.stroke();
                    }
                    ctx.restore();
                };

                const drawEmergencyVehicle = (v) => {
                    ctx.save(); ctx.translate(v.x + v.w / 2, v.y + v.h / 2); ctx.rotate(v.angle);
                    ctx.shadowColor = 'rgba(0,0,0,0.4)'; ctx.shadowBlur = 10;
                    if (v.type === 'firetruck') {
                        // ★★★ 若有消防車圖片則繪製圖片，否則繪製原本的向量圖 ★★★
                        const ftImg = assets.firetruck;
                        if (ftImg && ftImg.complete && ftImg.naturalWidth !== 0) {
                            // 繪製圖片 (填滿車輛尺寸)
                            ctx.drawImage(ftImg, -v.w / 2, -v.h / 2, v.w, v.h);
                        } else {
                            // (備案) 原本的向量繪製邏輯
                            drawRoundedRect(-v.w / 2, -v.h / 2, v.w, v.h, 6, '#c0392b');
                            ctx.fillStyle = '#e74c3c'; ctx.fillRect(-v.w / 2 + 5, -v.h / 2 + 5, v.w - 10, v.h - 10);
                            ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.rect(-v.w / 2 + 10, -5, v.w - 20, 10); ctx.fill();
                            for (let x = -v.w / 2 + 15; x < v.w / 2 - 10; x += 10) { ctx.clearRect(x, -3, 2, 6); }
                        }
                    } else if (v.type === 'ambulance') {
                        const ambImg = assets.ambulance;
                        if (ambImg && ambImg.complete && ambImg.naturalWidth !== 0) {
                            ctx.drawImage(ambImg, -v.w / 2, -v.h / 2, v.w, v.h);
                        } else {
                            // (備案) 原本的向量繪製邏輯
                            drawRoundedRect(-v.w / 2, -v.h / 2, v.w, v.h, 6, '#ecf0f1');
                            ctx.fillStyle = '#34495e'; ctx.beginPath();
                            ctx.fillRect(-v.w / 2 + 5, -v.h / 2 + 5, 20, v.h - 10);
                            ctx.fillStyle = '#e74c3c'; ctx.fillRect(-20, -5, 25, 10); ctx.fillRect(-12.5, -12.5, 10, 25);
                        }
                    } else if (v.type === 'police') {
                        // ★★★ 修改：若有警車圖片則繪製圖片，否則繪製原本的向量圖 ★★★
                        const policeImg = assets.police;
                        if (policeImg && policeImg.complete && policeImg.naturalWidth !== 0) {
                            const drawW = 150; // 設定圖片寬度
                            const drawH = 150;  // 設定圖片高度
                            ctx.drawImage(policeImg, -drawW / 2, -drawH / 2, drawW, drawH);
                        } else {
                            // (備案) 原本的向量繪製邏輯
                            drawRoundedRect(-v.w / 2, -v.h / 2, v.w, v.h, 6, '#2c3e50');
                            ctx.fillStyle = '#ecf0f1'; ctx.fillRect(-v.w / 2 + 25, -v.h / 2, 35, v.h);
                            ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-5, -v.h / 2 + 2, 10, v.h - 4);
                        }
                    }
                    // ★★★ 新增：繪製小巴 (若有圖片則繪製圖片) ★★★
                    else if (v.type === 'mini_bus') {
                        const minibusImg = assets.minibus;

                        // 檢查圖片是否載入成功
                        if (minibusImg && minibusImg.complete && minibusImg.naturalWidth !== 0) {
                            // 繪製圖片 (填滿車輛尺寸)
                            ctx.drawImage(minibusImg, -v.w / 2, -v.h / 2, v.w, v.h);
                        } else {
                            // (備案) 若無圖片，維持原本的向量繪製邏輯 (黃色車身)
                            drawRoundedRect(-v.w / 2, -v.h / 2, v.w, v.h, 8, '#f1c40f');
                            ctx.fillStyle = '#2c3e50';
                            // 車窗 (長條型)
                            ctx.fillRect(-v.w / 2 + 10, -v.h / 2 + 5, v.w - 20, v.h - 10);
                            // 車頂燈
                            ctx.fillStyle = '#e67e22';
                            ctx.fillRect(-10, -6, 20, 12);
                        }
                    }


                    ctx.restore();
                };

                const drawFire = (hazard) => {
                    // ★★★ 定義 img (從 assets 取得) 與 size (根據半徑計算) ★★★
                    const img = assets.fire;
                    const size = hazard.r * 2;
                    // 檢查圖片是否載入完成
                    if (img && img.complete) {
                        ctx.save();
                        ctx.translate(hazard.x, hazard.y);

                        // 加入簡單的縮放動態，模擬火焰燃燒忽大忽小
                        // 使用 frameCount 產生正弦波，範圍約 0.9 ~ 1.1
                        const scale = 1 + Math.sin(state.frameCount * 0.2) * 0.1;
                        ctx.scale(scale, scale);

                        // 繪製圖片 (將中心點對齊座標)
                        ctx.drawImage(img, -size / 2, -size / 2, size, size);
                        ctx.restore();
                    } else {
                        // (備案) 若圖片尚未載入或讀取失敗，維持原本的圓形漸層繪製，確保遊戲不會出錯
                        const flicker = Math.random() * 10;
                        const r = hazard.r + flicker;
                        const gradient = ctx.createRadialGradient(hazard.x, hazard.y, r * 0.2, hazard.x, hazard.y, r * 2);
                        gradient.addColorStop(0, 'rgba(255, 100, 0, 0.4)'); gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(hazard.x, hazard.y, r * 2, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = `rgba(255, ${150 + Math.random() * 100}, 0, 0.8)`; ctx.beginPath(); ctx.arc(hazard.x + (Math.random() - 0.5) * 10, hazard.y + (Math.random() - 0.5) * 10, r * 0.5, 0, Math.PI * 2); ctx.fill();
                    }
                };

                const drawMenu = (menu) => {
                    if (!menu.active) return;
                    const mx = menu.x - 40; const my = menu.y - 60;
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
                    // 修改: 若是治療選單，縮短連線以配合向上移動的選單
                    let lineBottom = my + 45;
                    if (menu.mode === 'treatment') lineBottom = my + 15;
                    else if (menu.mode === 'radio') {
                        // 在 radio 模式中，我們將選單向上移動更多 (在下面定義的 radioY)
                        // 但連線的目標點仍然是選單的底部邊緣，即 radioY + menuH (約 -20)
                        // 這裡讓連線畫到比 my 更高的位置 (my - 60 = menu.y - 120)
                        lineBottom = my - 60;
                    }
                    ctx.beginPath(); ctx.moveTo(menu.x, menu.y - 10); ctx.lineTo(menu.x, lineBottom); ctx.stroke();

                    if (menu.mode === 'main') {
                        // === 新增：正上方兩個方形按鈕 (預留插圖位置) ===
                        const topY = my - 45; // 位於原按鈕上方 5px 間隔處 (40px 高 + 5px)

                        // 按鈕 A (位於檢傷按鈕正上方)
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx, topY, 40, 40);
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(mx, topY, 40, 40);
                        if (assets.pulse && assets.pulse.complete && assets.pulse.naturalWidth !== 0) {
                            // 繪製脈搏插圖，置中於 40x40 內 (設定為 32x32)
                            ctx.drawImage(assets.pulse, mx + 4, topY + 4, 32, 32);
                        } else {
                            ctx.fillStyle = '#555';
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText("載入中...", mx + 20, topY + 24);
                        }
                        // 鍵盤選取高亮
                        if (menu.selectedIndex === 3) { ctx.lineWidth = 3; ctx.strokeStyle = '#f1c40f'; ctx.strokeRect(mx, topY, 40, 40); }

                        // 按鈕 B (位於急救按鈕正上方)
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx + 45, topY, 40, 40);
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(mx + 45, topY, 40, 40);
                        if (assets.consciousness && assets.consciousness.complete && assets.consciousness.naturalWidth !== 0) {
                            // 繪製意識狀態插圖，置中於 40x40 內 (設定為 32x32)
                            ctx.drawImage(assets.consciousness, mx + 45 + 4, topY + 4, 32, 32);
                        } else {
                            ctx.fillStyle = '#555';
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText("載入中...", mx + 65, topY + 24);
                        }
                        if (menu.selectedIndex === 4) { ctx.lineWidth = 3; ctx.strokeStyle = '#f1c40f'; ctx.strokeRect(mx + 45, topY, 40, 40); }
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx, my, 40, 40); ctx.strokeStyle = '#fff'; ctx.strokeRect(mx, my, 40, 40);
                        // 修改: 繪製四張重疊的檢傷卡片 (綠黃紅黑)
                        // 依照圖片順序：綠 -> 黃 -> 紅 -> 黑 (由後往前堆疊)
                        const cards = ['green', 'yellow', 'red', 'black'];
                        const stripColors = { 'green': '#00b894', 'yellow': '#f39c12', 'red': '#e74c3c', 'black': '#2d3436' };

                        cards.forEach((c, i) => {
                            // 計算堆疊位置 (每張向右偏移 6px)
                            // 起始 X 設為 mx + 5，讓四張卡片整體居中於 40px 的按鈕內
                            let cx = mx + 5 + (i * 6);
                            let cy = my + 8; // 垂直位置
                            const w = 14;    // 卡片寬度 (稍微縮小以容納四張)
                            const h = 20;    // 卡片高度

                            // 1. 把手 (頂部突起)
                            ctx.fillStyle = '#2d3436'; ctx.fillRect(cx + 5, cy - 3, 4, 3);

                            // 2. 外框 (深色背景)
                            ctx.fillStyle = '#2d3436'; ctx.fillRect(cx, cy, w, h);

                            // 3. 本體 (米色)
                            ctx.fillStyle = '#fff8e1'; ctx.fillRect(cx + 1, cy + 1, w - 2, h - 2);

                            // 4. 顏色條 (底部色帶)
                            ctx.fillStyle = stripColors[c]; ctx.fillRect(cx + 1, cy + h - 4, w - 2, 3);

                            // 5. 表情 (簡化版像素點)
                            ctx.fillStyle = '#2d3436';
                            ctx.fillRect(cx + 3, cy + 5, 2, 2); // 左眼
                            ctx.fillRect(cx + 9, cy + 5, 2, 2); // 右眼
                            ctx.fillRect(cx + 5, cy + 10, 4, 1); // 嘴巴
                        });
                        // --- 右側按鈕 (醫療) ---
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx + 45, my, 40, 40); ctx.strokeStyle = '#fff'; ctx.strokeRect(mx + 45, my, 40, 40);
                        // --- 插入 PIC/BASIC.png 圖片 ---
                        if (assets.basic && assets.basic.complete && assets.basic.naturalWidth !== 0) {
                            // 繪製圖片於 40x40 按鈕內，置中並縮放至 32x32 以保留邊框感
                            ctx.drawImage(assets.basic, mx + 45 + 4, my + 4, 32, 32);
                        } else {
                            // 圖片載入中或失敗時顯示文字備案
                            ctx.fillStyle = '#555';
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText("載入中...", mx + 65, my + 24);
                        }
                        // 若該按鈕被選中（鍵盤導航），顯示高亮邊框
                        if (menu.selectedIndex === 1) {
                            ctx.lineWidth = 3;
                            ctx.strokeStyle = '#f1c40f'; // 黃色高亮
                            ctx.strokeRect(mx + 45, my, 40, 40);
                        }
                        if (menu.selectedIndex === 1) ctx.strokeRect(mx + 45, my, 40, 40);
                        // ★★★ 新增：繪製方形 X 取消按鈕 ★★★
                        const closeX = mx + 90;
                        const closeY = my;

                        // 背景 (深紅色)
                        ctx.fillStyle = '#c0392b';
                        ctx.fillRect(closeX, closeY, 40, 40);

                        // 邊框
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(closeX, closeY, 40, 40);

                        // 繪製 X 圖示
                        ctx.beginPath();
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        ctx.moveTo(closeX + 10, closeY + 10);
                        ctx.lineTo(closeX + 30, closeY + 30);
                        ctx.moveTo(closeX + 30, closeY + 10);
                        ctx.lineTo(closeX + 10, closeY + 30);
                        ctx.stroke();

                        // 鍵盤選取時的高亮 (黃色邊框)
                        if (menu.selectedIndex === 2) {
                            ctx.lineWidth = 3;
                            ctx.strokeStyle = '#f1c40f';
                            ctx.strokeRect(closeX, closeY, 40, 40);
                        }
                    } else if (menu.mode === 'triage') {
                        // --- 修改開始: 替換為圖片風格的圖示 ---
                        const colors = ['green', 'yellow', 'red', 'black'];
                        const btnW = 30;
                        const btnH = 30;
                        const gap = 5;
                        // 往左移以騰出空間
                        const startX = mx - 25;
                        const startY = my - 12; // 垂直置中
                        // 背景稍微加高以容納新圖示
                        // 繪製背景 (調整為方形以容納 2x2)
                        ctx.fillStyle = 'rgba(0,0,0,0.85)';
                        ctx.fillRect(startX - 5, startY - 5, (btnW * 2) + gap + 10, (btnH * 2) + gap + 10);
                        ctx.strokeStyle = '#555';
                        ctx.strokeRect(startX - 5, startY - 5, (btnW * 2) + gap + 10, (btnH * 2) + gap + 10);
                        colors.forEach((c, i) => {
                            let col = i % 2;
                            let row = Math.floor(i / 2);

                            let bx = startX + col * (btnW + gap);
                            let by = startY + row * (btnH + gap);

                            // 繪製按鈕底色
                            const stripColors = { 'green': '#00b894', 'yellow': '#f39c12', 'red': '#e74c3c', 'black': '#2d3436' };

                            // 外框
                            ctx.fillStyle = '#2d3436';
                            ctx.fillRect(bx, by, btnW, btnH);

                            // 內部 (米色)
                            ctx.fillStyle = '#fff8e1';
                            ctx.fillRect(bx + 2, by + 2, btnW - 4, btnH - 4);

                            // 顏色標籤 (佔據下半部較大區域)
                            ctx.fillStyle = stripColors[c];
                            ctx.fillRect(bx + 2, by + btnH - 8, btnW - 4, 6);

                            // 表情 (眼睛)
                            ctx.fillStyle = '#2d3436';
                            ctx.fillRect(bx + 8, by + 10, 3, 3);  // 左眼
                            ctx.fillRect(bx + 19, by + 10, 3, 3); // 右眼

                            // 嘴巴 (根據顏色做點變化)
                            if (c === 'green') { // 笑臉
                                ctx.fillRect(bx + 10, by + 18, 2, 2);
                                ctx.fillRect(bx + 18, by + 18, 2, 2);
                                ctx.fillRect(bx + 12, by + 20, 6, 2);
                            } else if (c === 'black') { // X嘴
                                ctx.beginPath(); ctx.moveTo(bx + 12, by + 18); ctx.lineTo(bx + 18, by + 22); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(bx + 18, by + 18); ctx.lineTo(bx + 12, by + 22); ctx.stroke();
                            } else { // 平嘴
                                ctx.fillRect(bx + 12, by + 19, 6, 2);
                            }
                            if (menu.selectedIndex === i) {
                                ctx.lineWidth = 3; ctx.strokeStyle = '#f1c40f';
                                ctx.strokeRect(bx, by, btnW, btnH);
                            }
                        });

                        // --- 新增：繪製右側常駐的「醫療按鈕」 ---
                        // (複製自 Main Mode)
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx + 45, my, 40, 40); ctx.strokeStyle = '#fff'; ctx.strokeRect(mx + 45, my, 40, 40);
                        ctx.fillStyle = '#2ecc71'; ctx.fillRect(mx + 62, my + 10, 6, 20); ctx.fillRect(mx + 55, my + 17, 20, 6);
                        if (menu.selectedIndex === 4) {
                            ctx.lineWidth = 3; ctx.strokeStyle = '#f1c40f';
                            ctx.strokeRect(mx + 45, my, 40, 40);
                        }
                    } else if (menu.mode === 'treatment') {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(mx - 25, my - 15, 130, 100);
                        ctx.fillStyle = '#e74c3c'; ctx.fillRect(mx - 20, my - 10, 120, 25);
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("使用止血帶", mx - 10, my + 7);
                        ctx.fillStyle = '#3498db'; ctx.fillRect(mx - 20, my + 20, 120, 25);
                        ctx.fillStyle = 'white'; ctx.fillText("暢通呼吸道", mx - 10, my + 37);
                        ctx.fillStyle = '#7f8c8d'; // 使用灰色區隔
                        ctx.fillRect(mx - 20, my + 50, 120, 25);
                        ctx.fillStyle = 'white';
                        ctx.fillText("取消 (Cancel)", mx - 10, my + 67);
                        ctx.lineWidth = 2; ctx.strokeStyle = '#f1c40f';
                        if (menu.selectedIndex === 0) ctx.strokeRect(mx - 20, my - 10, 120, 25);
                        if (menu.selectedIndex === 1) ctx.strokeRect(mx - 20, my + 20, 120, 25);
                        if (menu.selectedIndex === 2) ctx.strokeRect(mx - 20, my + 50, 120, 25);
                    } else if (menu.mode === 'hazard_fire') {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(mx - 10, my, 100, 40);
                        ctx.fillStyle = '#3498db'; ctx.fillRect(mx - 5, my + 5, 90, 30);
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("請求滅火", mx + 15, my + 25);
                    } else if (menu.mode === 'hazard_vehicle') {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(mx - 10, my, 100, 40);
                        ctx.fillStyle = '#e67e22'; ctx.fillRect(mx - 5, my + 5, 90, 30);
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("破壞車體", mx + 15, my + 25);
                        // 【修改】無線電選單繪製邏輯
                    } else if (menu.mode === 'radio') {
                        // 選單畫在玩家頭上 (menu.x, menu.y - 60)
                        // 這裡的 radioX/Y 必須與 handleCanvasClick 中的定義一致
                        const radioX = menu.x - 50; // 往左移 50px
                        const radioY = menu.y - 120; // 往上移更多 (menu.y - 60 剛好是 my，所以這裡設定 -120 讓它高出 mx/my 60px)
                        const menuW = 100;
                        const menuH = 130;
                        const btnH = 25;
                        const gap = 5;
                        const btnW = menuW - 10;

                        // 繪製背景
                        drawRoundedRect(radioX, radioY, menuW, menuH, 5, 'rgba(0,0,0,0.85)');
                        ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; ctx.strokeRect(radioX, radioY, menuW, menuH);

                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.font = 'bold 12px "Segoe UI"';
                        const radioOptions = [
                            { label: "請求救護車", color: '#3498db' },     // 藍
                            { label: "請求消防車", color: '#e74c3c' },     // 紅
                            { label: "請求破壞小組", color: '#e67e22' },   // 橘
                            { label: "請求搬運人員", color: '#9b59b6' }    // 紫
                        ];
                        // 統一繪製按鈕與高亮框
                        radioOptions.forEach((opt, i) => {
                            const by = (radioY + gap) + i * (btnH + gap);

                            // 繪製按鈕本體
                            ctx.fillStyle = opt.color;
                            ctx.fillRect(radioX + 5, by, btnW, btnH);

                            // 繪製文字
                            ctx.fillStyle = 'white';
                            ctx.fillText(opt.label, radioX + menuW / 2, by + btnH / 2);

                            // 繪製選中高亮 (原本的迴圈邏輯整合至此)
                            if (menu.selectedIndex === i) {
                                ctx.lineWidth = 3; ctx.strokeStyle = '#f1c40f';
                                ctx.strokeRect(radioX + 5, by, btnW, btnH);
                            }
                        });
                    }


                };




                const drawSurvivorInfo = (player) => {
                    const interactRadius = 60;
                    // --- 修改開始：定義左側區域邊界 ---
                    // 消防車位置約在 750 (50 + 700)，設定 950 為界線，涵蓋左側與消防車周邊
                    const safeZoneBoundary = 950;
                    state.survivors.forEach(s => {
                        // 判斷該傷患是否為當前選單的目標
                        const isMenuTarget = state.interactionMenu.active && state.interactionMenu.target === s;
                        const distToPlayer = Math.hypot(player.x - s.x, player.y - s.y);
                        // --- 修改顯示邏輯 ---
                        // 1. 檢查是否在左側安全區域 (inSafeZone)
                        const inSafeZone = s.x < safeZoneBoundary;

                        // 2. 顯示條件：
                        //    (A) 是當前點擊的目標 (isMenuTarget) -> 絕對顯示
                        //    (B) 距離夠近 + 有檢傷卡 + "不在"安全區域 -> 自動顯示
                        const showInfo = isMenuTarget || (distToPlayer < interactRadius && s.triageTag && !inSafeZone);
                        if (showInfo && !s.isBeingCarried && !s.isEvacuating) {
                            // 定義資訊欄尺寸
                            const w = 140;
                            const h = 130;

                            // 基礎間距
                            let gap = 20;
                            // --- 修改開始: 動態計算避讓偏移量 ---
                            let leftOffset = 40;  // 預設向左偏移 (資訊欄在左時，距離 s.x 的距離)
                            let rightOffset = 20; // 預設向右偏移 (資訊欄在右時，距離 s.x 的距離)
                            // 如果選單開啟中，加大間距以避開選單 (選單寬度約 130px 左右，設 85 安全)
                            if (isMenuTarget) {
                                const mode = state.interactionMenu.mode;
                                // 根據選單模式的寬度設定邊界，確保不重疊
                                if (mode === 'triage') {
                                    // 檢傷模式 (2x2 Grid)
                                    // 左邊界約為 -65 (s.x - 65)，我們設 75 留緩衝
                                    // 右邊界約為 +15 (s.x + 15)，我們設 25 留緩衝
                                    leftOffset = 75;
                                    rightOffset = 25;
                                } else if (mode === 'treatment') {
                                    // 治療模式 (寬條狀)
                                    // 左右邊界較寬 (-65 ~ +65)
                                    leftOffset = 75;
                                    rightOffset = 75;
                                } else {
                                    // 主選單 (Main)
                                    // 左邊界 -40, 右邊界 +85 (含右側醫療按鈕)
                                    leftOffset = 50;
                                    rightOffset = 90;
                                }
                            }

                            // --- 修改開始: 判斷顯示位置 ---
                            let infoX;
                            // 如果傷患在玩家的左邊 (s.x < player.x)，資訊欄顯示在傷患右邊
                            if (s.x < player.x) {
                                infoX = s.x + rightOffset;
                            } else {
                                // 如果傷患在玩家的右邊 (s.x > player.x)，資訊欄顯示在傷患左邊
                                // 減去寬度 (w) 和偏移量 (20)
                                infoX = s.x - leftOffset - w;
                            }
                            // Y 軸維持原樣 (顯示在上方)
                            const infoY = s.y - 40;
                            drawRoundedRect(infoX, infoY, w, h, 5, 'rgba(0, 0, 0, 0.8)');
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(infoX, infoY, w, h);
                            ctx.font = '10px "Segoe UI"'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';

                            const d = s.data;
                            let yOffset = infoY + 8; const lineHeight = 16;
                            ctx.fillStyle = '#ecf0f1';
                            ctx.fillText(`性別: ${d.sex}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`年齡: ${d.age} 歲`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`傷情: ${d.injuryText}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`呼吸: ${d.resp}`, infoX + 8, yOffset); yOffset += lineHeight;
                            // 根據狀態顯示脈搏數值 
                            let pulseText = "???";
                            if (s.pulseRevealed) {
                                pulseText = d.pulse;
                            } else if (s.pulseMeasuring) {
                                pulseText = "評估中...";
                            }
                            ctx.fillText(`脈搏: ${pulseText}`, infoX + 8, yOffset); yOffset += lineHeight;
                            // 根據狀態顯示意識數值 
                            let consciousnessText = "???";
                            if (s.consciousnessRevealed) {
                                consciousnessText = d.consciousness;
                            } else if (s.consciousnessMeasuring) {
                                consciousnessText = "評估中...";
                            }
                            ctx.fillText(`意識: ${consciousnessText}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`四肢大出血: ${d.isBleeding ? '是' : '否'}`, infoX + 8, yOffset);
                            yOffset += lineHeight;


                            ctx.fillText(`汙染: ${d.isContaminated ? '是 (需除汙)' : '否'}`, infoX + 8, yOffset);
                        }
                    });
                };

                const drawNPCGroups = (groups) => {
                    groups.forEach(group => {
                        // ★★★ 使用圖片繪製搬運人員 ★★★
                        const size = 80; // 設定圖片顯示大小 (可依圖片比例調整)
                        const img = assets.emt; // 取得預載的 emt 圖片

                        // 1. 繪製跟隨者 (後方人員)
                        if (img && img.complete) {
                            ctx.drawImage(img, group.followerX - size / 2, group.followerY - size / 2, size, size);
                        } else {
                            // 圖片未載入時的備案 (維持原樣)
                            drawFirefighterHighRes(group.followerX, group.followerY, 0, '#1a253a', state.frameCount, true);
                        }
                        // 4. 繪製擔架上的傷患 (保持不變)
                        if (group.carrying && group.target) {
                            // ★★★ 關鍵修改：將傷患位置暫時鎖定在搬運人員位置 ★★★
                            // 這樣即使 update 邏輯還在計算雙人中點，視覺上會正確顯示在單人身上
                            const originalX = group.target.x;
                            const originalY = group.target.y;

                            // 設定繪製位置 (稍微偏移以增加層次感，例如 y+5)
                            group.target.x = group.leaderX;
                            group.target.y = group.leaderY + 5;

                            // 使用原本的插圖繪製函式
                            drawSurvivorHighRes(group.target);

                            // 繪製完畢後還原座標，避免影響其他邏輯
                            group.target.x = originalX;
                            group.target.y = originalY;
                        }
                    });
                };

                const drawFirefighters = (squads) => {
                    squads.forEach(s => {
                        drawFirefighterHighRes(s.x, s.y, 0, '#e67e22', state.frameCount, s.state === 'moving_to_fire');
                        drawFirefighterHighRes(s.x - 20, s.y + 10, 0, '#e67e22', state.frameCount, s.state === 'moving_to_fire');
                        if (s.state === 'extinguishing') {
                            const waterImg = assets.water;
                            if (waterImg && waterImg.complete && waterImg.naturalWidth !== 0) {
                                const dx = s.target.x - s.x;
                                const dy = s.target.y - s.y;
                                const dist = Math.hypot(dx, dy);
                                const angle = Math.atan2(dy, dx);

                                ctx.save();
                                ctx.translate(s.x, s.y);
                                ctx.rotate(angle);

                                // 繪製水線圖片
                                // 參數：圖片, x(起點), y(垂直置中), width(拉長至目標距離), height(設定寬度)
                                // 假設圖片原向為水平向右
                                ctx.drawImage(waterImg, 0, -10, dist, 45);

                                ctx.restore();
                            } else {
                                // (備案) 原本的向量繪製邏輯
                                ctx.strokeStyle = 'rgba(52, 152, 219, 0.7)'; ctx.lineWidth = 4;
                                ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.target.x, s.target.y); ctx.stroke();
                            }
                        }
                    });
                };
                // 新增: 繪製破壞小組 (含破壞剪動畫)
                const drawRescueSquads = (squads) => {
                    if (!squads) return; // ★★★ 修正 3: 加入安全檢查，防止 squads 為 undefined 時導致黑畫面 ★★★
                    squads.forEach(s => {
                        if (!s.target) return; // ★★★ 修正 4: 確保目標存在，避免讀取 s.target.y 時報錯 ★★★
                        // 1. 主操作手
                        drawFirefighterHighRes(s.x, s.y, 0, '#e67e22', state.frameCount, s.state !== 'breaking');

                        // 2. 副手 (稍微跟在後面)
                        drawFirefighterHighRes(s.x - 20, s.y + 15, 0, '#e67e22', state.frameCount, s.state !== 'breaking');

                        // 3. 繪製破壞器材 (僅在破壞狀態時顯示作動)
                        if (s.state === 'breaking') {
                            const toolImg = assets.breaker;

                            if (toolImg && toolImg.complete && toolImg.naturalWidth !== 0) {
                                ctx.save();
                                // 將座標原點移到主操作手前方
                                ctx.translate(s.x + 10, s.y);

                                // 計算目標車輛方向，讓器材指向車輛
                                const angle = Math.atan2(s.target.y - s.y, s.target.x - s.x);
                                ctx.rotate(angle);

                                // 模擬破壞時的震動效果
                                const vibration = Math.sin(state.frameCount * 0.8);

                                // 設定圖片尺寸 (寬度與高度可依圖片比例調整)
                                const w = 60;
                                const h = 60;

                                // 繪製圖片 (加入震動位移)
                                // 假設圖片是水平向右的工具
                                ctx.drawImage(toolImg, 0 + vibration, -h / 2, w, h);

                                // 破壞火花特效 (保留)
                                if (Math.random() > 0.7) {
                                    ctx.fillStyle = '#f1c40f';
                                    ctx.fillRect(w + Math.random() * 10, (Math.random() - 0.5) * 10, 2, 2);
                                }
                                ctx.restore();
                            } else {
                                // (備案) 原本的向量繪製邏輯
                                ctx.save();
                                ctx.translate(s.x + 10, s.y);
                                const angle = Math.atan2(s.target.y - s.y, s.target.x - s.x);
                                ctx.rotate(angle);
                                const bite = Math.sin(state.frameCount * 0.5) * 0.5;
                                ctx.fillStyle = '#555'; ctx.fillRect(0, -4, 25, 8);
                                ctx.fillStyle = '#222'; ctx.fillRect(5, -8, 4, 16);
                                ctx.save(); ctx.translate(25, -2); ctx.rotate(-0.5 + bite); ctx.fillStyle = '#d35400';
                                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(15, -4); ctx.lineTo(12, 4); ctx.fill(); ctx.restore();
                                ctx.save(); ctx.translate(25, 2); ctx.rotate(0.5 - bite); ctx.fillStyle = '#d35400';
                                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(15, 4); ctx.lineTo(12, -4); ctx.fill(); ctx.restore();
                                if (Math.random() > 0.7) { ctx.fillStyle = '#f1c40f'; ctx.fillRect(38 + Math.random() * 10, (Math.random() - 0.5) * 10, 2, 2); }
                                ctx.restore();
                            }
                        }
                    });
                };
                const drawStaticNpcs = (npcs) => {
                    npcs.forEach(npc => { drawFirefighterHighRes(npc.x, npc.y, 0, '#1a253a', state.frameCount, false); });
                    state.decorations.forEach(d => {
                        if (d.type === 'stretcher') {
                            ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 6;
                            ctx.beginPath(); ctx.moveTo(d.x - 10, d.y); ctx.lineTo(d.x + 10, d.y); ctx.stroke();
                        }
                    });
                };


                const drawTriageMats = (mats) => {
                    mats.forEach(m => {
                        ctx.save();
                        // ★★★ 新增：紅色區域繪製邏輯 (優先使用圖片) ★★★
                        if (m.color === 'red' && assets.red_zone && assets.red_zone.complete && assets.red_zone.naturalWidth !== 0) {
                            // ★★★ 修改：自定義圖片尺寸 (可在此處修改寬高數值) ★★★
                            const drawW = 200; // 自定義寬度 (原 m.w 約為 100-160)
                            const drawH = 200; // 自定義高度

                            // 計算置中位置 (讓圖片中心對齊區域中心)
                            const drawX = m.x + (m.w - drawW) / 2;
                            const drawY = m.y + (m.h - drawH) / 2;
                            // 1. 繪製圖片 (填滿區域)(使用自定義尺寸)
                            ctx.drawImage(assets.red_zone, drawX, drawY, drawW, drawH);

                            // 2. 繪製文字標籤 (加上黑色陰影以確保在圖片上清晰可見)
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 4;
                            ctx.fillText('重傷區', m.x + m.w / 2, m.y + m.h / 2);

                            ctx.shadowBlur = 0; // 重置陰影
                            ctx.restore();
                            return; // ★ 成功繪製圖片後，直接結束函式
                        }
                        // ★★★ 新增：黃色區域繪製邏輯 (優先使用圖片) ★★★
                        if (m.color === 'yellow' && assets.yellow_zone && assets.yellow_zone.complete && assets.yellow_zone.naturalWidth !== 0) {
                            // ★★★ 修改：自定義圖片尺寸 (可在此處修改寬高數值) ★★★
                            const drawW = 150; // 自定義寬度
                            const drawH = 150; // 自定義高度

                            // 計算置中位置 (讓圖片中心對齊區域中心)
                            const drawX = m.x + (m.w - drawW) / 2;
                            const drawY = m.y + (m.h - drawH) / 2;

                            // 1. 繪製圖片 (使用自定義尺寸)
                            ctx.drawImage(assets.yellow_zone, drawX, drawY, drawW, drawH);

                            // 2. 繪製文字標籤 (加上黑色陰影以確保在圖片上清晰可見)
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 4;
                            ctx.fillText('中傷區', m.x + m.w / 2, m.y + m.h / 2);

                            ctx.shadowBlur = 0; // 重置陰影
                            ctx.restore();
                            return; // ★ 成功繪製圖片後，直接結束函式
                        }
                        // ★★★ 新增：綠色區域繪製邏輯 (優先使用圖片) ★★★
                        if (m.color === 'green' && assets.green_zone && assets.green_zone.complete && assets.green_zone.naturalWidth !== 0) {
                            // ★★★ 修改：自定義圖片尺寸 (可在此處修改寬高數值) ★★★
                            const drawW = 150; // 自定義寬度
                            const drawH = 150; // 自定義高度

                            // 計算置中位置 (讓圖片中心對齊區域中心)
                            const drawX = m.x + (m.w - drawW) / 2;
                            const drawY = m.y + (m.h - drawH) / 2;

                            // 1. 繪製圖片 (使用自定義尺寸)
                            ctx.drawImage(assets.green_zone, drawX, drawY, drawW, drawH);

                            // 2. 繪製文字標籤 (加上黑色陰影以確保在圖片上清晰可見)
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 4;
                            ctx.fillText('輕傷區', m.x + m.w / 2, m.y + m.h / 2);

                            ctx.shadowBlur = 0; // 重置陰影
                            ctx.restore();
                            return; // ★ 成功繪製圖片後，直接結束函式
                        }
                        // ★★★ 新增：黑色區域繪製邏輯 (優先使用圖片) ★★★
                        if (m.color === 'black' && assets.black_zone && assets.black_zone.complete && assets.black_zone.naturalWidth !== 0) {
                            // ★★★ 修改：自定義圖片尺寸 (可在此處修改寬高數值) ★★★
                            const drawW = 150; // 自定義寬度 
                            const drawH = 150; // 自定義高度

                            // 計算置中位置 (讓圖片中心對齊區域中心)
                            const drawX = m.x + (m.w - drawW) / 2;
                            const drawY = m.y + (m.h - drawH) / 2;
                            // 1. 繪製圖片 (填滿區域)(使用自定義尺寸)
                            ctx.drawImage(assets.black_zone, drawX, drawY, drawW, drawH);

                            // 2. 繪製文字標籤 (加上黑色陰影以確保在圖片上清晰可見)
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 4;
                            ctx.fillText('臨時停屍間', m.x + m.w / 2, m.y + m.h / 2);

                            ctx.shadowBlur = 0; // 重置陰影
                            ctx.restore();
                            return; // ★ 成功繪製圖片後，直接結束函式
                        }
                        // ★★★ 修改：若為指揮站且圖片已載入，優先繪製圖片 ★★★
                        if (m.color === 'command_post' && assets.command_post && assets.command_post.complete && assets.command_post.naturalWidth !== 0) {
                            // 1. 繪製指揮站圖片 (填滿區域)
                            ctx.drawImage(assets.command_post, m.x, m.y, m.w, m.h);

                            // 2. 繪製文字標籤 (加上黑色陰影以確保在圖片上清晰可見)
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 4;
                            ctx.fillText('指揮站', m.x + m.w / 2, m.y + m.h / 2);

                            // 3. 繪製 HP/MP 恢復動態提示 (保持與原版一致的動畫)
                            const blink = Math.sin(state.frameCount * 0.1) * 3;
                            ctx.fillStyle = '#2ecc71'; // 綠色 HP
                            ctx.font = 'bold 20px Arial';
                            // 繪製 "+ HP"
                            ctx.fillText('+', m.x + m.w / 2 - 10, m.y + m.h / 2 + 30 + blink);
                            ctx.fillText('HP', m.x + m.w / 2 + 5, m.y + m.h / 2 + 30 + blink);

                            ctx.shadowBlur = 0; // 重置陰影
                            ctx.restore();
                            return; // ★ 成功繪製圖片後，直接結束此物件的繪製，跳過下方的 fallback
                        }
                        // ★★★ 新增：若為除汙站且圖片已載入，優先繪製圖片 ★★★
                        if (m.color === 'decon' && assets.decon && assets.decon.complete && assets.decon.naturalWidth !== 0) {
                            // 1. 繪製除汙站圖片 (填滿區域)
                            ctx.drawImage(assets.decon, m.x, m.y, m.w, m.h);

                            // 2. 繪製文字標籤 (加上黑色陰影以確保在圖片上清晰可見)
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 4;
                            ctx.fillText('除汙站', m.x + m.w / 2, m.y + m.h / 2);

                            ctx.shadowBlur = 0; // 重置陰影
                            ctx.restore();
                            return; // ★ 成功繪製圖片後，直接結束函式，跳過下方的 fallback
                        }
                        // ★★★ 新增：若為救護車待命區且圖片已載入，優先繪製圖片 ★★★
                        if (m.color === 'ambulance_staging' && assets.ambulance_staging && assets.ambulance_staging.complete && assets.ambulance_staging.naturalWidth !== 0) {
                            // 1. 繪製救護車待命區圖片 (填滿區域)
                            ctx.drawImage(assets.ambulance_staging, m.x, m.y, m.w, m.h);

                            // 2. 繪製文字標籤 (加上黑色陰影以確保在圖片上清晰可見)
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 4;
                            ctx.fillText('救護車待命區', m.x + m.w / 2, m.y + m.h / 2);

                            ctx.shadowBlur = 0; // 重置陰影
                            ctx.restore();
                            return; // ★ 成功繪製圖片後，直接結束函式
                        }
                        // --- 以下為原本的色塊繪製邏輯 (Fallback / 其他區域使用) ---
                        const colors = {
                            'green': 'rgba(46, 204, 113, 0.4)',
                            'yellow': 'rgba(241, 196, 15, 0.4)',
                            'red': 'rgba(231, 76, 60, 0.4)',
                            'black': 'rgba(44, 62, 80, 0.6)',
                            'command_post': 'rgba(255, 255, 255, 0.4)',
                            'ambulance_staging': 'rgba(52, 152, 219, 0.4)',
                            'decon': 'rgba(149, 165, 166, 0.4)'
                        };
                        ctx.fillStyle = colors[m.color] || 'rgba(255,255,255,0.2)';
                        ctx.fillRect(m.x, m.y, m.w, m.h);

                        const borderColors = {
                            'green': '#2ecc71',
                            'yellow': '#f1c40f',
                            'red': '#e74c3c',
                            'black': '#2c3e50'
                        };
                        ctx.strokeStyle = borderColors[m.color] || '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(m.x, m.y, m.w, m.h);

                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const labels = {
                            'green': '輕傷區',
                            'yellow': '中傷區',
                            'red': '重傷區',
                            'black': '臨時停屍間',
                            'command_post': '指揮站',
                            'ambulance_staging': '救護車待命區',
                            'decon': '除汙區'
                        };
                        ctx.fillText(labels[m.color], m.x + m.w / 2, m.y + m.h / 2);

                        // 如果是指揮站 (無圖片時的 fallback)，額外繪製恢復圖示
                        if (m.color === 'command_post') {
                            const blink = Math.sin(state.frameCount * 0.1) * 3;
                            ctx.fillStyle = '#2ecc71';
                            ctx.font = 'bold 20px Arial';
                            ctx.fillText('+', m.x + m.w / 2 - 10, m.y + m.h / 2 + 30 + blink);
                            ctx.fillText('HP', m.x + m.w / 2 + 5, m.y + m.h / 2 + 30 + blink);
                        }
                        ctx.restore();
                    });
                };

                // ★★★ 新增：繪製互動提示箭頭 (與設置區域風格一致) ★★
                const drawPlacementPreview = (mode) => {
                    if (!mode.active) return;

                    const p = state.player; // 取得玩家參考

                    ctx.save();


                    // --- 計算跟隨玩家頭上的座標 ---
                    // 不再使用 mode.x/mode.y (地墊座標)，而是直接鎖定玩家座標 (p.x, p.y)
                    const cx = p.x;
                    const cy = p.y - 50; // 基礎高度 (角色頭頂上方)

                    // --- 1. 箭頭 (指向角色頭頂) ---
                    const bounce = Math.sin(state.frameCount * 0.2) * 5; // 上下浮動動畫
                    const arrowY = cy + bounce;

                    ctx.fillStyle = '#f1c40f';
                    ctx.beginPath();
                    ctx.moveTo(cx - 10, arrowY - 15); // 左上
                    ctx.lineTo(cx + 10, arrowY - 15); // 右上
                    ctx.lineTo(cx, arrowY);           // 下尖端 (指向角色)
                    ctx.closePath();

                    ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
                    ctx.fill();
                    ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.stroke();
                    ctx.shadowBlur = 0;

                    // --- 2. 文字設定 ---
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = 'rgba(0,0,0,0.8)'; // 文字黑邊

                    // --- 3. 操作提示 "按 [E]..." (在箭頭上方) ---
                    const promptText = "按 [E] 設置 或 [點擊左鍵]";
                    const promptY = arrowY - 20;

                    ctx.font = 'bold 14px "Segoe UI"';
                    ctx.strokeText(promptText, cx, promptY);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(promptText, cx, promptY);

                    // --- 4. 區域名稱 (如：輕傷區) (在操作提示上方) ---
                    const labels = {
                        'green': '輕傷區', 'yellow': '中傷區', 'red': '重傷區', 'black': '臨時停屍間',
                        'command_post': '指揮站', 'ambulance_staging': '救護車待命區', 'decon': '除汙區'
                    };
                    const labelText = labels[mode.color] || '';
                    const labelY = promptY - 20;

                    // 根據區域類型設定文字顏色
                    const labelColors = {
                        'green': '#2ecc71', 'yellow': '#f1c40f', 'red': '#e74c3c', 'black': '#bdc3c7',
                        'command_post': '#ffffff', 'ambulance_staging': '#3498db', 'decon': '#95a5a6'
                    };

                    ctx.font = 'bold 18px "Segoe UI"'; // 標題字大一點
                    ctx.strokeText(labelText, cx, labelY);
                    ctx.fillStyle = labelColors[mode.color] || '#fff';
                    ctx.fillText(labelText, cx, labelY);

                    ctx.restore();
                };
                // ★★★ 新增：繪製互動提示箭頭 (與設置區域風格一致) ★★★
                const drawInteractionIndicators = () => {
                    // 如果正在放置模式、選單開啟中或遊戲結束，不顯示提示以免雜亂
                    if (state.placementMode.active || state.interactionMenu.active || state.isGameOver) return;

                    const p = state.player;
                    const interactRadius = 60; // 與 handleCanvasClick 中的判定距離一致

                    // 共用的繪製箭頭函式
                    const drawArrow = (x, y, label) => {
                        ctx.save();
                        const bounce = Math.sin(state.frameCount * 0.2) * 5; // 上下浮動
                        const arrowY = y - 40 + bounce; // 顯示在物件上方

                        // 1. 繪製箭頭
                        ctx.fillStyle = '#f1c40f';
                        ctx.beginPath();
                        ctx.moveTo(x - 10, arrowY - 15);
                        ctx.lineTo(x + 10, arrowY - 15);
                        ctx.lineTo(x, arrowY);
                        ctx.closePath();

                        ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
                        ctx.fill();
                        ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.stroke();
                        ctx.shadowBlur = 0;

                        // 2. 繪製文字
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'rgba(0,0,0,0.8)';

                        const promptText = "按 [E] 互動 或 [點擊左鍵]";
                        const promptY = arrowY - 20;

                        // 操作提示
                        ctx.font = 'bold 12px "Segoe UI"';
                        ctx.strokeText(promptText, x, promptY);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(promptText, x, promptY);

                        // 物件名稱 (選填)
                        if (label) {
                            ctx.font = 'bold 16px "Segoe UI"';
                            ctx.strokeText(label, x, promptY - 15);
                            ctx.fillStyle = '#f1c40f';
                            ctx.fillText(label, x, promptY - 15);
                        }
                        ctx.restore();
                    };

                    // 1. 檢查火焰 (Fire)
                    state.hazards.forEach(h => {
                        if (!h.beingExtinguished) {
                            const dist = Math.hypot(p.x - h.x, p.y - h.y);
                            if (dist < interactRadius + 50) { // 配合點擊判定範圍
                                drawArrow(h.x, h.y - h.r, "請求滅火");
                            }
                        }
                    });

                    // 2. 檢查車輛 (Vehicle) - 只提示有人的車
                    state.obstacles.forEach(o => {
                        if (o.type !== 'guardrail' && o.type !== 'wall' && o.type !== 'vehicle_block' && o.type !== 'metal_debris') {
                            const dist = Math.hypot(p.x - (o.x + o.w / 2), p.y - (o.y + o.h / 2));
                            if (dist < interactRadius + 40) {
                                // 檢查是否受困且未破壞
                                const survivorInside = state.survivors.find(s => s.trappedInVehicle === o);
                                if (survivorInside && !o.isBreached && o.breakTimer === 0) {
                                    drawArrow(o.x + o.w / 2, o.y, "破壞車體");
                                }
                            }
                        }
                    });

                    // 3. 檢查傷患 (Survivor)
                    state.survivors.forEach(s => {
                        // 排除受困中(由車輛處理)、已死亡轉黑卡且不在選單目標、正在移動或被搬運的
                        if (s.trappedInVehicle && !s.trappedInVehicle.isBreached) return;
                        if (s.isEvacuating || s.isBeingCarried || s.onAmbulance) return;

                        const dist = Math.hypot(p.x - s.x, p.y - s.y);
                        if (dist < interactRadius) {
                            let label = "進行檢傷";
                            if (s.triageTag) label = "查看資訊"; // 已檢傷改顯示查看
                            drawArrow(s.x, s.y - 15, label);
                        }
                    });
                };


                state.frameCount++;
                const update = () => {
                    const p = state.player;
                    state.frameCount++;
                    // === 新增：全域 MP 被動恢復 (每 10 秒 / 600 幀 回復 1 點) ===
                    if (state.frameCount % 600 === 0) {
                        state.stats.mp = Math.min(state.stats.maxMp, state.stats.mp + 1);
                    }
                    //  能量飲料生成邏輯 (每30秒 = 1800 frames) 
                    state.energySpawnTimer++;
                    if (state.energySpawnTimer > 3600) {
                        state.energySpawnTimer = 0;
                        // 最多同時存在 3 罐
                        if (state.energyDrinks.length < 3) {
                            const minX = (50 + 700) + 200; // 起始點約 950
                            const maxX = WORLD_WIDTH - 150; // 終點
                            // 消防車位於 50 + LEFT_EXPANSION (約 750)，寬 140
                            // 生成於消防車右側區域 (約 X: 950 ~ 1150)
                            const spawnX = minX + Math.random() * (maxX - minX);
                            // Y軸範圍：避開上下邊界 (與傷患生成邏輯類似)
                            const spawnY = 150 + Math.random() * (WORLD_HEIGHT - 300);

                            // 簡單避開障礙物檢查
                            let safe = true;
                            for (let o of state.obstacles) {
                                if (spawnX > o.x && spawnX < o.x + o.w && spawnY > o.y && spawnY < o.y + o.h) {
                                    safe = false; break;
                                }
                            }

                            if (safe) {
                                state.energyDrinks.push({
                                    x: spawnX, y: spawnY, w: 20, h: 30,
                                    floatOffset: Math.random() * Math.PI * 2
                                });
                                addFeedback(spawnX, spawnY - 40, "能量飲料出現!", "#00ffff");
                            }
                        }
                    }

                    // ★★★ 新增：檢查玩家是否吃到能量飲料 ★★★
                    for (let i = state.energyDrinks.length - 1; i >= 0; i--) {
                        const drink = state.energyDrinks[i];
                        // 碰撞距離判定
                        if (Math.hypot(p.x - drink.x, p.y - drink.y) < 40) {
                            state.energyDrinks.splice(i, 1); // 移除飲料
                            state.spBuffTimer = 1800; // 給予 30秒 (1800 frames) Buff
                            addFeedback(p.x, p.y - 60, "⚡ SP無限 (30s) ⚡", "#00ffff");
                        }
                    }

                    // ★★★ 新增：Buff 計時器倒數 ★★★
                    if (state.spBuffTimer > 0) {
                        state.spBuffTimer--;
                    }

                    // ★★★ 新增：搬運系統冷卻倒數 (放在 update 函式前方) ★★★
                    if (state.carrySystemCooldown > 0) {
                        state.carrySystemCooldown--;
                    }
                    // ★★★ 新增：救護車冷卻時間倒數 ★★★
                    if (state.ambulanceCooldown > 0) {
                        state.ambulanceCooldown--;
                    }
                    // ★★★ 新增：大聲公冷卻倒數 ★★★
                    if (state.megaphoneCooldown > 0) {
                        state.megaphoneCooldown--;
                    }
                    // --- 新增：計算目的地 (地墊中心隨機點 或 消防車後方) ---
                    const getTriageDest = (tag) => {
                        const mat = state.triageMats.find(m => m.color === tag);
                        if (mat) {
                            // 若有對應顏色的地墊，回傳地墊範圍內的隨機點
                            return {
                                x: mat.x + 10 + Math.random() * (mat.w - 20),
                                y: mat.y + 10 + Math.random() * (mat.h - 20)
                            };
                        }
                        // 若無設置地墊，預設前往消防車後方待命 (消防車 X 約在 50 + LEFT_EXPANSION)
                        return {
                            x: (50 + LEFT_EXPANSION) - 80 + Math.random() * 40,
                            y: WORLD_HEIGHT / 2 - 50 + Math.random() * 100
                        };
                    };

                    // --- 新增：地墊位置自動更新 (顯示在角色前方) ---
                    if (state.placementMode.active) {
                        const pm = state.placementMode;


                        let targetX = p.x;
                        let targetY = p.y;



                        // 更新地墊座標 (置中)
                        pm.x = targetX - pm.w / 2;
                        pm.y = targetY - pm.h / 2;

                        // 驗證位置是否合法 (檢查障礙物、其他地墊、傷患)
                        let valid = true;
                        // 0. 【新增】檢查是否在安全區域 (消防車左側)
                        // 消防車 X = 50 + LEFT_EXPANSION，我們以此作為邊界
                        const safeZoneLimit = 50 + LEFT_EXPANSION;
                        if (pm.x + pm.w > safeZoneLimit) {
                            valid = false;
                        }
                        // 1. 檢查障礙物
                        for (let o of state.obstacles) {
                            if (pm.x < o.x + o.w && pm.x + pm.w > o.x && pm.y < o.y + o.h && pm.y + pm.h > o.y) {
                                valid = false; break;
                            }
                        }
                        // 2. 檢查重疊地墊
                        if (valid) {
                            for (let m of state.triageMats) {
                                if (pm.x < m.x + m.w && pm.x + pm.w > m.x && pm.y < m.y + m.h && pm.y + pm.h > m.y) {
                                    valid = false; break;
                                }
                            }
                        }
                        // 3. 檢查是否壓到傷患
                        if (valid) {
                            for (let s of state.survivors) {
                                if (Math.hypot(pm.x + pm.w / 2 - s.x, pm.y + pm.h / 2 - s.y) < 20) {
                                    valid = false; break;
                                }
                            }
                        }
                        pm.valid = valid;
                    }
                    p.moving = false;
                    let nextX = p.x;
                    let nextY = p.y;

                    if (state.stats.hp <= 0) {
                        state.isGameOver = true;
                        setGameOver(true);
                        return;
                    }

                    if (state.interactionMenu.active && state.interactionMenu.target) {
                        const target = state.interactionMenu.target;

                        let targetX = target.x;
                        let targetY = target.y;
                        if (target.w) { targetX += target.w / 2; targetY += target.h / 2; }
                        const dist = Math.hypot(p.x - targetX, p.y - targetY);
                        if (dist > 80) {
                            state.interactionMenu.active = false;
                            state.interactionMenu.target = null;
                            state.interactionMenu.mode = 'main';
                        }
                    }

                    for (let i = state.firefightingSquads.length - 1; i >= 0; i--) {
                        let s = state.firefightingSquads[i];
                        if (s.state === 'moving_to_fire') {
                            const dx = s.target.x - s.x;
                            const dy = s.target.y - s.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist < 100) {
                                s.state = 'extinguishing';
                            } else {
                                s.x += (dx / dist) * 2;
                                s.y += (dy / dist) * 2;
                            }
                        } else if (s.state === 'extinguishing') {
                            s.target.life--;
                            if (s.target.life <= 0) {
                                const hzIndex = state.hazards.indexOf(s.target);
                                if (hzIndex > -1) state.hazards.splice(hzIndex, 1);
                                s.state = 'leaving';
                            }
                        } else if (s.state === 'leaving') {
                            s.x -= 2;
                            if (s.x < -50) state.firefightingSquads.splice(i, 1);
                        }
                    }
                    // 新增: 破壞小組更新邏輯
                    for (let i = state.rescueSquads.length - 1; i >= 0; i--) {
                        let s = state.rescueSquads[i];
                        if (s.state === 'moving_to_vehicle') {
                            // 移動到車輛左側一點的位置
                            let tx = s.target.x - 40;
                            let ty = s.target.y + s.target.h / 2;
                            const dx = tx - s.x;
                            const dy = ty - s.y;
                            const dist = Math.hypot(dx, dy);

                            if (dist < 10) {
                                s.state = 'breaking';
                                // 設定 600 frames = 約 10 秒
                                s.target.breakTimer = 600;
                                addFeedback(s.target.x + s.target.w / 2, s.target.y - 20, "破壞作業開始...", "#f39c12");
                            } else {
                                // 移動速度
                                s.x += (dx / dist) * 2.5;
                                s.y += (dy / dist) * 2.5;
                            }
                        } else if (s.state === 'breaking') {
                            // 破壞中：breakTimer 會在下方的 obstacles 迴圈中自動倒數
                            // 這裡只需要檢查是否完成
                            if (s.target.isBreached) {
                                s.state = 'leaving';
                                addFeedback(s.target.x + s.target.w / 2, s.target.y - 20, "作業完成，撤收!", "#2ecc71");
                            }
                        } else if (s.state === 'leaving') {
                            // 返回出發點
                            let tx = 50 + 700;
                            let ty = 540 / 2 - 150;
                            const dx = tx - s.x;
                            const dy = ty - s.y;
                            const dist = Math.hypot(dx, dy);

                            if (dist < 10) {
                                state.rescueSquads.splice(i, 1); // 移除小組
                            } else {
                                s.x += (dx / dist) * 2;
                                s.y += (dy / dist) * 2;
                            }
                        }
                    }
                    state.obstacles.forEach(o => {
                        if (o.breakTimer > 0) {
                            o.breakTimer--;
                            if (o.breakTimer <= 0) {
                                o.isBreached = true;
                                addFeedback(o.x + o.w / 2, o.y, "破壞完成", "#2ecc71");
                                // --- 修改開始：將傷患移出車外 ---
                                // 搜尋受困於此車輛的傷患
                                const survivor = state.survivors.find(s => s.trappedInVehicle === o);
                                if (survivor) {
                                    // 將傷患位置設定到車輛下方 (Y軸增加)，確保完全露出
                                    // 偏移量設為車高 + 50px，確保有足夠點擊空間
                                    survivor.x = o.x + o.w / 2; // 水平置中
                                    survivor.y = o.y + o.h + 50;

                                    // 簡單邊界檢查，如果太下面就改移到上面
                                    if (survivor.y > WORLD_HEIGHT - 30) {
                                        survivor.y = o.y - 50;
                                    }

                                    addFeedback(survivor.x, survivor.y, "傷患已移出", "#3498db");
                                }
                            }
                        }
                    });

                    // 新程式碼：檢查場上是否有「無人處理」的重傷患
                    const unassignedTargets = state.survivors.filter(s =>
                        s.triageTag &&
                        (s.triageTag === 'red' || s.triageTag === 'yellow' || s.triageTag === 'black') && // 針對紅/黃/黑卡
                        !s.isEvacuating &&      // 非自行移動中
                        !s.hasArrived &&        // 尚未抵達安置區
                        !s.isBeingCarried &&    // 尚未被搬起
                        !state.npcGroups.some(g => g.target === s) && // 目前沒有任何小組鎖定他
                        (!s.trappedInVehicle || s.trappedInVehicle.isBreached) && // 沒有受困
                        !state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30) // 周圍無火
                    );

                    // 限制場上同時存在的搬運組上限 (例如 5 組)，避免太亂
                    if (unassignedTargets.length > 0 && state.npcGroups.length < 1) {
                        // 簡單的冷卻時間，避免同一幀生成所有人 (利用 frameCount)
                        if (state.frameCount % 60 === 0) {
                            // 優先處理紅卡 (雖然 filter 已經篩選過，這裡取第一個即可)
                            // 根據嚴重程度排序：黑 > 紅 > 黃 (或依需求調整)
                            unassignedTargets.sort((a, b) => {
                                const p = { 'black': 3, 'red': 2, 'yellow': 1 };
                                return p[b.triageTag] - p[a.triageTag];
                            });

                            const target = unassignedTargets[0];

                            state.npcGroups.push({
                                leaderX: 20 + LEFT_EXPANSION, leaderY: 600, // 從畫面邊緣出現
                                followerX: 0 + LEFT_EXPANSION, followerY: 600,
                                target: target,           // 直接鎖定目標
                                state: 'moving_to_target', // 直接前往，不經過 searching
                                carrying: false
                            });
                        }
                    }

                    for (let i = state.npcGroups.length - 1; i >= 0; i--) {
                        let group = state.npcGroups[i];
                        const speed = 1.0;
                        if (group.state === 'searching') {
                            // 預防萬一：如果處於 searching 狀態但沒目標，直接撤離
                            group.state = 'leaving';

                        }

                        else if (group.state === 'moving_to_target') {
                            // (這段保持不變)
                            const dx = group.target.x - group.leaderX;
                            const dy = group.target.y - group.leaderY;
                            const dist = Math.hypot(dx, dy);
                            if (dist < 10) {
                                group.state = 'carrying';
                                group.carrying = true;
                                group.target.isBeingCarried = true;
                                addFeedback(group.leaderX, group.leaderY, "開始搬運", "#fff");
                            } else {
                                group.leaderX += (dx / dist) * speed;
                                group.leaderY += (dy / dist) * speed;
                            }
                        } else if (group.state === 'carrying') {
                            // --- 修改：搬運邏輯 (包含除汙區判斷) ---
                            let targetTag = group.target.triageTag;
                            let isGoingToDecon = false;

                            // 判斷是否需要先去除汙
                            if (group.target.data.isContaminated) {
                                const deconMat = state.triageMats.find(m => m.color === 'decon');
                                const targetMat = state.triageMats.find(m => m.color === targetTag);

                                // 若滿足所有條件，強制先前往除汙區
                                if (deconMat && targetMat && deconMat.x > targetMat.x) {
                                    targetTag = 'decon';
                                    isGoingToDecon = true;
                                }
                            }

                            // 取得目的地座標 (可能是原本的檢傷區，或是暫時的除汙區)
                            const dest = getTriageDest(targetTag);
                            const dx = dest.x - group.leaderX;
                            const dy = dest.y - group.leaderY;
                            const dist = Math.hypot(dx, dy);

                            if (dist < 10) {
                                if (isGoingToDecon) {
                                    if (group.target.data.isContaminated) {
                                        statsTracker.current.deconCount++;
                                    }
                                    // --- Case A: 抵達除汙區 ---
                                    group.target.data.isContaminated = false; // 清除汙染狀態
                                    addFeedback(group.leaderX, group.leaderY, "已除汙", "#95a5a6");

                                    // 重要：這裡不執行放下傷患 (drop) 的動作
                                    // 因為 isContaminated 已被設為 false，下一幀更新時，
                                    // 上方的 if 判斷會不成立，目的地會自動切換回原本的檢傷區 (targetTag)，
                                    // NPC 就會帶著傷患繼續往正確區域前進。
                                } else {
                                    // --- Case B: 抵達最終安置區域 ---
                                    group.target.x = dest.x;
                                    group.target.y = dest.y;
                                    group.target.isBeingCarried = false;
                                    // ★★★ 修改：只有當對應顏色的地墊存在時，才標記為「已安置」 ★★★
                                    const destMat = state.triageMats.find(m => m.color === group.target.triageTag);
                                    if (destMat) {
                                        group.target.hasArrived = true; // 標記為已安置
                                        // 檢查檢傷分類是否與實際傷情相符
                                        if (group.target.triageTag === group.target.data.severity) {
                                            if (!group.target.hasBeenMovedScored) {
                                                setScore(prev => prev + 100);
                                                addFeedback(group.leaderX, group.leaderY - 50, "移動正確 +100", "#f1c40f");
                                                group.target.hasBeenMovedScored = true; // 標記已加過移動分
                                            }
                                        }
                                    } else {
                                        // ★★★ 重點：若無地墊，雖然只是暫置，但必須標記為 hasArrived = true ★★★
                                        // ★★★ 這樣才能防止系統判定該傷患需要「再次搬運」，導致原地無限迴圈 ★★★
                                        group.target.hasArrived = true;
                                        addFeedback(group.leaderX, group.leaderY - 20, "無對應區域，暫置於此", "#bdc3c7");
                                    }



                                    // NPC 重置狀態，準備去搜尋下一個傷患
                                    group.target = null;
                                    group.carrying = false;
                                    group.state = 'searching';
                                    checkTriageCounts(); // 搬運完成後檢查計數 
                                    state.carrySystemCooldown = 1200;
                                }
                            } else {
                                // 移動邏輯 (保持不變)
                                const speed = 0.6;
                                group.leaderX += (dx / dist) * speed;
                                group.leaderY += (dy / dist) * speed;
                                if (group.target) {
                                    // 傷患位置跟隨 NPC 隊伍中心
                                    group.target.x = (group.leaderX + group.followerX) / 2;
                                    group.target.y = (group.leaderY + group.followerY) / 2;
                                }
                            }

                        }
                        // ... leaving 狀態保持不變 ...
                        else if (group.state === 'leaving') {
                            group.leaderX -= speed;
                            if (group.leaderX < -50 + LEFT_EXPANSION) state.npcGroups.splice(i, 1);
                        }

                        // ... 跟隨者邏輯保持不變 ...
                        if (group.state !== 'searching' || group.leaderX > 0) {
                            const fdx = group.leaderX - group.followerX;
                            const fdy = group.leaderY - group.followerY;
                            const fdist = Math.hypot(fdx, fdy);
                            if (fdist > 25) {
                                group.followerX += (fdx / fdist) * speed;
                                group.followerY += (fdy / fdist) * speed;
                            }
                        } else {
                            group.followerX = group.leaderX - 20;
                            group.followerY = group.leaderY;
                        }
                    }

                    // --- 修改：傷患自行移動邏輯 (取代原本的 splice 移除) ---
                    for (let i = state.survivors.length - 1; i >= 0; i--) {
                        let s = state.survivors[i];
                        if (s.isEvacuating && !s.hasArrived) { // 只有尚未抵達的才需要移動
                            const dest = getTriageDest('green'); // 綠色標籤去綠色區或待命區

                            const dx = dest.x - s.x;
                            const dy = dest.y - s.y;
                            const dist = Math.hypot(dx, dy);

                            if (dist < 10) {
                                s.isEvacuating = false;

                                // ★★★ 修改：只有當綠色地墊存在時，才標記為「已安置」 ★★★
                                const greenMat = state.triageMats.find(m => m.color === 'green');
                                if (greenMat) {
                                    s.hasArrived = true; // 標記已抵達
                                    addFeedback(s.x, s.y, "抵達輕傷區", "#2ecc71");
                                    // 綠色傷患自行移動到綠色區，且實際傷情確實為綠色
                                    if (s.triageTag === 'green' && s.data.severity === 'green') {
                                        if (!s.hasBeenMovedScored) {
                                            setScore(prev => prev + 100);
                                            addFeedback(s.x, s.y - 50, "移動正確 +100", "#f1c40f");
                                            s.hasBeenMovedScored = true; // 標記已加過移動分
                                        }
                                    }
                                } else {
                                    s.hasArrived = false;
                                    addFeedback(s.x, s.y, "抵達集結點", "#bdc3c7");
                                }
                                checkTriageCounts(); // 自行移動抵達後檢查計數
                            } else {
                                s.x += (dx / dist) * 0.4; // 輕傷移動速度
                                s.y += (dy / dist) * 0.4;
                            }
                        }
                    }
                    // --- 修正：救護車進場與離開邏輯 (整合在 update 迴圈內) ---
                    for (let i = state.emergencyVehicles.length - 1; i >= 0; i--) {
                        let v = state.emergencyVehicles[i];

                        // 1. 進場邏輯 (arriving) - 設定約 10 秒 (600 frames) 抵達
                        if (['ambulance', 'mini_bus'].includes(v.type) && v.state === 'arriving') {
                            const dx = v.targetX - v.x;
                            const dy = v.targetY - v.y;
                            const dist = Math.hypot(dx, dy);

                            // 若尚未設定速度，根據距離計算速度 (Distance / 600 frames)
                            // 600 frames / 60fps = 10秒
                            if (!v.speed) {
                                // 限制最小速度 0.5 避免距離過近時停滯
                                v.speed = Math.max(0.5, dist / 600);
                            }

                            if (dist <= v.speed) {
                                v.x = v.targetX;
                                v.y = v.targetY;
                                v.state = 'waiting'; // 抵達後轉為待命
                                v.angle = 0; // 轉正
                            } else {
                                v.x += (dx / dist) * v.speed;
                                v.y += (dy / dist) * v.speed;
                            }
                        }
                        // 2. 離場邏輯 (departing)
                        else if (['ambulance', 'mini_bus'].includes(v.type) && v.state === 'departing') {
                            const oldX = v.x;
                            v.x -= 5; // 向左快速移動 (離場速度較快)

                            // 同步移動對應的阻擋塊，避免留下隱形牆
                            const block = state.obstacles.find(o =>
                                o.type === 'vehicle_block' &&
                                Math.abs(o.x - oldX) < 10 &&
                                Math.abs(o.y - v.y) < 10
                            );
                            if (block) {
                                block.x = v.x; // 跟著車子移動
                            }

                            if (v.x < -200) {
                                // 離開畫面後移除
                                state.emergencyVehicles.splice(i, 1);
                                // 同時移除對應的阻擋塊 (如果有)
                                const blockIndex = state.obstacles.findIndex(o => o.type === 'vehicle_block' && Math.abs(o.x - v.x) < 20 && Math.abs(o.y - v.y) < 20);
                                if (blockIndex > -1) state.obstacles.splice(blockIndex, 1);
                            }
                        }
                    }
                    state.survivors.forEach(s => {
                        if (s.tourniquetTimer !== null && s.tourniquetTimer > 0) {
                            s.tourniquetTimer -= 1 / 240;
                            if (s.tourniquetTimer <= 0) {
                                s.tourniquetTimer = 0;
                                s.isDead = true;
                                //s.triageTag = 'black';
                                s.data.consciousness = '無意識';
                                s.data.resp = '無';
                                s.data.pulse = '無';
                                s.data.injuryText = '失血過多死亡';
                                s.data.severity = 'black';
                                addFeedback(s.x, s.y, "傷患死亡", "#000");
                                checkTriageCounts(); // 傷患死亡轉黑卡後檢查計數
                            }
                        }
                    });

                    const isTryingToMove = state.keys.w || state.keys.s || state.keys.a || state.keys.d;
                    let speed = p.speed;

                    // 定義「正在移動」的狀態 (包含 鍵盤、滑鼠導航、虛擬搖桿) ★★★
                    // 這樣無論是用滑鼠點擊移動還是搖桿，都會正確扣除 SP
                    const isPlayerMoving = isTryingToMove || p.movingToTarget || joystickRef.current.active;


                    if (isPlayerMoving) {
                        // ★★★ 修改：若有 SP Buff (spBuffTimer > 0) 則不扣 SP ★★★
                        if (state.spBuffTimer <= 0) {
                            state.stats.sp = Math.max(0, state.stats.sp - 0.2);
                        } else {
                            // Buff 期間 SP 維持全滿或緩慢恢復
                            state.stats.sp = Math.min(state.stats.maxSp, state.stats.sp + 1);
                        }
                        if (state.stats.sp <= 0) speed = speed * 0.5;
                    } else {
                        state.stats.sp = Math.min(state.stats.maxSp, state.stats.sp + 0.1);
                    }
                    // ====== 新增：指揮站 HP 恢復邏輯 ======
                    let isInCommandPost = false;
                    const commandPost = state.triageMats.find(m => m.color === 'command_post');
                    if (commandPost) {
                        // 檢查玩家是否在指揮站區域內
                        if (p.x > commandPost.x && p.x < commandPost.x + commandPost.w &&
                            p.y > commandPost.y && p.y < commandPost.y + commandPost.h) {
                            isInCommandPost = true;
                        }
                    }
                    if (isInCommandPost) {
                        // 每 30 幀 (約 0.5 秒) 恢復一次 HP，每次恢復 1 點
                        if (state.frameCount % 30 === 0) {
                            const newHp = Math.min(state.stats.maxHp, state.stats.hp + 1);
                            if (newHp > state.stats.hp) {
                                state.stats.hp = newHp;
                                addFeedback(p.x, p.y - 60, "+1 HP (指揮站)", "#2ecc71");

                            }

                        }
                        // 2. ★★★ 新增 MP 恢復：每 60 幀 (約 1 秒) 恢復 1 點 ★★★
                        if (state.frameCount % 60 === 0) {
                            const newMp = Math.min(state.stats.maxMp, state.stats.mp + 1);
                            if (newMp > state.stats.mp) {
                                state.stats.mp = newMp;
                                // 提示位置稍微往上 (y - 80)，避免與 HP 提示重疊，使用藍色 (#3498db)
                                addFeedback(p.x, p.y - 80, "+1 MP (指揮站)", "#3498db");
                            }
                        }
                        // 並且加速恢復 SP (耐力)
                        state.stats.sp = Math.min(state.stats.maxSp, state.stats.sp + 0.5);
                    }
                    // ========================================

                    if (state.keys.w) { nextY -= speed; p.dir = 1; p.moving = true; }
                    if (state.keys.s) { nextY += speed; p.dir = 0; p.moving = true; }
                    if (state.keys.a) { nextX -= speed; p.dir = 2; p.moving = true; }
                    if (state.keys.d) { nextX += speed; p.dir = 3; p.moving = true; }
                    // 只有在沒有按鍵盤的時候，才執行滑鼠導航
                    if (p.movingToTarget && !isTryingToMove) {
                        const dx = p.targetX - p.x;
                        const dy = p.targetY - p.y;
                        const dist = Math.hypot(dx, dy);

                        // 如果距離小於移動速度，直接抵達
                        if (dist <= speed) {
                            nextX = p.targetX;
                            nextY = p.targetY;
                            p.movingToTarget = false; // 停止移動
                            // p.moving = false; // 這裡不設為 false，讓下方碰撞偵測後的賦值去處理
                        } else {
                            // 計算移動向量
                            nextX += (dx / dist) * speed;
                            nextY += (dy / dist) * speed;
                            p.moving = true;

                            // 根據移動方向更新角色面向 (dir)
                            if (Math.abs(dx) > Math.abs(dy)) {
                                p.dir = dx > 0 ? 3 : 2; // 右 : 左
                            } else {
                                p.dir = dy > 0 ? 0 : 1; // 下 : 上
                            }
                        }
                    }
                    state.camera.x = p.x - GAME_WIDTH / 2;
                    state.camera.y = p.y - GAME_HEIGHT / 2;
                    state.camera.x = Math.max(0, Math.min(state.camera.x, WORLD_WIDTH - GAME_WIDTH)); // 更新邊界
                    state.camera.y = Math.max(0, Math.min(state.camera.y, 1200 - GAME_HEIGHT));
                    // ★★★ Joystick 移動邏輯整合 ★★★
                    if (joystickRef.current.active) {
                        const { vecX, vecY } = joystickRef.current;
                        if (Math.abs(vecX) > 0.1 || Math.abs(vecY) > 0.1) {
                            // 根據推動幅度決定速度 (0.5 ~ 1.0 倍速)
                            const pushStrength = Math.min(1, Math.hypot(vecX, vecY));
                            const currentSpeed = speed * (0.5 + 0.5 * pushStrength);

                            nextX += vecX * currentSpeed;
                            nextY += vecY * currentSpeed;
                            p.moving = true;

                            // 更新面向
                            if (Math.abs(vecX) > Math.abs(vecY)) {
                                p.dir = vecX > 0 ? 3 : 2;
                            } else {
                                p.dir = vecY > 0 ? 0 : 1;
                            }
                            // 搖桿操作時取消滑鼠點擊移動
                            p.movingToTarget = false;
                        }
                    }
                    state.decorations.forEach(d => {
                        if (d.type === 'oil') {
                            const dist = Math.hypot(p.x - d.x, p.y - d.y);
                            if (dist < d.r) {
                                state.stats.hp = Math.max(0, state.stats.hp - 0.05);
                                if (state.frameCount % 60 === 0) {
                                    addFeedback(p.x, p.y - 30, "受傷! (油漬)", "#e74c3c");
                                }
                            }
                        }
                    });

                    let pBox = { x: nextX - 5, y: nextY - 5, w: 10, h: 10 };
                    let collide = false;

                    // --- 火焰碰撞邏輯 ---
                    for (let h of state.hazards) {
                        const dist = Math.hypot(nextX - h.x, nextY - h.y);
                        // 如果距離小於火焰半徑 (稍微寬一點，讓視覺上碰到顏色就擋住)
                        if (dist < h.r + 10) {
                            collide = true; // 視為碰撞，無法前進
                            // 扣血
                            state.stats.hp = Math.max(0, state.stats.hp - 0.5);
                            if (state.frameCount % 30 === 0) {
                                addFeedback(p.x, p.y - 40, "高溫! 無法靠近!", "#e74c3c");
                            }
                            break;
                        }
                    }

                    for (let o of state.obstacles) {
                        if (o.type === 'metal_debris') {
                            if (pBox.x < o.x + o.w && pBox.x + 10 > o.x && pBox.y < o.y + o.h && pBox.y + 10 > o.y) {
                                state.stats.hp = Math.max(0, state.stats.hp - 0.1);
                                if (state.frameCount % 45 === 0) addFeedback(p.x, p.y - 30, "割傷! (金屬)", "#e74c3c");
                            }
                        }

                        let obBox = o.type === 'guardrail' ? { x: o.x, y: o.y, w: o.w, h: o.h } : o.hitbox;
                        if (!obBox) obBox = { x: o.x, y: o.y, w: o.w, h: o.h };
                        if (pBox.x < obBox.x + obBox.w && pBox.x + pBox.w > obBox.x && pBox.y < obBox.y + obBox.h && pBox.y + pBox.h > obBox.y) {
                            collide = true; break;
                        }
                    }
                    if (!collide) {
                        p.x = nextX; p.y = nextY;
                    } else {
                        // ★★★ 新增：若發生碰撞，停止滑鼠自動移動，避免卡住 ★★★
                        if (p.movingToTarget) {
                            p.movingToTarget = false;
                            p.moving = false;
                        }
                    }
                    if (p.moving) { p.animTimer++; p.frame = Math.floor(p.animTimer / 5); }
                    state.hazards.forEach(h => {
                        // 只有未被滅火的火焰會持續產生煙霧
                        if (h.type === 'fire' && !h.beingExtinguished) {
                            // 控制煙霧產生頻率 (0.7 = 30% 機率每幀產生)
                            if (Math.random() > 0.95) {
                                state.particles.push({
                                    x: h.x + (Math.random() - 0.5) * h.r,   // 在火焰範圍內隨機位置
                                    y: h.y - h.r * 0.5,                     // 從火焰上半部冒出
                                    vx: 0.5 + (Math.random() - 0.5) * 0.5,  // 微微向右飄 (模擬風向)
                                    vy: -1.5 - Math.random(),               // 向上升起
                                    life: 100 + Math.random() * 60,         // 煙霧壽命較長
                                    size: 5 + Math.random() * 8,            // 初始大小
                                    // 隨機深灰色帶透明度
                                    color: `rgba(${60 + Math.random() * 40}, ${60 + Math.random() * 40}, ${60 + Math.random() * 40}, ${0.3 + Math.random() * 0.2})`,
                                    type: 'smoke' // 標記為煙霧
                                });
                            }
                        }
                    });

                    state.survivors.forEach(s => {
                        if (s.data.isBleeding && Math.random() > 0.8) {
                            state.particles.push({
                                x: s.x + (Math.random() - 0.5) * 8,
                                y: s.y + (Math.random() - 0.5) * 8,
                                vx: (Math.random() - 0.5) * 0.1,
                                vy: (Math.random() - 0.5) * 0.1,
                                life: 15 + Math.random() * 10,
                                size: 1.5,
                                color: 'rgba(231, 76, 60, 0.9)',
                                type: 'blood',
                            });
                        }
                    });

                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        let pt = state.particles[i];
                        pt.x += pt.vx; pt.y += pt.vy;
                        pt.life--;
                        if (pt.type === 'smoke') {
                            pt.size += 0.15; // 煙霧隨時間擴散變大
                            pt.vx += 0.005;  // 隨風加速 (可選)
                        } else {
                            if (!pt.color.includes('150')) pt.size = Math.max(0, pt.size - 0.05);
                            else pt.size += 0.1;
                        }
                        if (pt.life <= 0) {
                            if (pt.color.includes('150')) {
                                let car = state.obstacles[Math.floor(Math.random() * state.obstacles.length)];
                                if (car && car.type !== 'guardrail' && car.type !== 'wall') {
                                    pt.x = car.x + car.w / 2; pt.y = car.y + car.h / 2; pt.life = rand(50, 150); pt.size = rand(2, 5);
                                }
                            } else {
                                state.particles.splice(i, 1);
                            }
                        }
                    }

                    for (let i = state.feedbacks.length - 1; i >= 0; i--) {
                        let f = state.feedbacks[i];
                        f.y += f.vy; f.life--;
                        if (f.life <= 0) state.feedbacks.splice(i, 1);
                    }

                    if (state.frameCount % 10 === 0) {
                        setPlayerStatsUI({ ...state.stats });
                        // checkTriageCounts() // 已經在狀態改變時呼叫，這裡可以省略以減少不必要的渲染
                    }
                };

                const draw = () => {
                    ctx.save();
                    ctx.translate(-state.camera.x, -state.camera.y);

                    // 背景更新寬度
                    drawRect(0, 0, WORLD_WIDTH, 1200, PALETTE.asphalt);

                    if (state.placementMode.active) {
                        const zoneWidth = 50 + LEFT_EXPANSION; // 消防車位置

                        ctx.save();
                        // 1. 半透明綠色背景
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.1)';
                        ctx.fillRect(0, 0, zoneWidth, 1200);

                        // 2. 邊界虛線
                        ctx.strokeStyle = '#2ecc71';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([15, 10]); // 虛線樣式
                        ctx.beginPath();
                        ctx.moveTo(zoneWidth, 0);
                        ctx.lineTo(zoneWidth, 1200);
                        ctx.stroke();

                        // 3. 文字提示
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.6)';
                        ctx.font = 'bold 30px "Segoe UI"';
                        ctx.textAlign = 'center';
                        ctx.fillText("安全作業區域 (由此處開始部署)", zoneWidth / 2, 200);

                        ctx.restore();
                    }
                    // ↑↑↑↑↑↑ 綠色半透明區域程式碼位置 (由此結束) ↑↑↑↑↑↑

                    ctx.fillStyle = PALETTE.markingWhite;
                    const laneCount = 8;
                    const laneH = (1200 - 80) / laneCount;
                    for (let l = 1; l < laneCount; l++) {
                        let ly = 40 + l * laneH;
                        for (let lx = 0; lx < WORLD_WIDTH; lx += 80) ctx.fillRect(lx, ly - 2, 40, 4);
                    }
                    ctx.fillStyle = PALETTE.markingYellow;
                    ctx.fillRect(0, 40, WORLD_WIDTH, 4);
                    ctx.fillRect(0, 1200 - 44, WORLD_WIDTH, 4);

                    drawTriageMats(state.triageMats);

                    state.decorations.forEach(d => {
                        if (d.type === 'skid') {
                            ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.angle); drawRect(0, 0, d.w, d.h, 'rgba(0,0,0,0.6)'); ctx.restore();
                        } else if (d.type === 'oil') {
                            // ★★★ 修改：若有圖片則繪製圖片，否則繪製原本的黑色橢圓 ★★★
                            const img = assets.oil;
                            if (img && img.complete && img.naturalWidth !== 0) {
                                ctx.save();
                                ctx.translate(d.x, d.y);
                                // 設定圖片尺寸 (根據原本的半徑 r 調整比例，保持橢圓感)
                                const w = d.r * 2.5;
                                const h = d.r * 1.5;
                                ctx.drawImage(img, -w / 2, -h / 2, w, h);
                                ctx.restore();
                            } else {
                                // (備案) 原本的向量繪製邏輯
                                ctx.fillStyle = PALETTE.oil; ctx.beginPath(); ctx.ellipse(d.x, d.y, d.r, d.r * 0.6, 0, 0, Math.PI * 2); ctx.fill();
                            }
                        } else if (d.type === 'glass') {
                            // ★★★ 修改：若有圖片則繪製圖片，否則繪製原本的藍色方塊 ★★★
                            const img = assets.glass;
                            if (img && img.complete && img.naturalWidth !== 0) {
                                ctx.save();
                                ctx.translate(d.x, d.y);
                                // 設定圖片尺寸 (d.size 原本數值很小約 1~3，這邊放大倍率顯示)
                                const size = d.size * 8 + 5;
                                // 可選擇是否隨機旋轉讓碎片看起來更自然
                                // ctx.rotate(Math.random() * Math.PI); 
                                ctx.drawImage(img, -size / 2, -size / 2, size, size);
                                ctx.restore();
                            } else {
                                drawRect(d.x, d.y, d.size, d.size, PALETTE.glass);
                            }
                        }
                    });

                    state.hazards.forEach(h => drawFire(h));

                    state.emergencyVehicles.forEach(v => drawEmergencyVehicle(v));
                    drawFirefighters(state.firefightingSquads);
                    drawRescueSquads(state.rescueSquads); // 新增這行
                    const renderList = [];
                    state.obstacles.forEach(o => {
                        if (o.type !== 'vehicle_block') renderList.push({ type: 'obstacle', obj: o, y: o.y + o.h })
                    });

                    state.survivors.forEach(s => {
                        let isLifted = false;
                        if (s.isBeingCarried) {
                            const carrierGroup = state.npcGroups.find(g => g.target === s && g.state === 'carrying');
                            if (carrierGroup) isLifted = true;
                        }

                        // ★★★ 如果已經上救護車 (onAmbulance)，就不再繪製 ★★★
                        if ((!isLifted || s.isEvacuating) && !s.onAmbulance) {
                            renderList.push({ type: 'survivor', obj: s, y: s.y })
                        }
                    });
                    // ★★★ 將能量飲料加入繪製列表 (Render List) ★★★
                    state.energyDrinks.forEach(d => {
                        renderList.push({ type: 'energy_drink', obj: d, y: d.y });
                    });

                    renderList.push({ type: 'player', y: state.player.y });
                    renderList.sort((a, b) => a.y - b.y);

                    renderList.forEach(item => {
                        if (item.type === 'obstacle') {
                            let o = item.obj;
                            if (o.type === 'metal_debris') {
                                // ★★★ 修改：若有圖片則繪製圖片，否則繪製原本的向量圖 ★★★
                                const img = assets.metal;
                                if (img && img.complete && img.naturalWidth !== 0) {
                                    ctx.save();
                                    ctx.translate(o.x + o.w / 2, o.y + o.h / 2);
                                    ctx.rotate(o.angle);
                                    // 設定圖片尺寸 (根據物件 w, h 調整)
                                    const scale = 2.0;
                                    ctx.drawImage(img, -o.w * scale / 2, -o.h * scale / 2, o.w * scale, o.h * scale);
                                    ctx.restore();
                                } else {
                                    // (備案) 原本的向量繪製邏輯
                                    ctx.save(); ctx.translate(o.x + o.w / 2, o.y + o.h / 2); ctx.rotate(o.angle);
                                    ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.moveTo(-o.w / 2, -o.h / 2); ctx.lineTo(o.w / 2, -o.h / 4); ctx.lineTo(0, o.h / 2); ctx.fill();
                                    ctx.restore();
                                }
                            } else if (o.type === 'guardrail') {
                                drawRect(o.x, o.y, o.w, o.h, '#7f8c8d'); drawRect(o.x, o.y + 5, o.w, 10, '#95a5a6');
                                for (let gx = 0; gx < WORLD_WIDTH; gx += 100) drawRect(gx, o.y, 10, o.h, '#555');
                            } else if (o.type !== 'wall') {
                                // ★★★ 修改：一般車輛 (轎車/卡車) 繪製邏輯 ★★★
                                const carImg = assets[o.type]; // 取得對應圖片 (sedan 或 truck)
                                let drawnImage = false;

                                // 檢查圖片是否可用
                                if (carImg && carImg.complete && carImg.naturalWidth !== 0) {
                                    ctx.save();
                                    ctx.translate(o.x + o.w / 2, o.y + o.h / 2); // 移動到中心

                                    // 判斷車輛方向並旋轉
                                    // 假設原始圖片為直向 (Vertical, 車頭朝上/下)
                                    // 若 o.w > o.h 表示車輛在遊戲中是橫向的，需旋轉 90 度
                                    if (o.w > o.h) {
                                        ctx.rotate(Math.PI / 2);
                                        // 旋轉後，繪製的寬度應為 o.h，高度為 o.w
                                        ctx.drawImage(carImg, -o.h / 2, -o.w / 2, o.h, o.w);
                                    } else {
                                        // 直向，直接繪製
                                        ctx.drawImage(carImg, -o.w / 2, -o.h / 2, o.w, o.h);
                                    }

                                    // 如果車輛被破壞，疊加一層半透明黑色與文字
                                    if (o.isBreached) {
                                        ctx.rotate(o.w > o.h ? -Math.PI / 2 : 0); // 轉回來畫文字
                                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                                        ctx.fillRect(-o.w / 2, -o.h / 2, o.w, o.h);
                                        ctx.fillStyle = '#fff';
                                        ctx.font = 'bold 12px Arial';
                                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                                        ctx.fillText("已破壞", 0, 0);
                                    } else if (o.breakTimer > 0) {
                                        ctx.rotate(o.w > o.h ? -Math.PI / 2 : 0);
                                        ctx.fillStyle = '#e67e22';
                                        ctx.font = 'bold 14px Arial';
                                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                                        ctx.fillText(`${Math.ceil(o.breakTimer / 60)}s`, 0, 0);
                                    }

                                    ctx.restore();
                                    drawnImage = true;
                                }

                                // (Fallback) 若無圖片，使用原本的向量繪製
                                if (!drawnImage) {
                                    drawRect(o.x + 5, o.y + 5, o.w, o.h, 'rgba(0,0,0,0.5)'); drawRect(o.x, o.y, o.w, o.h, o.color);
                                    ctx.fillStyle = '#2c3e50';
                                    if (o.isBreached) {
                                        ctx.fillStyle = '#555';
                                    }
                                    let cabinW = o.rotated ? o.w * 0.6 : o.w - 4; let cabinH = o.rotated ? o.h - 4 : o.h * 0.5;
                                    let cabinX = o.rotated ? o.x + (o.w - cabinW) / 2 : o.x + 2; let cabinY = o.rotated ? o.y + 2 : o.y + (o.h - cabinH) / 2;
                                    drawRect(cabinX, cabinY, cabinW, cabinH, o.color);
                                    ctx.fillStyle = '#2c3e50';
                                    if (o.rotated) { drawRect(cabinX, cabinY, 4, cabinH); drawRect(cabinX + cabinW - 4, cabinY, 4, cabinH); }
                                    else { drawRect(cabinX, cabinY, cabinW, 4); drawRect(cabinX, cabinY + cabinH - 4, cabinW, 4); }

                                    if (o.isBreached) {
                                        ctx.fillStyle = '#000';
                                        ctx.fillText("破壞", o.x + o.w / 2 - 10, o.y + o.h / 2);
                                    } else if (o.breakTimer > 0) {
                                        ctx.fillStyle = '#e67e22';
                                        ctx.fillText(`${Math.ceil(o.breakTimer / 60)}s`, o.x + o.w / 2 - 5, o.y + o.h / 2);
                                    }
                                }
                            }
                        } else if (item.type === 'survivor') {
                            drawSurvivorHighRes(item.obj);
                            let s = item.obj;
                            ctx.fillStyle = '#fff'; ctx.font = '10px Arial';
                            if (s.tourniquetTimer !== null && s.tourniquetTimer > 0) {
                                ctx.fillStyle = '#e74c3c'; ctx.font = 'bold 12px Arial'; ctx.fillText(Math.ceil(s.tourniquetTimer) + "s", s.x - 10, s.y - 25);
                            } else if (s.isDead) {
                                ctx.fillStyle = '#666'; ctx.font = 'bold 10px Arial'; ctx.fillText("DEAD", s.x - 12, s.y - 15);
                            } else if (s.triageTag) {
                                let tagText = "UNK";
                                if (s.triageTag === 'green') tagText = "III";
                                if (s.triageTag === 'yellow') tagText = "II";
                                if (s.triageTag === 'red') tagText = "I";
                                if (s.triageTag === 'black') tagText = "0";
                                ctx.fillText(tagText, s.x - 4, s.y - 10);
                            } else {
                                if (Math.floor(Date.now() / 600) % 2 === 0) { ctx.fillText('HELP', s.x - 10, s.y - 15); }
                            }
                        }
                        // ★★★ 能量飲料繪製邏輯 ★★★
                        else if (item.type === 'energy_drink') {
                            const d = item.obj;
                            const img = assets.energy_drink; // 取得圖片資源

                            ctx.save();
                            // 浮動動畫
                            const floatY = Math.sin(state.frameCount * 0.1 + d.floatOffset) * 5;
                            ctx.translate(d.x, d.y + floatY);

                            // 陰影
                            ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            ctx.beginPath(); ctx.ellipse(0, 15 - floatY, 10, 4, 0, 0, Math.PI * 2); ctx.fill();

                            // ★★★ 檢查圖片是否載入成功 ★★★
                            if (img && img.complete && img.naturalWidth !== 0) {
                                // 設定圖片顯示尺寸 (可依圖片比例自行調整，此處設為 30x40)
                                const w = 40;
                                const h = 40;
                                // 繪製圖片 (置中)
                                ctx.drawImage(img, -w / 2, -h / 2, w, h);

                                // 選填：保留發光特效增強辨識度
                                ctx.shadowColor = '#00ffff';
                                ctx.shadowBlur = 15;
                                ctx.globalCompositeOperation = 'screen'; // 讓光暈更亮
                                ctx.drawImage(img, -w / 2, -h / 2, w, h);
                            } else {
                                // (備案) 若無圖片，維持原本的程式碼繪製
                                // 罐身
                                drawRoundedRect(-10, -15, 20, 30, 4, '#3498db'); // 藍色罐體
                                // 罐蓋
                                ctx.fillStyle = '#bdc3c7';
                                ctx.fillRect(-10, -15, 20, 4);
                                // 閃電標誌
                                ctx.fillStyle = '#f1c40f';
                                ctx.beginPath();
                                ctx.moveTo(2, -8); ctx.lineTo(-6, 2); ctx.lineTo(0, 2);
                                ctx.lineTo(-2, 10); ctx.lineTo(6, 0); ctx.lineTo(0, 0);
                                ctx.closePath(); ctx.fill();

                                // 發光特效
                                ctx.shadowColor = '#00ffff';
                                ctx.shadowBlur = 10;
                                ctx.strokeStyle = 'white';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(-10, -15, 20, 30);
                            }

                            ctx.restore();
                        }
                        else if (item.type === 'player') {
                            // ★★★ 修改：根據性別繪製對應圖片 ★★★
                            const pImg = assets.player[state.player.gender];
                            // 設定繪製尺寸 (根據圖片比例調整，這裡設為寬40 高60，保持長方形比例)
                            const w = 40;
                            const h = 45;

                            if (pImg && pImg.complete) {
                                ctx.save();
                                ctx.translate(state.player.x, state.player.y);
                                // 簡單的走路搖晃動畫
                                if (state.player.moving) {
                                    const wobble = Math.sin(state.frameCount * 0.2) * 5;
                                    ctx.rotate(wobble * Math.PI / 180);
                                }
                                ctx.drawImage(pImg, -w / 2, -h / 2, w, h);
                                ctx.restore();
                            } else {
                                // 圖片未載入時的備案 (原本的 canvas 繪製函式)
                                drawFirefighterHighRes(state.player.x, state.player.y, 0, '#1a253a', state.frameCount, state.player.moving);
                            }

                            // ★★★ 新增：SP Buff 視覺特效 (腳下光環) ★★★
                            if (state.spBuffTimer > 0) {
                                ctx.save();
                                ctx.translate(state.player.x, state.player.y);
                                ctx.globalCompositeOperation = 'lighter';
                                ctx.fillStyle = `rgba(0, 255, 255, ${0.3 + Math.sin(state.frameCount * 0.2) * 0.2})`;
                                ctx.beginPath();
                                ctx.ellipse(0, 5, 20, 10, 0, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }

                        }

                    });

                    drawNPCGroups(state.npcGroups);
                    drawStaticNpcs(state.staticNpcs);

                    state.particles.forEach(pt => {
                        ctx.fillStyle = pt.color || 'rgba(150, 150, 150, 0.3)';
                        ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI * 2); ctx.fill();
                    });

                    drawPlacementPreview(state.placementMode);

                    // ★★★ 在此處呼叫新增的函式 (建議放在 drawPlacementPreview 之後，選單之前) ★★★
                    drawInteractionIndicators();
                    drawMenu(state.interactionMenu);
                    drawSurvivorInfo(state.player);

                    state.feedbacks.forEach(f => {
                        ctx.fillStyle = f.color;
                        ctx.font = 'bold 14px "Courier New"';
                        ctx.shadowColor = 'black';
                        ctx.shadowBlur = 2;
                        ctx.fillText(f.text, f.x - 20, f.y);
                        ctx.shadowBlur = 0;
                    });

                    ctx.restore();

                    ctx.save();
                    let time = Date.now();
                    let policeAlpha = (Math.sin(time / 200) + 1) / 2 * 0.1;
                    ctx.fillStyle = `rgba(0, 0, 255, ${policeAlpha})`; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                    if (Math.sin(time / 200 + Math.PI) > 0) { ctx.fillStyle = `rgba(255, 0, 0, ${policeAlpha})`; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); }
                    ctx.restore();
                };

                const loop = () => {
                    update();
                    draw();
                    if (!gameState.current.isGameOver) {
                        state.animationFrameId = requestAnimationFrame(loop);
                    }
                };
                loop();

                return () => {
                    window.removeEventListener('resize', resize);
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                    canvas.removeEventListener('click', handleCanvasClick);
                    window.removeEventListener('contextmenu', handleContextMenu);
                    // 移除監聽 // 移除 mousemove
                    window.removeEventListener('mousemove', handleMouseMove);
                    cancelAnimationFrame(state.animationFrameId);
                };
            }, [gameOver, gameStarted]);
            useEffect(() => {
                if (gameOver) return;

                // 計算目前各項進度
                const placedCount = Object.values(triageCounts).reduce((a, b) => a + b, 0);
                const currentEvacuatedCount = gameState.current.survivors.filter(s => s.onAmbulance).length;
                const deadCount = gameState.current.survivors.filter(s => s.triageTag === 'black').length;

                // 判斷條件：
                // 1. 檢傷人數 = 總人數
                // 2. 安置人數 = 總人數
                // 3. 後送人數 + 死亡人數 = 總人數 (因黑卡無法後送，故將死亡視為此項已處理)
                const isTriageDone = survivorCount >= totalSurvivors;
                const isPlacementDone = placedCount >= totalSurvivors;
                const isEvacDone = (currentEvacuatedCount + deadCount) >= totalSurvivors;

                // 只要三個 OBJ 都完成，就觸發 Mission Complete
                if (isTriageDone && isPlacementDone && isEvacDone) {
                    setMissionComplete(true);

                    // --- 計算詳細結算數據 ---
                    const survivors = gameState.current.survivors;

                    // 1. 檢傷正確率
                    const triageStats = {
                        green: { correct: 0, total: 0 },
                        yellow: { correct: 0, total: 0 },
                        red: { correct: 0, total: 0 },
                        black: { correct: 0, total: 0 }
                    };

                    // 4. 除汙統計
                    let totalContaminated = 0;

                    // 5. 紅色優先後送統計
                    let totalInitialReds = 0;
                    let evacuatedReds = 0;

                    survivors.forEach(s => {
                        // 檢傷統計 (比較 最終貼的標籤 vs 當前實際傷情)
                        // 注意：如果傷患死亡，實際傷情會變為 black，若玩家貼 black 算正確
                        const actual = s.data.severity;
                        const tagged = s.triageTag;

                        if (triageStats[actual]) {
                            triageStats[actual].total++;
                            if (tagged === actual) {
                                triageStats[actual].correct++;
                            }
                        }

                        // 除汙統計
                        if (s.data.wasContaminated) {
                            totalContaminated++;
                        }

                        // 紅色優先統計
                        // 邏輯：計算有多少「初始為紅色」的傷患，最終成功被後送
                        if (s.data.initialSeverity === 'red') {
                            totalInitialReds++;
                            if (s.onAmbulance) {
                                evacuatedReds++;
                            }
                        }
                    });

                    // 2. 遊戲時間
                    const timeSeconds = Math.floor(gameState.current.frameCount / 60);

                    // 3. 治療正確率 (止血 + 呼吸道 合併計算)
                    const treatTotal = statsTracker.current.tourniquet.total + statsTracker.current.airway.total;
                    const treatCorrect = statsTracker.current.tourniquet.correct + statsTracker.current.airway.correct;

                    setResultStats({
                        triage: triageStats,
                        timeSeconds: timeSeconds,
                        treatment: { correct: treatCorrect, total: treatTotal },
                        decon: { correct: statsTracker.current.deconCount, total: totalContaminated },
                        redEvac: { correct: evacuatedReds, total: totalInitialReds }
                    });
                }
            }, [survivorCount, triageCounts, evacuatedCount, gameOver, updateCount]); // 當檢傷數或安置數變化時檢查

            const getPct = (correct, total) => {
                if (total === 0) return "100%"; // 若無該類別傷患，視為滿分
                return Math.round((correct / total) * 100) + "%";
            };
            // ★★★ 遊戲流程控制 (Intro -> CharacterSelect -> Game) ★★★
            // 如果遊戲還沒開始
            if (!gameStarted) {
                // 如果處於「顯示人物選擇」階段
                if (showCharacterSelect) {
                    return <CharacterSelection onSelect={handleCharacterSelect} />;
                }
                // 否則顯示開頭動畫 (動畫結束後觸發 setShowCharacterSelect)
                return <IntroScreen onStart={() => setShowCharacterSelect(true)} />;
            }
            return (
                <div className="flex justify-center items-center h-screen bg-[#050505] text-white overflow-hidden font-mono relative">
                    <div className="relative shadow-[0_0_50px_rgba(0,0,20,0.5)] border-2 border-[#333] bg-[#111]">
                        <canvas ref={canvasRef} className="block image-pixelated cursor-default" />

                        {gameOver && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-50 animate-fade-in">
                                <h1 className="text-5xl text-red-600 font-bold mb-8 tracking-widest drop-shadow-[0_0_10px_rgba(255,0,0,0.8)] animate-pulse">
                                    GAME OVER
                                </h1>
                                <div className="text-gray-400 mb-8 text-center text-sm">
                                    任務失敗：生命跡象消失<br />
                                    總計檢傷：{survivorCount}/{totalSurvivors}
                                </div>
                                <button
                                    onClick={handleRestart}
                                    className="px-8 py-3 bg-white text-black font-bold text-lg hover:bg-gray-300 hover:scale-105 transition transform rounded shadow-lg border-2 border-transparent hover:border-gray-500"
                                >
                                    重新遊戲
                                </button>
                            </div>
                        )}
                        {/* ★★★ 修改：Mission Complete 結算畫面 ★★★ */}
                        {missionComplete && resultStats && (
                            <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center z-[100] animate-fade-in backdrop-blur-md p-8">
                                <h1 className="text-5xl text-yellow-400 font-bold mb-2 tracking-widest drop-shadow-[0_0_20px_rgba(253,224,71,0.6)]" style={{ fontFamily: 'Impact, sans-serif' }}>
                                    MISSION COMPLETE
                                </h1>
                                <div className="text-gray-400 mb-6 text-sm">任務耗時: {Math.floor(resultStats.timeSeconds / 60)}分 {resultStats.timeSeconds % 60}秒</div>

                                <div className="grid grid-cols-2 gap-x-12 gap-y-6 w-full max-w-4xl">
                                    {/* 1. 檢傷正確率面板 */}
                                    <div className="bg-gray-800/50 p-6 rounded-lg border border-gray-700">
                                        <h3 className="text-xl font-bold text-blue-400 mb-4 border-b border-gray-600 pb-2">檢傷正確率</h3>
                                        <div className="space-y-3">
                                            <div className="flex justify-between items-center">
                                                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-green-500"></span> 綠色輕傷</div>
                                                <div className="font-mono text-lg">{getPct(resultStats.triage.green.correct, resultStats.triage.green.total)} <span className="text-xs text-gray-500">({resultStats.triage.green.correct}/{resultStats.triage.green.total})</span></div>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-yellow-500"></span> 黃色中傷</div>
                                                <div className="font-mono text-lg">{getPct(resultStats.triage.yellow.correct, resultStats.triage.yellow.total)} <span className="text-xs text-gray-500">({resultStats.triage.yellow.correct}/{resultStats.triage.yellow.total})</span></div>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-red-600"></span> 紅色重傷</div>
                                                <div className="font-mono text-lg">{getPct(resultStats.triage.red.correct, resultStats.triage.red.total)} <span className="text-xs text-gray-500">({resultStats.triage.red.correct}/{resultStats.triage.red.total})</span></div>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-gray-500"></span> 黑色死亡</div>
                                                <div className="font-mono text-lg">{getPct(resultStats.triage.black.correct, resultStats.triage.black.total)} <span className="text-xs text-gray-500">({resultStats.triage.black.correct}/{resultStats.triage.black.total})</span></div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* 右側欄：其他統計 */}
                                    <div className="space-y-6">
                                        {/* 3. 處置正確率 */}
                                        <div className="bg-gray-800/50 p-4 rounded-lg border border-gray-700">
                                            <h3 className="text-lg font-bold text-yellow-400 mb-2">急救處置正確率</h3>
                                            <div className="text-sm text-gray-400 mb-1">(止血帶 / 暢通呼吸道)</div>
                                            <div className="flex justify-between items-end">
                                                <div className="text-3xl font-bold text-white">{getPct(resultStats.treatment.correct, resultStats.treatment.total)}</div>
                                                <div className="text-gray-500">操作: {resultStats.treatment.correct}/{resultStats.treatment.total}</div>
                                            </div>
                                        </div>

                                        {/* 4. 除汙正確率 */}
                                        <div className="bg-gray-800/50 p-4 rounded-lg border border-gray-700">
                                            <h3 className="text-lg font-bold text-purple-400 mb-2">傷患除汙完成率</h3>
                                            <div className="flex justify-between items-end">
                                                <div className="text-3xl font-bold text-white">{getPct(resultStats.decon.correct, resultStats.decon.total)}</div>
                                                <div className="text-gray-500">已除汙: {resultStats.decon.correct}/{resultStats.decon.total}</div>
                                            </div>
                                        </div>

                                        {/* 5. 紅色優先後送率 */}
                                        <div className="bg-gray-800/50 p-4 rounded-lg border border-gray-700">
                                            <h3 className="text-lg font-bold text-red-400 mb-2">紅色傷患優先後送率</h3>
                                            <div className="text-sm text-gray-400 mb-1">(成功存活並送醫的重傷患)</div>
                                            <div className="flex justify-between items-end">
                                                <div className="text-3xl font-bold text-white">{getPct(resultStats.redEvac.correct, resultStats.redEvac.total)}</div>
                                                <div className="text-gray-500">成功後送: {resultStats.redEvac.correct}/{resultStats.redEvac.total}</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* 完成按鈕  */}

                                <button
                                    onClick={handleRestart}
                                    className="px-12 py-4 bg-yellow-500 hover:bg-yellow-400 text-black text-2xl font-black rounded shadow-[0_0_30px_rgba(234,179,8,0.4)] transform hover:scale-105 transition-all duration-200"
                                >
                                    重新開始
                                </button>
                            </div>
                        )}
                        {/* ★★★ 4. 新增：無線電 UI 面板 (仿平板風格) ★★★ */}
                        {showRadioPanel && (
                            <div className="absolute top-[210px] left-3 w-72 bg-slate-900/95 border-2 border-blue-500 rounded-lg shadow-[0_0_30px_rgba(59,130,246,0.3)] p-4 text-white z-50 animate-fade-in font-sans custom-scrollbar">
                                <div className="flex justify-between items-center mb-4 border-b border-blue-500/50 pb-2">
                                    <h2 className="text-lg font-bold text-blue-400 flex items-center gap-2">
                                        📻 無線電指揮
                                    </h2>
                                    <span className="text-xs text-gray-400">MP: {Math.floor(playerStatsUI.mp)}</span>
                                </div>
                                <div className="space-y-3">
                                    {/* 1. 請求救護車 */}
                                    <button
                                        onClick={() => {
                                            const state = gameState.current;
                                            if (state.ambulanceCooldown > 0) {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: `冷卻中 (${Math.ceil(state.ambulanceCooldown / 60)}s)`, color: "#bdc3c7", life: 60, vy: -0.5 });
                                                return;
                                            }
                                            const stagingArea = state.triageMats.find(m => m.color === 'ambulance_staging');
                                            if (!stagingArea) {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "無設置救護車待命區", color: "#e74c3c", life: 60, vy: -0.5 });
                                                return;
                                            }
                                            if (state.stats.mp >= 10) {
                                                state.stats.mp -= 10;
                                                state.ambulanceCooldown = 1500;
                                                const ambCount = Math.floor(Math.random() * 3) + 1;
                                                for (let k = 0; k < ambCount; k++) {
                                                    const ax = stagingArea.x + 10 + Math.random() * (stagingArea.w - 90);
                                                    const ay = stagingArea.y + 10 + Math.random() * (stagingArea.h - 60);
                                                    state.emergencyVehicles.push({
                                                        id: Math.random(), type: 'ambulance', passengers: [], state: 'arriving',
                                                        x: state.camera.x - 150 - (k * 100), y: ay, targetX: ax, targetY: ay, w: 80, h: 40, angle: 0
                                                    });
                                                }
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "救護車趕往中...", color: "#3498db", life: 60, vy: -0.5 });
                                                forceUpdate(n => n + 1);
                                            } else {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "MP不足!", color: "#e74c3c", life: 60, vy: -0.5 });
                                            }
                                        }}
                                        className="w-full bg-slate-800 hover:bg-slate-700 border border-slate-600 p-3 rounded flex justify-between items-center transition group"
                                    >
                                        <span className="font-bold text-blue-300 group-hover:text-blue-200">請求救護車</span>
                                        <span className="text-xs bg-blue-900 text-blue-200 px-2 py-1 rounded">-10 MP</span>
                                    </button>

                                    {/* 2. 請求消防車 */}
                                    <button
                                        onClick={() => {
                                            const state = gameState.current;
                                            const target = state.hazards.find(h => !h.beingExtinguished);
                                            if (target) {
                                                if (state.stats.mp >= 10) {
                                                    state.stats.mp -= 10;
                                                    target.beingExtinguished = true;
                                                    state.firefightingSquads.push({
                                                        x: 50 + 700, y: 540 / 2 - 150, target: target, state: 'moving_to_fire'
                                                    });
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "派遣消防車支援", color: "#e74c3c", life: 60, vy: -0.5 });
                                                    forceUpdate(n => n + 1);
                                                } else {
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "MP不足!", color: "#e74c3c", life: 60, vy: -0.5 });
                                                }
                                            } else {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "目前無火災需處理", color: "#2ecc71", life: 60, vy: -0.5 });
                                            }
                                        }}
                                        className="w-full bg-slate-800 hover:bg-slate-700 border border-slate-600 p-3 rounded flex justify-between items-center transition group"
                                    >
                                        <span className="font-bold text-red-400 group-hover:text-red-300">請求消防車</span>
                                        <span className="text-xs bg-red-900 text-red-200 px-2 py-1 rounded">-10 MP</span>
                                    </button>

                                    {/* 3. 請求破壞小組 */}
                                    <button
                                        onClick={() => {
                                            const state = gameState.current;
                                            const target = state.obstacles.find(o =>
                                                ['sedan', 'truck'].includes(o.type) && !o.isBreached && o.breakTimer === 0 &&
                                                state.survivors.some(s => s.trappedInVehicle === o) &&
                                                !state.rescueSquads.some(sq => sq.target === o)
                                            );
                                            if (target) {
                                                if (state.stats.mp >= 10) {
                                                    state.stats.mp -= 10;
                                                    state.rescueSquads.push({
                                                        x: 50 + 700, y: 540 / 2 - 100, target: target, state: 'moving_to_vehicle'
                                                    });
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "派遣破壞小組", color: "#e67e22", life: 60, vy: -0.5 });
                                                    forceUpdate(n => n + 1);
                                                } else {
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "MP不足!", color: "#e74c3c", life: 60, vy: -0.5 });
                                                }
                                            } else {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "無受困車輛需處理", color: "#bdc3c7", life: 60, vy: -0.5 });
                                            }
                                        }}
                                        className="w-full bg-slate-800 hover:bg-slate-700 border border-slate-600 p-3 rounded flex justify-between items-center transition group"
                                    >
                                        <span className="font-bold text-orange-400 group-hover:text-orange-300">請求破壞小組</span>
                                        <span className="text-xs bg-orange-900 text-orange-200 px-2 py-1 rounded">-10 MP</span>
                                    </button>

                                    {/* 4. 請求搬運人員 */}
                                    <button
                                        onClick={() => {
                                            const state = gameState.current;
                                            if (state.npcGroups.length >= 2) {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "搬運人力已達上限", color: "#e74c3c", life: 60, vy: -0.5 });
                                                return;
                                            }
                                            const unassignedTargets = state.survivors.filter(s =>
                                                s.triageTag && ['red', 'yellow', 'black'].includes(s.triageTag) &&
                                                !s.isEvacuating && !s.hasArrived && !s.isBeingCarried &&
                                                !state.npcGroups.some(g => g.target === s) &&
                                                (!s.trappedInVehicle || s.trappedInVehicle.isBreached) &&
                                                !state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30)
                                            );
                                            if (unassignedTargets.length > 0) {
                                                if (state.stats.mp >= 10) {
                                                    state.stats.mp -= 10;
                                                    unassignedTargets.sort((a, b) => {
                                                        const p = { 'black': 3, 'red': 2, 'yellow': 1 };
                                                        return p[b.triageTag] - p[a.triageTag];
                                                    });
                                                    state.npcGroups.push({
                                                        leaderX: 20 + 700, leaderY: 600, followerX: 0 + 700, followerY: 600,
                                                        target: unassignedTargets[0], state: 'moving_to_target', carrying: false
                                                    });
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "增派搬運人員", color: "#9b59b6", life: 60, vy: -0.5 });
                                                    forceUpdate(n => n + 1);
                                                } else {
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "MP不足!", color: "#e74c3c", life: 60, vy: -0.5 });
                                                }
                                            } else {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "目前無傷患需搬運", color: "#bdc3c7", life: 60, vy: -0.5 });
                                            }
                                        }}
                                        className="w-full bg-slate-800 hover:bg-slate-700 border border-slate-600 p-3 rounded flex justify-between items-center transition group"
                                    >
                                        <span className="font-bold text-purple-400 group-hover:text-purple-300">請求搬運人員</span>
                                        <span className="text-xs bg-purple-900 text-purple-200 px-2 py-1 rounded">-10 MP</span>
                                    </button>
                                </div>
                            </div>
                        )}


                        {/* ★★★ 檢傷平板浮動視窗 (靠右顯示) ★★★ */}
                        {showTabletUI && (
                            <>
                                {/* 左側：救護車調度列表 */}
                                <div className="absolute top-16 right-80 w-72 bg-slate-900/95 border-2 border-blue-500 rounded-lg shadow-[0_0_30px_rgba(59,130,246,0.3)] p-4 text-white z-50 max-h-[80vh] overflow-y-auto font-sans animate-fade-in custom-scrollbar">
                                    <div className="flex justify-between items-center mb-4 border-b border-blue-500/50 pb-2">
                                        <h2 className="text-lg font-bold text-blue-400 flex items-center gap-2">
                                            🚑 救護車調度
                                        </h2>
                                        {/* --- 新增：修改：呼叫小巴按鈕 (MP-30)--- */}
                                        <button
                                            onClick={() => {
                                                const state = gameState.current;
                                                // 1. 檢查冷卻
                                                if (state.ambulanceCooldown > 0) {
                                                    state.feedbacks.push({
                                                        x: state.player.x,
                                                        y: state.player.y - 50,
                                                        text: `調度冷卻中 (${Math.ceil(state.ambulanceCooldown / 60)}s)`,
                                                        color: "#bdc3c7",
                                                        life: 60,
                                                        vy: -0.5
                                                    });
                                                    return;
                                                }
                                                // 2. 檢查待命區
                                                const stagingArea = state.triageMats.find(m => m.color === 'ambulance_staging');
                                                if (!stagingArea) {
                                                    // ★★★ 修正：改用遊戲內浮動文字提示，而非 alert ★★★
                                                    state.feedbacks.push({
                                                        x: state.player.x,
                                                        y: state.player.y - 50,
                                                        text: "請先設置救護車待命區！",
                                                        color: "#e74c3c",
                                                        life: 60,
                                                        vy: -0.5
                                                    });
                                                    return;
                                                }
                                                // 3. 檢查 MP 並扣除
                                                if (state.stats.mp >= 30) {
                                                    state.stats.mp -= 30;
                                                    state.ambulanceCooldown = 3600; // 設定 60秒冷卻

                                                    // ★★★ 修改：生成 1 台小巴 ★★★
                                                    let destX, destY;
                                                    let isSafe = false;
                                                    let attempts = 0;
                                                    while (!isSafe && attempts < 10) {
                                                        destX = stagingArea.x + 10 + Math.random() * (stagingArea.w - 90);
                                                        destY = stagingArea.y + 10 + Math.random() * (stagingArea.h - 60);

                                                        const dist = Math.hypot(state.player.x - (destX + 40), state.player.y - (destY + 20));
                                                        if (dist > 80) isSafe = true;
                                                        attempts++;
                                                    }

                                                    state.emergencyVehicles.push({
                                                        id: Math.random(),
                                                        type: 'mini_bus', // 類型設為小巴
                                                        passengers: [],
                                                        state: 'arriving',
                                                        x: state.camera.x - 150,
                                                        y: destY,
                                                        targetX: destX,
                                                        targetY: destY,
                                                        w: 100, h: 50, angle: 0
                                                    });

                                                    forceUpdate(prev => prev + 1); // 強制重繪
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "-30 MP (小巴支援)", color: "#f1c40f", life: 60, vy: -0.5 });
                                                } else {
                                                    alert("MP不足 (需 30)！");
                                                }
                                            }}
                                            className="px-2 py-1 bg-yellow-600 hover:bg-yellow-500 text-white text-xs rounded shadow transition border border-yellow-400"
                                        >
                                            呼叫小型巴士支援 (-30MP)
                                        </button>
                                    </div>
                                    <div className="space-y-3">
                                        {(() => {
                                            const staging = gameState.current.triageMats.find(m => m.color === 'ambulance_staging');
                                            let vehicles = [];
                                            if (staging) {
                                                // ★★★ 修改：篩選 ambulance 和 mini_bus ★★★
                                                vehicles = gameState.current.emergencyVehicles.filter(v =>
                                                    ['ambulance', 'mini_bus'].includes(v.type) && v.state !== 'departing' &&
                                                    v.x >= staging.x && v.x <= staging.x + staging.w &&
                                                    v.y >= staging.y && v.y <= staging.y + staging.h
                                                );
                                            } else {
                                                vehicles = gameState.current.emergencyVehicles.filter(v => ['ambulance', 'mini_bus'].includes(v.type) && v.state !== 'departing');
                                            }

                                            if (vehicles.length === 0) {
                                                return <div className="text-gray-500 text-center py-4">待命區無車輛</div>;
                                            }

                                            return vehicles.map((veh, idx) => {
                                                // ★★★ 修改：載送規則檢查 (區分小巴與救護車) ★★★
                                                const canLoad = (patientTag) => {
                                                    const p = veh.passengers;

                                                    // (1) 小巴規則: 只載綠色，上限 8 人
                                                    if (veh.type === 'mini_bus') {
                                                        if (patientTag !== 'green') return false;
                                                        if (p.length >= 8) return false;
                                                        return true;
                                                    }

                                                    // (2) 救護車規則: 1紅 OR 1黃1綠 OR 2綠
                                                    if (p.length === 0) return true;
                                                    const hasRed = p.includes('red');
                                                    const hasYellow = p.includes('yellow');
                                                    const greens = p.filter(c => c === 'green').length;

                                                    if (hasRed) return false;
                                                    if (patientTag === 'red') return false;
                                                    if (patientTag === 'yellow') return greens === 1 && !hasYellow;
                                                    if (patientTag === 'green') {
                                                        if (hasYellow) return true;
                                                        if (greens === 1) return true;
                                                        return false;
                                                    }
                                                    return false;
                                                };

                                                const handleVehicleClick = () => {
                                                    // ★★★ 若為靜態車輛(第一台)，禁止互動 ★★★
                                                    if (veh.isStatic) {
                                                        alert("此為現場指揮車，不執行後送任務！");
                                                        return;
                                                    }
                                                    if (!selectedPatient) return;

                                                    if (canLoad(selectedPatient.triageTag)) {
                                                        if (selectedPatient.triageTag === 'red') {
                                                            setScore(prev => prev + 500);
                                                            // 手動推入 feedback (因為此處在 useEffect 外)
                                                            gameState.current.feedbacks.push({
                                                                x: gameState.current.player.x,
                                                                y: gameState.current.player.y - 50,
                                                                text: "優先後送紅色 +500",
                                                                color: "#f1c40f",
                                                                life: 60,
                                                                vy: -0.5
                                                            });
                                                        }

                                                        veh.passengers.push(selectedPatient.triageTag);
                                                        selectedPatient.onAmbulance = true;
                                                        setSelectedPatient(null);

                                                        const p = veh.passengers;

                                                        // ★★★ 修改：自動出發邏輯 ★★★
                                                        let shouldDepart = false;
                                                        if (veh.type === 'mini_bus') {
                                                            if (p.length >= 8) shouldDepart = true;
                                                        } else {
                                                            const hasRed = p.includes('red');
                                                            const hasYellow = p.includes('yellow');
                                                            const greens = p.filter(c => c === 'green').length;
                                                            if (hasRed || (hasYellow && greens >= 1) || greens >= 2) {
                                                                shouldDepart = true;
                                                            }
                                                        }

                                                        if (shouldDepart) {
                                                            veh.state = 'departing';
                                                        }
                                                        // ★★★ 新增：立即重新計算安置人數 (因為有人上車了，要從安置名單扣除) ★★★
                                                        const counts = { green: 0, yellow: 0, red: 0, black: 0 };
                                                        gameState.current.survivors.forEach(s => {
                                                            if (s.hasArrived && s.triageTag && !s.onAmbulance) {
                                                                counts[s.triageTag]++;
                                                            }
                                                        });
                                                        setTriageCounts(counts);

                                                        forceUpdate(prev => prev + 1);
                                                    } else {
                                                        if (veh.type === 'mini_bus') {
                                                            alert("小巴只能載送綠色輕傷患者 (上限8人)！");
                                                        } else {
                                                            alert("不符合載送規則或車位已滿！\n規則: 1紅 或 1黃1綠 或 2綠");
                                                        }
                                                    }
                                                };


                                                const handleManualDepart = (e) => {
                                                    e.stopPropagation();
                                                    if (veh.isStatic) return;

                                                    if (veh.passengers.length > 0) {
                                                        veh.state = 'departing';
                                                        forceUpdate(prev => prev + 1);
                                                    }
                                                };

                                                // 顯示名稱與顏色
                                                const vehName = veh.type === 'mini_bus' ? `小巴 #${idx + 1}` : `救護車 #${idx + 1}`;
                                                const vehColor = veh.type === 'mini_bus' ? 'text-yellow-400' : 'text-gray-300';
                                                const displayName = veh.isStatic ? `${vehName} (指揮用)` : vehName;
                                                return (
                                                    <div
                                                        key={veh.id || idx}
                                                        onClick={handleVehicleClick}
                                                        className={`bg-slate-800/50 p-3 rounded border border-slate-700 hover:bg-slate-700 cursor-pointer transition
                                                    ${selectedPatient ? (canLoad(selectedPatient.triageTag) ? 'ring-2 ring-green-500' : 'opacity-50 cursor-not-allowed') : ''}
                                                `}
                                                    >
                                                        <div className="flex justify-between mb-2">
                                                            <span className={`font-bold ${vehColor}`}>{vehName}</span>
                                                            <span className="text-xs text-blue-400">點擊載入</span>
                                                            <button
                                                                onClick={handleManualDepart}
                                                                disabled={veh.passengers.length === 0}
                                                                className={`px-3 py-1 text-xs rounded font-bold transition-colors z-10
                                                            ${veh.passengers.length > 0
                                                                        ? 'bg-blue-600 hover:bg-blue-500 text-white shadow-md'
                                                                        : 'bg-gray-700 text-gray-500 cursor-not-allowed'}
                                                        `}
                                                            >
                                                                出發
                                                            </button>
                                                        </div>
                                                        {/* ★★★ 修改：乘客顯示格 (支援小巴多格) ★★★ */}
                                                        <div className="flex gap-1 h-4 bg-slate-900 rounded overflow-hidden flex-wrap">
                                                            {veh.passengers.length === 0 && <div className="w-full text-[10px] text-center text-gray-600 leading-4">空車</div>}
                                                            {veh.passengers.map((tag, pi) => (
                                                                <div key={pi} className={`h-full ${veh.type === 'mini_bus' ? 'w-[11%]' : 'flex-1'} ${tag === 'red' ? 'bg-red-500' :
                                                                    tag === 'yellow' ? 'bg-yellow-500' : 'bg-green-500'
                                                                    } border-r border-slate-800`}></div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                );
                                            });
                                        })()}
                                    </div>
                                </div>
                                {/* ★★★ 檢傷資訊列表 ★★★ */}
                                <div className="absolute top-16 right-4 w-72 bg-slate-900/95 border-2 border-green-500 rounded-lg shadow-[0_0_30px_rgba(34,197,94,0.3)] p-4 text-white z-50 max-h-[80vh] overflow-y-auto font-sans animate-fade-in custom-scrollbar">
                                    <div className="flex justify-between items-center mb-4 border-b border-green-500/50 pb-2">
                                        <div className="flex items-end gap-2">
                                            <h2 className="text-lg font-bold text-green-400 flex items-center gap-2">
                                                📋 傷患名單
                                            </h2>
                                            <span className="text-sm font-bold text-gray-300 leading-none mb-0.5">
                                                目前共 {survivorCount} 名
                                            </span>
                                        </div>
                                        <span className="text-xs text-gray-400">點擊選擇傷患</span>
                                    </div>
                                    <div className="space-y-2">
                                        {gameState.current.survivors.filter(s => s.triageTag).length === 0 ? (
                                            <div className="text-center text-gray-500 py-4">尚無檢傷紀錄</div>
                                        ) : (
                                            gameState.current.survivors.map((s, idx) => {
                                                if (!s.triageTag) return null; // 只顯示已檢傷的
                                                // 如果已上車或已死亡(轉黑卡)通常還是顯示，方便查看，但可根據需求過濾
                                                return (
                                                    <div
                                                        key={idx}
                                                        onClick={() => !s.onAmbulance && setSelectedPatient(s)}
                                                        className={`p-2 rounded border cursor-pointer transition flex justify-between items-center
                                                    ${selectedPatient === s ? 'bg-green-900/50 border-green-400 ring-1 ring-green-400' : 'bg-slate-800/50 border-slate-700 hover:bg-slate-700'}
                                                    ${s.onAmbulance ? 'opacity-50 cursor-not-allowed' : ''}
                                                `}
                                                    >
                                                        <div className="flex items-center gap-3">
                                                            <span className={`w-3 h-3 rounded-full ${s.triageTag === 'red' ? 'bg-red-500' :
                                                                s.triageTag === 'yellow' ? 'bg-yellow-500' :
                                                                    s.triageTag === 'green' ? 'bg-green-500' : 'bg-gray-600'
                                                                }`}></span>
                                                            <div>
                                                                <div className="text-sm font-bold text-gray-200">
                                                                    傷患 #{idx + 1} <span className="text-xs text-gray-400">({s.data.sex}, {s.data.age})</span>
                                                                </div>
                                                                <div className="text-xs text-gray-500">{s.data.injuryText}</div>
                                                            </div>
                                                        </div>
                                                        {s.onAmbulance ? (
                                                            <span className="text-[10px] bg-blue-900 text-blue-300 px-1 py-0.5 rounded">已上車</span>
                                                        ) : s.hasArrived ? (
                                                            <span className="text-[10px] bg-gray-700 text-gray-300 px-1 py-0.5 rounded">已安置</span>
                                                        ) : (
                                                            <span className="text-[10px] bg-gray-800 text-gray-500 px-1 py-0.5 rounded">待處理</span>
                                                        )}
                                                    </div>
                                                );
                                            })
                                        )}
                                    </div>
                                </div>
                                {/* --- 新增：檢傷統計面板 (畫面正上方置中) --- */}
                                <div className="absolute top-0 left-1/2 -translate-x-1/2 pointer-events-none select-none z-50">
                                    <div className="flex gap-4 bg-black/80 p-2 px-4 border-b-2 border-gray-600 rounded-b-lg shadow-xl">
                                        {/* 綠色 */}
                                        <div className="flex items-center gap-1">
                                            <span className="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_5px_rgba(34,197,94,0.8)]"></span>
                                            <span className="text-xs text-gray-300">綠色:</span>
                                            <span className="text-sm font-bold text-green-400">{triageCounts.green}</span>
                                        </div>
                                        {/* 黃色 */}
                                        <div className="flex items-center gap-1">
                                            <span className="w-2 h-2 rounded-full bg-yellow-500 shadow-[0_0_5px_rgba(234,179,8,0.8)]"></span>
                                            <span className="text-xs text-gray-300">黃色:</span>
                                            <span className="text-sm font-bold text-yellow-400">{triageCounts.yellow}</span>
                                        </div>
                                        {/* 紅色 */}
                                        <div className="flex items-center gap-1">
                                            <span className="w-2 h-2 rounded-full bg-red-600 shadow-[0_0_5px_rgba(220,38,38,0.8)]"></span>
                                            <span className="text-xs text-gray-300">紅色:</span>
                                            <span className="text-sm font-bold text-red-500">{triageCounts.red}</span>
                                        </div>
                                        {/* 黑色 */}
                                        <div className="flex items-center gap-1">
                                            <span className="w-2 h-2 rounded-full bg-gray-600 shadow-[0_0_5px_rgba(107,114,128,0.8)]"></span>
                                            <span className="text-xs text-gray-300">黑色:</span>
                                            <span className="text-sm font-bold text-gray-400">{triageCounts.black}</span>
                                        </div>
                                    </div>
                                </div>
                            </>
                        )}
                        {/* 地墊選擇選單 */}
                        {showMatSelector && (
                            <div className="absolute bottom-16 left-1/2 -translate-x-1/2 bg-black/90 p-4 rounded-lg border border-gray-500 shadow-xl flex gap-4 z-50">
                                {[
                                    { id: 'green', label: '輕傷區', bg: 'bg-green-500', hover: 'hover:bg-green-400', text: 'text-black' },
                                    { id: 'yellow', label: '中傷區', bg: 'bg-yellow-500', hover: 'hover:bg-yellow-400', text: 'text-black' },
                                    { id: 'red', label: '重傷區', bg: 'bg-red-600', hover: 'hover:bg-red-500', text: 'text-white' },
                                    { id: 'black', label: '黑卡區', bg: 'bg-gray-800', hover: 'hover:bg-gray-700', text: 'text-white' }
                                ].map(btn => {
                                    // 檢查該顏色是否已存在於場景中
                                    const isUsed = gameState.current.triageMats.some(m => m.color === btn.id);

                                    return (
                                        <button
                                            key={btn.id}
                                            onClick={() => !isUsed && handleSelectMatColor(btn.id)}
                                            disabled={isUsed}
                                            className={`
                                                w-16 h-10 font-bold text-xs rounded shadow relative transition-all
                                                ${isUsed
                                                    ? 'bg-gray-700 text-gray-500 cursor-not-allowed border border-gray-600'
                                                    : `${btn.bg} ${btn.hover} ${btn.text}`
                                                }
                                            `}
                                        >
                                            {btn.label}
                                            {isUsed && (
                                                <span className="absolute inset-0 flex items-center justify-center text-red-500/80 text-lg font-bold">✕</span>
                                            )}
                                        </button>
                                    );
                                })}
                            </div>
                        )}
                        {/* --- 修改結束 --- */}

                        <div className="absolute top-3 left-3 pointer-events-none select-none">
                            <div className="bg-black/60 p-1.5 mb-1 backdrop-blur-sm border-l-2 border-[#e74c3c] inline-block">
                                <h1 className="text-sm m-0 text-[#e74c3c] font-bold flex items-center gap-2 tracking-wide">
                                    <IconAlert /> MCI 模擬演練
                                    <span className="text-yellow-400 ml-4 font-mono text-base">Score: {score}</span>
                                </h1>
                            </div>
                            <div className="bg-black/80 p-2 border-l-2 border-orange-500 text-gray-200 text-xs w-[220px] shadow-lg">
                                <div className="grid grid-cols-[auto_1fr] gap-x-2 gap-y-1">
                                    {/* 第一列：OBJ 標籤 與 檢傷人數 */}
                                    <div className="flex items-center gap-2 text-gray-400">
                                        <IconActivity /> <span>OBJ:</span>
                                    </div>
                                    <div>檢傷人數 ({survivorCount}/{totalSurvivors})</div>

                                    {/* 第二列：編號 1. 與 安置人數 */}
                                    <div className="text-right text-gray-400">1.</div>
                                    <div>安置人數 ({Object.values(triageCounts).reduce((a, b) => a + b, 0)}/{totalSurvivors})</div>

                                    {/* 第三列：編號 2. 與 後送人數 */}
                                    <div className="text-right text-gray-400">2.</div>
                                    <div>後送人數 ({gameState.current.survivors.filter(s => s.onAmbulance).length}/{totalSurvivors})</div>

                                </div>
                            </div>
                            <div className="mt-2 w-[150px] flex flex-col gap-1">
                                <div className="flex items-center gap-1 bg-black/60 p-1 rounded-sm">
                                    <span className="text-[10px] font-bold text-red-400 w-4">HP</span>
                                    <div className="h-2 flex-1 bg-gray-700 relative overflow-hidden rounded-sm">
                                        <div className="absolute top-0 left-0 h-full bg-red-600" style={{ width: `${(playerStatsUI.hp / playerStatsUI.maxHp) * 100}%` }}></div>
                                    </div>
                                </div>
                                <div className="flex items-center gap-1 bg-black/60 p-1 rounded-sm">
                                    <span className="text-[10px] font-bold text-blue-400 w-4">MP</span>
                                    <div className="h-2 flex-1 bg-gray-700 relative overflow-hidden rounded-sm">
                                        <div className="absolute top-0 left-0 h-full bg-blue-600" style={{ width: `${(playerStatsUI.mp / playerStatsUI.maxMp) * 100}%` }}></div>
                                    </div>
                                </div>
                                <div className="flex items-center gap-1 bg-black/60 p-1 rounded-sm">
                                    <span className={`text-[10px] font-bold w-4 ${gameState.current.spBuffTimer > 0 ? 'text-cyan-400 animate-pulse' : 'text-yellow-400'}`}>SP</span>
                                    <div className="h-2 flex-1 bg-gray-700 relative overflow-hidden rounded-sm">
                                        <div className="absolute top-0 left-0 h-full bg-yellow-600" style={{ width: `${(playerStatsUI.sp / playerStatsUI.maxSp) * 100}%` }}></div>
                                        <div style={{ width: `${(playerStatsUI.sp / playerStatsUI.maxSp) * 100}%` }}></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        {/* ★★★ 右上角遊戲音樂混音器/開關 ★★★ */}
                        <div className="absolute top-3 right-3 z-50 pointer-events-auto flex items-center gap-4">
                            {/* 文字與按鈕容器 (垂直排列) */}
                            <div className="flex flex-col items-end gap-1 hidden xl:flex">
                                {/* ★★★ 操作說明文字 (透明背景) ★★★ */}
                                <div className="text-white/90 text-xs font-bold tracking-wide select-none drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)] hidden xl:block">
                                    Simple Triage And Rapid Treatment操作說明:鍵盤←↓ ↑→ &nbsp;&nbsp; 互動:E鍵或滑鼠左鍵 &nbsp;&nbsp; 道具欄:I鍵 &nbsp;&nbsp; 取消:C鍵或滑鼠右鍵
                                </div>
                                {/* ★★★ 檢傷流程圖按鈕 ★★★ */}
                                <button
                                    onClick={() => setShowFlowchart(true)}
                                    className="px-2 py-1 bg-slate-700/80 hover:bg-slate-600 text-gray-200 text-xs rounded border border-slate-500 shadow-sm transition-all flex items-center gap-1"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><line x1="3" x2="21" y1="9" y2="9" /><line x1="9" x2="9" y1="21" y2="9" /></svg>
                                    檢傷流程圖/Triage flowchart
                                </button>
                            </div>
                            <button
                                onClick={toggleAudio}
                                className={`
                                    flex items-center gap-2 px-3 py-2 rounded-full border-2 transition-all shadow-lg backdrop-blur-md
                                    ${isMuted
                                        ? 'bg-gray-800/80 border-gray-600 text-gray-400 hover:bg-gray-700'
                                        : 'bg-green-900/80 border-green-500 text-green-400 hover:bg-green-800 playing-wave'
                                    }
                                `}
                            >
                                <IconVolume muted={isMuted} />
                                <span className="text-xs font-bold tracking-wider hidden sm:inline">
                                    {isMuted ? 'MUTE' : 'BGM ON'}
                                </span>
                                {/* 音訊視覺化條 (僅在播放時顯示) */}
                                {!isMuted && (
                                    <div className="flex gap-[2px] items-end h-4 ml-1">
                                        <div className="bar w-1 bg-green-400"></div>
                                        <div className="bar w-1 bg-green-400"></div>
                                        <div className="bar w-1 bg-green-400"></div>
                                        <div className="bar w-1 bg-green-400"></div>
                                    </div>
                                )}
                            </button>
                        </div>
                        {/* --- 道具欄 (修改後：左下角摺疊式) --- */}
                        <div className="absolute bottom-4 left-4 pointer-events-auto select-none z-50">
                            {!showInventory ? (
                                // 摺疊狀態：顯示背包圖示
                                <div
                                    onClick={() => setShowInventory(true)}
                                    className="w-12 h-12 border border-gray-500 bg-black/80 hover:bg-gray-700/80 rounded-md cursor-pointer flex items-center justify-center shadow-lg group transition-transform hover:scale-105"
                                    title="打開道具欄 (I)"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-300 group-hover:text-white">
                                        <path d="M3 7v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7" /><path d="M3 7l9-4 9 4" /><path d="M12 3v4" />
                                    </svg>
                                    {/* 提示文字 */}
                                    <div className="absolute left-14 top-1/2 -translate-y-1/2 bg-black text-white text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 whitespace-nowrap pointer-events-none transition-opacity">
                                        背包 (I)
                                    </div>
                                </div>
                            ) : (
                                // 展開狀態：顯示道具列表 (由左向右延伸)
                                <div className="flex items-end gap-1">
                                    {/* 關閉按鈕 (X) */}
                                    <div
                                        onClick={() => setShowInventory(false)}
                                        className="w-8 h-8 mb-1 mr-1 border border-red-500/50 bg-red-900/30 hover:bg-red-900/50 rounded cursor-pointer flex items-center justify-center text-red-400 font-bold"
                                        title="收起"
                                    >
                                        ✕
                                    </div>
                                    {/* --- 道具欄移至此處 (外層黑色區域) --- */}

                                    <div className="flex gap-1 bg-black/80 p-2 border border-gray-600 rounded-md shadow-[0_0_15px_rgba(0,0,0,0.8)]">
                                        {items.map((item, i) => (
                                            <div
                                                key={i}
                                                onClick={() => handleSlotClick(i)}
                                                className={`w-10 h-10 border bg-gray-900/50 hover:bg-gray-700/50 transition-colors relative cursor-pointer group
                                        ${selectedSlot === i ? 'border-yellow-400 shadow-[0_0_10px_rgba(253,224,71,0.5)]' : 'border-gray-600 hover:border-gray-400'}
                                    `}
                                                title={item.name}
                                            >
                                                <span className="absolute bottom-0.5 right-1 text-[8px] text-gray-500 group-hover:text-gray-300 font-bold">{i === 9 ? 0 : i + 1}</span>
                                                <div className="w-full h-full flex items-center justify-center p-1">
                                                    <img
                                                        src={item.imgSrc}
                                                        alt={item.name}
                                                        className="w-full h-full object-contain drop-shadow-md"
                                                        draggable="false"
                                                        onError={(e) => {
                                                            // 如果圖片讀取失敗，自動變回顯示色塊 (fallback)
                                                            e.target.style.display = 'none';
                                                            e.target.nextSibling.style.display = 'block';
                                                        }}
                                                    />
                                                    {/* 備用色塊 (預設隱藏，圖片掛掉時顯示) */}
                                                    <div
                                                        className="w-full h-full rounded-sm opacity-80 hidden"
                                                        style={{ backgroundColor: item.color }}
                                                    ></div>
                                                </div>
                                                <div className="absolute -top-8 left-1/2 -translate-x-1/2 bg-black text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 whitespace-nowrap pointer-events-none transition-opacity">
                                                    {item.name}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                    {/* ★★★ 新增：檢傷流程圖浮動視窗 (Modal) ★★★ */}
                    {showFlowchart && (
                        <div className="absolute inset-0 z-[200] bg-black flex items-center justify-center animate-fade-in" onClick={() => setShowFlowchart(false)}>
                            <div
                                className="relative bg-slate-900 w-full h-full flex flex-col items-center p-2"
                                onClick={e => e.stopPropagation()}
                            >
                                {/* 右上角關閉按鈕 X */}
                                <button
                                    className="absolute top-2 right-2 text-gray-400 hover:text-white text-xl font-bold p-2 w-10 h-10 flex items-center justify-center bg-black/20 rounded-full transition-colors"
                                    onClick={() => setShowFlowchart(false)}
                                >
                                    ✕
                                </button>

                                <h2 className="text-xl text-white font-bold mb-4 tracking-wider border-b border-gray-600 pb-2 w-full text-center">
                                    檢傷分類流程圖 / Triage Flowchart
                                </h2>

                                {/* 圖片顯示區 */}
                                <div className="flex-1 w-full flex items-center justify-center overflow-hidden bg-black/50 rounded mb-2 relative">
                                    {flowchartIndex === 0 ? (
                                        <div className="w-full h-full flex items-center justify-center">
                                            {/* ★★★ 預留程式碼插入位置 1：第一張圖片 ★★★ */}
                                            {/* 請將下方的 src 替換為您的圖片路徑，例如 "PIC/flowchart1.png" */}
                                            <img src="PIC/flowchart1.png" alt="流程圖 1" className="max-w-full max-h-full object-contain" />
                                        </div>
                                    ) : (
                                        <div className="w-full h-full flex items-center justify-center">
                                            {/* ★★★ 預留程式碼插入位置 2：第二張圖片 ★★★ */}
                                            {/* 請將下方的 src 替換為您的圖片路徑，例如 "PIC/flowchart2.png" */}
                                            <img src="PIC/flowchart2.png" alt="流程圖 2" className="max-w-full max-h-full object-contain" />
                                        </div>
                                    )}
                                </div>

                                {/* 底部切換箭頭 */}
                                <div className="flex gap-12 items-center pb-2">
                                    <button
                                        onClick={() => setFlowchartIndex(prev => (prev === 0 ? 1 : 0))}
                                        className="text-white/70 hover:text-yellow-400 text-5xl font-bold transition-all transform hover:scale-110 active:scale-95 select-none"
                                    >
                                        ←
                                    </button>

                                    {/* 頁碼圓點指示器 */}
                                    <div className="flex gap-3 items-center">
                                        <div className={`w-3 h-3 rounded-full transition-all ${flowchartIndex === 0 ? 'bg-yellow-400 scale-125' : 'bg-gray-600'}`}></div>
                                        <div className={`w-3 h-3 rounded-full transition-all ${flowchartIndex === 1 ? 'bg-yellow-400 scale-125' : 'bg-gray-600'}`}></div>
                                    </div>

                                    <button
                                        onClick={() => setFlowchartIndex(prev => (prev === 0 ? 1 : 0))}
                                        className="text-white/70 hover:text-yellow-400 text-5xl font-bold transition-all transform hover:scale-110 active:scale-95 select-none"
                                    >
                                        →
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    {/* ★★★ 手機版 UI 控制層 (新增) ★★★ */}
                    <div className="absolute inset-0 pointer-events-none z-[60]">
                        {/* 虛擬搖桿 (左下) */}
                        {/*<div
                                className="joystick-zone pointer-events-auto"
                                onTouchStart={handleJoystickTouchStart}
                                onTouchMove={handleJoystickTouchMove}
                                onTouchEnd={handleJoystickTouchEnd}
                                onTouchCancel={handleJoystickTouchEnd}
                            >
                                <div className="joystick-base">
                                    <div
                                        className="joystick-knob"
                                        style={{ transform: `translate(calc(-50% + ${joystickUI.x}px), calc(-50% + ${joystickUI.y}px))` }}
                                    ></div>
                                </div>
                            </div>
                            */}
                        {/* 互動按鈕 (Interact - E) - 右下 */}
                        {/*<div
                                className="mobile-btn btn-interact pointer-events-auto"
                                onTouchStart={(e) => { e.preventDefault(); triggerKey('e'); }}
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0" /><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2" /><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" /><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" /></svg>
                            </div>
                            */}
                        {/* 取消按鈕 (Cancel - C) - 右上 */}
                        {/*<div
                                className="mobile-btn btn-cancel pointer-events-auto"
                                onTouchStart={(e) => { e.preventDefault(); triggerCancel(); }}
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18" /><path d="m6 6 12 12" /></svg>
                            </div>

                            {/* 道具欄開關 (Inventory - I) - 中下 */}
                        {/* <div
                                className="mobile-btn btn-inventory pointer-events-auto"
                                onTouchStart={(e) => { e.preventDefault(); setShowInventory(prev => !prev); }}
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7" /><path d="M3 7l9-4 9 4" /><path d="M12 3v4" /></svg>
                            </div>
                            */}
                    </div>

                </div>



            );

        }




        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
    <!-- ★★★ PWA Service Worker 註冊腳本 ★★★ -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>
</body>

</html>
