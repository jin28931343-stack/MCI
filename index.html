<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>災害應變 - 國道連環車禍 (擴張場景版)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas {
            image-rendering: auto; 
        }
        ::-webkit-scrollbar {
            display: none;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        .animate-blink {
            animation: blink 1s infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef, useState } = React;

        const IconAlert = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>;
        const IconMapPin = () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></svg>;
        const IconActivity = () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>;

        function App() {
            const canvasRef = useRef(null);
            const [survivorCount, setSurvivorCount] = useState(0);
            const [selectedSlot, setSelectedSlot] = useState(0);
            const [gameOver, setGameOver] = useState(false);
            const [showMatSelector, setShowMatSelector] = useState(false);
            
            const [playerStatsUI, setPlayerStatsUI] = useState({
                hp: 100, maxHp: 100,
                mp: 80, maxMp: 100,
                sp: 100, maxSp: 100
            });
            
            const totalSurvivors = 12;

            const gameState = useRef({
                isGameOver: false,
                keys: { w: false, s: false, a: false, d: false },
                player: {
                    x: 300, y: 600, width: 30, height: 30, speed: 1.75, dir: 3, frame: 0, moving: false, animTimer: 0 
                },
                camera: { x: 0, y: 0 },
                stats: { hp: 100, maxHp: 100, mp: 80, maxMp: 100, sp: 100, maxSp: 100 },
                obstacles: [], 
                emergencyVehicles: [],
                npcGroups: [], 
                firefightingSquads: [], 
                staticNpcs: [], 
                decorations: [], 
                triageMats: [], 
                hazards: [],
                particles: [], 
                survivors: [],
                feedbacks: [], 
                firefightingSquads: [], 
                rescueSquads: [], // 新增: 破壞救援小組陣列
                staticNpcs: [], 
                interactionMenu: {
                    active: false, x: 0, y: 0, target: null, mode: 'main'
                },
                placementMode: {
                    active: false,
                    type: null, 
                    color: null,
                    w: 120, h: 80, 
                    valid: false,
                    x: 0, y: 0 
                },
                survivorsFoundCount: 0, 
                animationFrameId: null,
                frameCount: 0,
                npcSpawnTimer: 0
            });

            const items = [
                { name: "無線電",     color: "#34495e", type: "radio" },        // 1
                { name: "檢傷平板",   color: "#9b59b6", type: "tablet" },       // 2
                { name: "檢傷地墊",   color: "#27ae60", type: "mat" },          // 3
                { name: "指揮站",     color: "#ffffff", type: "command_post" }, // 4
                { name: "除汙站", color: "#95a5a6", type: "decon" },        // 5
                { name: "救護車待命區",     color: "#3498db", type: "ambulance_staging" }     // 6
            ];

            const handleSlotClick = (index) => {
                setSelectedSlot(index);
                const item = items[index];
                
                if (item.type === "mat") {
                    setShowMatSelector(true);
                } else if (['command_post', 'ambulance_staging', 'decon'].includes(item.type)) {
                    setShowMatSelector(false);
                    // 設定特殊區塊的放置模式
                    gameState.current.placementMode = {
                        active: true,
                        type: 'zone', 
                        color: item.type, // 使用 type 作為顏色鍵值
                        w: 160, h: 120,   // 設定比檢傷地墊稍大
                        valid: false,
                        x: 0, y: 0
                    };
                } else {
                    setShowMatSelector(false);
                    gameState.current.placementMode.active = false; 
                }
            };

            const handleSelectMatColor = (color) => {
                setShowMatSelector(false);
                gameState.current.placementMode = {
                    active: true,
                    type: 'triage_mat',
                    color: color, 
                    w:100 , h:100 , 
                    valid: false,
                    x: 0, y: 0
                };
            };

            const handleRestart = () => {
                setGameOver(false);
            };

            const generateSurvivorData = () => {
                const sex = Math.random() > 0.5 ? '男' : '女';
                const age = Math.floor(Math.random() * (70 - 12 + 1)) + 12;
                
                const severityRoll = Math.random();
                let severity = 'green';
                let consciousness = '清醒';
                let resp = '正常 (16/min)';
                let pulse = '強 (80/min)';
                let injuryText = '擦傷、驚嚇';
                let isBleeding = false; 

                if (severityRoll > 0.9) {
                    severity = 'black'; consciousness = '無意識'; resp = '無'; pulse = '無'; injuryText = '明顯死亡徵象';
                    isBleeding = false; 
                } else if (severityRoll > 0.6) {
                    severity = 'red'; consciousness = Math.random() > 0.5 ? '無意識' : '對痛有反應';
                    resp = Math.random() > 0.5 ? '淺快 (>30/min)' : '微弱 (<10/min)';
                    pulse = '微弱 (>120/min)'; injuryText = '大出血、氣胸';
                    isBleeding = Math.random() > 0.3; 
                } else if (severityRoll > 0.3) {
                    severity = 'yellow'; consciousness = '對聲音有反應'; resp = '正常'; pulse = '正常但快'; injuryText = '骨折、無法行走';
                    isBleeding = Math.random() > 0.8; 
                } else {
                    isBleeding = Math.random() > 0.95; 
                }

                const clothColor = `hsl(${Math.random() * 360}, 40%, 60%)`;
                return { sex, age, severity, consciousness, resp, pulse, injuryText, isBleeding, clothColor };
            };
            
            useEffect(() => {
                if (gameOver) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const state = gameState.current;
                
                const GAME_WIDTH = 960;
                const GAME_HEIGHT = 540;
                
                // --- 設定擴張 ---
                // 新增左側偏移量 (約 4 台消防車寬度 + 緩衝 = 700px)
                const LEFT_EXPANSION = 700;
                // 原本世界寬度 2000，加上擴張區域
                const WORLD_WIDTH = 2000 + LEFT_EXPANSION;
                const WORLD_HEIGHT = 1200;

                // --- 重置 ---
                state.isGameOver = false; 
                state.obstacles = [];
                state.emergencyVehicles = []; 
                state.npcGroups = []; 
                state.firefightingSquads = []; 
                state.staticNpcs = []; 
                state.decorations = [];
                state.triageMats = []; 
                state.hazards = []; 
                state.particles = [];
                state.survivors = [];
                state.feedbacks = [];
                state.survivorsFoundCount = 0;
                state.frameCount = 0;
                state.npcSpawnTimer = 0;
                state.stats = { hp: 100, maxHp: 100, mp: 80, maxMp: 100, sp: 100, maxSp: 100 };
                
                // 玩家起始位置也跟著向右移，保持相對位置
                state.player.x = 250 + LEFT_EXPANSION;
                state.player.y = WORLD_HEIGHT / 2 + 50; 
                
                // 攝影機初始位置可以設在擴張區邊緣，讓玩家看到空地
                state.camera = { x: LEFT_EXPANSION - 300, y: 0 }; // 稍微往左一點看
                if(state.camera.x < 0) state.camera.x = 0;

                state.interactionMenu = { active: false, x: 0, y: 0, target: null, mode: 'main' };
                state.placementMode.active = false; 
                setSurvivorCount(0);
                setPlayerStatsUI({...state.stats});
                setShowMatSelector(false); 

                const resize = () => {
                    if (!canvas) return;
                    let scale = Math.min(window.innerWidth / GAME_WIDTH, window.innerHeight / GAME_HEIGHT);
                    canvas.style.width = `${GAME_WIDTH * scale}px`;
                    canvas.style.height = `${GAME_HEIGHT * scale}px`;
                };
                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;
                window.addEventListener('resize', resize);
                resize();

                const PALETTE = {
                    asphalt: '#2d3436', markingWhite: '#b2bec3', markingYellow: '#f1c40f', oil: '#000000', glass: '#81ecec',
                    carColors: ['#e74c3c', '#3498db', '#ecf0f1', '#95a5a6', '#f39c12'],
                    playerVest: '#3498db', playerReflect: '#f1c40f'
                };
                const rand = (min, max) => Math.random() * (max - min) + min;

                const addFeedback = (x, y, text, color = "#fff") => {
                    state.feedbacks.push({ x: x, y: y - 20, text: text, color: color, life: 60, vy: -0.5 });
                };

                // --- 生成車輛與障礙物 (所有X座標都要加上 LEFT_EXPANSION) ---
                
                // 定義消防車位置 (加上偏移)
                const firetruckData = { type: 'firetruck', x: 50 + LEFT_EXPANSION, y: WORLD_HEIGHT/2 - 150, w: 140, h: 60, angle: 0.3 };
                
                // --- 計算消防車前後淨空區域 ---
                const ftClearanceLength = 420; 
                const ftClearanceZone = {
                    minX: firetruckData.x - ftClearanceLength,
                    maxX: firetruckData.x + firetruckData.w + ftClearanceLength,
                    minY: firetruckData.y - 50,
                    maxY: firetruckData.y + firetruckData.h + 50
                };

                state.emergencyVehicles.push(firetruckData); 
                state.emergencyVehicles.push({ type: 'ambulance', x: 80 + LEFT_EXPANSION, y: WORLD_HEIGHT/2 + 100, w: 100, h: 50, angle: -0.2 }); 
                state.emergencyVehicles.push({ type: 'police', x: 30 + LEFT_EXPANSION, y: WORLD_HEIGHT/2 + 200, w: 80, h: 40, angle: 0.1 }); 

                // 阻擋方塊 (加上偏移)
                state.obstacles.push({x: 50 + LEFT_EXPANSION, y: WORLD_HEIGHT/2 - 150, w: 140, h: 60, type: 'vehicle_block'});
                state.obstacles.push({x: 80 + LEFT_EXPANSION, y: WORLD_HEIGHT/2 + 100, w: 100, h: 50, type: 'vehicle_block'});
                state.obstacles.push({x: 30 + LEFT_EXPANSION, y: WORLD_HEIGHT/2 + 200, w: 80, h: 40, type: 'vehicle_block'});

                state.staticNpcs.push({ x: 100 + LEFT_EXPANSION, y: WORLD_HEIGHT/2 - 70, dir: 1 });
                state.staticNpcs.push({ x: 120 + LEFT_EXPANSION, y: WORLD_HEIGHT/2 - 70, dir: 1 });
                state.decorations.push({ type: 'stretcher', x: 110 + LEFT_EXPANSION, y: WORLD_HEIGHT/2 - 55, angle: 0 });

                // 隨機裝飾 (Skid, Oil, Glass) - 範圍從 LEFT_EXPANSION 開始，保持左側乾淨
                for(let i=0; i<30; i++) state.decorations.push({ type: 'skid', x: rand(LEFT_EXPANSION, WORLD_WIDTH), y: rand(50, WORLD_HEIGHT-50), w: rand(50, 150), h: rand(2, 4), angle: rand(-0.2, 0.2) });
                for(let i=0; i<30; i++) state.decorations.push({ type: 'oil', x: rand(LEFT_EXPANSION, WORLD_WIDTH), y: rand(50, WORLD_HEIGHT-50), r: rand(20, 45) });
                for(let i=0; i<150; i++) state.decorations.push({ type: 'glass', x: rand(LEFT_EXPANSION, WORLD_WIDTH), y: rand(0, WORLD_HEIGHT), size: rand(1, 3) });

                // 火焰生成 (範圍調整)
                for(let i=0; i<8; i++) {
                    // 從 300 + LEFT_EXPANSION 開始生成，確保離起始點有距離
                    let fx = rand(300 + LEFT_EXPANSION, WORLD_WIDTH-100);
                    let fy = rand(100, WORLD_HEIGHT-100);
                    
                    if (fx > ftClearanceZone.minX && fx < ftClearanceZone.maxX && fy > ftClearanceZone.minY && fy < ftClearanceZone.maxY) {
                        continue; 
                    }

                    state.hazards.push({ id: i, type: 'fire', x: fx, y: fy, r: rand(30, 60), beingExtinguished: false, life: 300 });
                }

                // 金屬碎片生成 (範圍調整)
                for(let i=0; i<20; i++) {
                    let mx = rand(100 + LEFT_EXPANSION, WORLD_WIDTH-100);
                    let my = rand(100, WORLD_HEIGHT-100);
                    
                    if (mx > ftClearanceZone.minX && mx < ftClearanceZone.maxX && my > ftClearanceZone.minY && my < ftClearanceZone.maxY) {
                        continue;
                    }
                    state.obstacles.push({ type: 'metal_debris', x: mx, y: my, w: rand(20, 40), h: rand(10, 20), angle: rand(0, Math.PI) });
                }

                // 邊界護欄 (更新寬度)
                state.obstacles.push({x: 0, y: 0, w: WORLD_WIDTH, h: 40, type: 'guardrail'});
                state.obstacles.push({x: 0, y: WORLD_HEIGHT-40, w: WORLD_WIDTH, h: 40, type: 'guardrail'});
                // 牆壁位置更新
                state.obstacles.push({x: -10, y: 0, w: 10, h: WORLD_HEIGHT, type: 'wall'});
                state.obstacles.push({x: WORLD_WIDTH, y: 0, w: 10, h: WORLD_HEIGHT, type: 'wall'});

                // 一般車輛生成 (範圍調整)
                for(let i=0; i<30; i++) { 
                    let type = Math.random() > 0.8 ? 'truck' : 'sedan';
                    // 生成範圍從 300 + LEFT_EXPANSION 開始
                    let x = rand(300 + LEFT_EXPANSION, WORLD_WIDTH - 100); 
                    let y = rand(50, WORLD_HEIGHT - 50); 
                    let rotated = Math.random() > 0.3;
                    let w = (type === 'sedan' ? (rotated?80:40) : (rotated?120:50));
                    let h = (type === 'sedan' ? (rotated?40:80) : (rotated?50:120));
                    
                    // 檢查消防車淨空區
                    if (x + w > ftClearanceZone.minX && x < ftClearanceZone.maxX && y + h > ftClearanceZone.minY && y < ftClearanceZone.maxY) {
                        continue; 
                    }

                    let overlap = state.obstacles.some(o => x < o.x + o.w + 10 && x + w + 10 > o.x && y < o.y + o.h + 10 && y + h + 10 > o.y);
                    if (!overlap) {
                        state.obstacles.push({
                            x, y, w, h, type, rotated,
                            color: type === 'truck' ? '#fff' : PALETTE.carColors[Math.floor(Math.random() * PALETTE.carColors.length)],
                            hitbox: { x: x+2, y: y+2, w: w-4, h: h-4 },
                            isBreached: false, breakTimer: 0
                        });
                    }
                }

                let cars = state.obstacles.filter(o => o.type !== 'guardrail' && o.type !== 'wall' && o.type !== 'vehicle_block' && o.type !== 'metal_debris');
                 for(let i=0; i<totalSurvivors; i++) {
                    let car = cars[Math.floor(Math.random() * cars.length)];
                    // 設定 30% 機率受困於車內 (需破壞)，70% 機率散落在外
                    let inCar = Math.random() > 0.7; 
                    
                    let sx, sy;
                    
                    if (inCar && car) {
                        // 【受困車內】：強制位置與車體重疊 (位於車輛中心)
                        sx = car.x + car.w/2; 
                        sy = car.y + car.h/2;
                    } else {
                        // 【非受困】：位置不能與車體重疊，但可以靠近
                        let validPosition = false;
                        let attempts = 0;
                        
                        // 嘗試尋找合法位置 (最多嘗試 50 次以防無窮迴圈)
                        while (!validPosition && attempts < 50) {
                            attempts++;
                            
                            // 決定生成區域
                            if (car && Math.random() > 0.4) {
                                // 策略 A: 在車輛「附近」生成 (範圍稍大，允許靠近)
                                sx = car.x + rand(-60, car.w + 60);
                                sy = car.y + rand(-60, car.h + 60);
                            } else {
                                // 策略 B: 全地圖隨機
                                sx = rand(300 + LEFT_EXPANSION, WORLD_WIDTH-100);
                                sy = rand(100, WORLD_HEIGHT-100);
                            }

                            // 1. 基礎邊界檢查
                            if (sx < 300 + LEFT_EXPANSION) sx = 300 + LEFT_EXPANSION;
                            if (sx > WORLD_WIDTH-20) sx = WORLD_WIDTH-20;
                            if (sy < 50) sy = 50; 
                            if (sy > WORLD_HEIGHT-50) sy = WORLD_HEIGHT-50;

                            // 2. 避開消防車作業淨空區
                            if (sx > ftClearanceZone.minX && sx < ftClearanceZone.maxX && sy > ftClearanceZone.minY && sy < ftClearanceZone.maxY) {
                                continue; 
                            }

                            // 3. 【關鍵修改】碰撞檢測：檢查是否與任何車體重疊
                            let isOverlapping = false;
                            for (let o of state.obstacles) {
                                // 只檢查實體車輛與車輛阻擋塊
                                if (o.type === 'sedan' || o.type === 'truck' || o.type === 'vehicle_block') {
                                    // 簡單矩形碰撞檢測
                                    // 為了視覺效果，我們保留一點點邊距 (margin)，避免傷患剛好「切」到車邊
                                    const margin = 5; 
                                    if (sx > o.x - margin && sx < o.x + o.w + margin &&
                                        sy > o.y - margin && sy < o.y + o.h + margin) {
                                        isOverlapping = true;
                                        break; // 發現重疊，跳出檢查
                                    }
                                }
                            }

                            // 如果沒有重疊，標記為合法位置
                            if (!isOverlapping) {
                                validPosition = true;
                            }
                        }

                        // 如果嘗試 50 次都失敗 (極少見)，則強制放置在左側安全空地
                        if (!validPosition) {
                            sx = LEFT_EXPANSION + rand(50, 150);
                            sy = WORLD_HEIGHT/2 + rand(-50, 50);
                            inCar = false; // 確保標記為非受困
                        }
                    }

                    // 生成傷患數據並加入陣列
                    const data = generateSurvivorData();
                    state.survivors.push({ 
                        x: sx, y: sy, found: false, triageTag: null, treatments: [], data: data,
                        tourniquetTimer: data.isBleeding ? 60 : null, isDead: false, isEvacuating: false, isBeingCarried: false, trappedInVehicle: inCar ? car : null 
                    });
                }
                // --- 新增：取消功能的共用邏輯 ---
                const cancelAction = () => {
                    let performed = false;
                    // 1. 取消放置模式
                    if (state.placementMode.active) {
                        state.placementMode.active = false;
                        setShowMatSelector(false); // 確保UI關閉
                        addFeedback(state.player.x, state.player.y - 50, "已取消設置", "#bdc3c7");
                        performed = true;
                    }
                    // 2. 關閉互動選單
                    if (state.interactionMenu.active) {
                        state.interactionMenu.active = false;
                        state.interactionMenu.target = null;
                        state.interactionMenu.mode = 'main';
                        // 避免重複顯示提示
                        if (!performed) addFeedback(state.player.x, state.player.y - 50, "已關閉選單", "#bdc3c7");
                    }
                };
                // --- 新增：滑鼠右鍵處理 (取消) ---
                const handleContextMenu = (e) => {
                    e.preventDefault(); // 阻止瀏覽器預設右鍵選單
                    if (state.isGameOver) return;
                    cancelAction();
                };
                const handleKeyDown = (e) => {
                    if (state.isGameOver) return; 
                    if(e.key === 'w' || e.key === 'ArrowUp') state.keys.w = true;
                    if(e.key === 's' || e.key === 'ArrowDown') state.keys.s = true;
                    if(e.key === 'a' || e.key === 'ArrowLeft') state.keys.a = true;
                    if(e.key === 'd' || e.key === 'ArrowRight') state.keys.d = true;
                    if (e.key >= '1' && e.key <= '9') handleSlotClick(parseInt(e.key) - 1);
                    else if (e.key === '0') handleSlotClick(9);
                    // --- 新增：C 鍵取消 ---
                    if (e.key === 'c' || e.key === 'C') {
                        cancelAction();}
                   // --- 新增：按下 E 鍵放置地墊 ---
                  if (e.key === 'e' || e.key === 'E') {
                   if (state.placementMode.active) {
                  if (state.placementMode.valid) {
                state.triageMats.push({
                    x: state.placementMode.x,
                    y: state.placementMode.y,
                    w: state.placementMode.w,
                    h: state.placementMode.h,
                    color: state.placementMode.color
                });
                addFeedback(state.placementMode.x + state.placementMode.w/2, state.placementMode.y, "地墊放置完成", "#fff");
                state.placementMode.active = false; 
                } else {
                // 若位置不合法，顯示提示 (使用玩家位置作為提示點)
                addFeedback(state.player.x, state.player.y - 50, "無法放置", "#e74c3c");
            }
        }
    } 
                };

                const handleKeyUp = (e) => {
                    if (state.isGameOver) return; 
                    if(e.key === 'w' || e.key === 'ArrowUp') state.keys.w = false;
                    if(e.key === 's' || e.key === 'ArrowDown') state.keys.s = false;
                    if(e.key === 'a' || e.key === 'ArrowLeft') state.keys.a = false;
                    if(e.key === 'd' || e.key === 'ArrowRight') state.keys.d = false;
                };

                const handleMouseMove = (e) => {
                    
                };

                const handleCanvasClick = (e) => {
                    if (state.isGameOver) return; 

                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const screenClickX = (e.clientX - rect.left) * scaleX;
                    const screenClickY = (e.clientY - rect.top) * scaleY;
                    const clickX = screenClickX + state.camera.x;
                    const clickY = screenClickY + state.camera.y;
                    const player = state.player;
                    const menu = state.interactionMenu;

                    if (state.placementMode.active) {
                        if (state.placementMode.valid) {
                            state.triageMats.push({
                                x: state.placementMode.x,
                                y: state.placementMode.y,
                                w: state.placementMode.w,
                                h: state.placementMode.h,
                                color: state.placementMode.color
                            });
                            addFeedback(state.placementMode.x + state.placementMode.w/2, state.placementMode.y, "地墊放置完成", "#fff");
                            state.placementMode.active = false; 
                        } else {
                            addFeedback(clickX, clickY, "無法放置於此", "#e74c3c");
                        }
                        return; 
                    }
                    
                    if (menu.active) {
                        const menuX = menu.x - 40; const menuY = menu.y - 60; 
                        
                        if (menu.mode === 'main') {
                            if (clickX >= menuX && clickX <= menuX + 40 && clickY >= menuY && clickY <= menuY + 40) {
                                menu.mode = 'triage'; return;
                            }
                            if (clickX >= menuX + 45 && clickX <= menuX + 85 && clickY >= menuY && clickY <= menuY + 40) {
                                menu.mode = 'treatment'; return;
                            }
                        } 
                        else if (menu.mode === 'triage') {
                            const colors = ['green', 'yellow', 'red', 'black'];
                           // 定義 2x2 按鈕參數
                            const btnW = 30;
                            const btnH = 30;
                            const gap = 5;
                            // 讓選單稍微往右移一點，避免遮擋
                            const startX = menuX -25; 
                            const startY = menuY -12;
                             
                            // --- 新增：檢查是否點擊了右側的「急救按鈕」 ---
                            // 位置與 Main 模式下的右側按鈕相同 (menuX + 45)
                            if (clickX >= menuX + 45 && clickX <= menuX + 85 && clickY >= menuY && clickY <= menuY + 40) {
                                menu.mode = 'treatment';
                                return;
                            }
                            for(let i=0; i<4; i++) {
                                // 計算 2x2 位置: 0,1第一列; 2,3第二列
                                let col = i % 2;
                                let row = Math.floor(i / 2);
                                
                                let btnX = startX + col * (btnW + gap);
                                let btnY = startY + row * (btnH + gap);

                                if (clickX >= btnX && clickX <= btnX + btnW && clickY >= btnY && clickY <= btnY + btnH) {
                                    if(menu.target) { 
                                       menu.target.triageTag = colors[i];
                                        menu.target.found = true;
                                        menu.target.hasArrived = false; // 新增：重置抵達狀態，讓傷患能再次被搬運或移動
                                         menu.target.isEvacuating = false; // 新增：重置移動狀態 (避免從綠卡轉紅卡時仍繼續自行移動) 
                                        state.survivorsFoundCount = state.survivors.filter(s=>s.found).length;
                                        setSurvivorCount(state.survivorsFoundCount);
                                        addFeedback(menu.x, menu.y, "檢傷完成", colors[i] === 'black' ? '#999' : colors[i]);
                                        
                                        // --- 修改開始：檢查實際傷情 ---
                                        if (colors[i] === 'green') {
                                            // 只有玩家判定為綠色 且 實際傷情(data.severity)也是綠色，才會移動
                                            if (menu.target.data.severity === 'green') {
                                                menu.target.isEvacuating = true;
                                                addFeedback(menu.x, menu.y - 20, "傷患自行移動中...", "#2ecc71");
                                            } else {
                                                // 玩家判斷為輕傷，但實際傷勢較重 -> 無法移動
                                                addFeedback(menu.x, menu.y - 20, "傷勢過重無法移動", "#e74c3c");
                                            }
                                        }
                                    }
                                    menu.active = false; menu.mode = 'main'; return;
                                }
                            }
                        }
                        else if (menu.mode === 'treatment') {
                            if (clickX >= menuX - 20 && clickX <= menuX + 100 && clickY >= menuY - 50 && clickY <= menuY + 25) {
                                if (menu.target && menu.target.data) {
                                    if (menu.target.data.isBleeding && !menu.target.isDead) { 
                                        menu.target.data.isBleeding = false; 
                                        menu.target.tourniquetTimer = null; 
                                        addFeedback(menu.x, menu.y, "止血成功", "#2ecc71");
                                    } else {
                                        addFeedback(menu.x, menu.y, "無需/無法止血", "#bdc3c7");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                            if (clickX >= menuX - 20 && clickX <= menuX + 100 && clickY >= menuY + 20 && clickY <= menuY + 5) {
                                if (menu.target && menu.target.data) {
                                    if (menu.target.data.resp === '無') {
                                        if (Math.random() > 0.5) {
                                            menu.target.data.resp = '恢復 (微弱)';
                                            menu.target.data.severity = 'red'; 
                                            menu.target.data.injuryText = '氣道阻塞解除';
                                            menu.target.triageTag = null; 
                                            addFeedback(menu.x, menu.y, "恢復呼吸!", "#2ecc71");
                                        } else {
                                            addFeedback(menu.x, menu.y, "無效 (仍無呼吸)", "#bdc3c7");
                                        }
                                    } else {
                                        addFeedback(menu.x, menu.y, "呼吸道暢通", "#3498db");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }
                        else if (menu.mode === 'hazard_fire') {
                            if (clickX >= menuX - 10 && clickX <= menuX + 90 && clickY >= menuY && clickY <= menuY + 40) {
                                if (!menu.target.beingExtinguished) {
                                    menu.target.beingExtinguished = true;
                                    state.firefightingSquads.push({
                                        x: 0, y: 600, target: menu.target, state: 'moving_to_fire'
                                    });
                                    addFeedback(menu.x, menu.y, "請求滅火支援...", "#3498db");
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }
                        else if (menu.mode === 'hazard_vehicle') {
                            if (clickX >= menuX - 10 && clickX <= menuX + 90 && clickY >= menuY && clickY <= menuY + 40) {
                                if (!menu.target.isBreached && menu.target.breakTimer === 0) {
                                    // 修改: 檢查是否已有小組，若無則派遣
                                    const alreadyDispatched = state.rescueSquads.some(s => s.target === menu.target);
                                    if (!alreadyDispatched) {
                                        state.rescueSquads.push({
                                            // 從消防車位置附近出發 (加上偏移量)
                                            x: 50 + 700, 
                                            y: 540/2 - 100, 
                                            target: menu.target,
                                            state: 'moving_to_vehicle'
                                        });
                                        addFeedback(menu.x, menu.y, "破壞器材小組出動!", "#e67e22");
                                    } else {
                                        addFeedback(menu.x, menu.y, "支援已在途中", "#f1c40f");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }
                        menu.active = false; menu.target = null; menu.mode = 'main'; return;
                    }

                    const interactRadius = 60;
                    let clickedSomething = false;

                    // 檢查火焰
                    if (!clickedSomething) {
                        for (let h of state.hazards) {
                            const dist = Math.hypot(clickX - h.x, clickY - h.y);
                            if (dist < h.r) {
                                clickedSomething = true;
                                const distToPlayer = Math.hypot(player.x - h.x, player.y - h.y);
                                if (distToPlayer < interactRadius + 50) {
                                    menu.active = true; menu.mode = 'hazard_fire';
                                    menu.x = h.x; menu.y = h.y; menu.target = h;
                                } else {
                                    addFeedback(h.x, h.y, "太遠了!", "#e74c3c");
                                }
                                return;
                            }
                        }
                    }

                    // 檢查車輛
                    if (!clickedSomething) {
                        for (let o of state.obstacles) {
                            if (o.type !== 'guardrail' && o.type !== 'wall' && o.type !== 'vehicle_block' && o.type !== 'metal_debris') {
                                if (clickX > o.x && clickX < o.x + o.w && clickY > o.y && clickY < o.y + o.h) {
                                    clickedSomething = true;
                                    const distToPlayer = Math.hypot(player.x - (o.x + o.w/2), player.y - (o.y + o.h/2));
                                    if (distToPlayer < interactRadius + 40) {
                                        const survivorInside = state.survivors.find(s => s.trappedInVehicle === o);
                                        if (!o.isBreached) {
                                            if (survivorInside) {
                                                menu.active = true; menu.mode = 'hazard_vehicle';
                                                menu.x = o.x + o.w/2; menu.y = o.y; menu.target = o;
                                            } else {
                                                addFeedback(o.x + o.w/2, o.y, "車內無人", "#bdc3c7");
                                            }
                                        } else {
                                            addFeedback(o.x + o.w/2, o.y, "車體已破壞", "#2ecc71");
                                        }
                                    } else {
                                        addFeedback(o.x + o.w/2, o.y, "靠近查看", "#e74c3c");
                                    }
                                    return;
                                }
                            }
                        }
                    }

                    // 檢查傷患
                    for (let s of state.survivors) {
                        const dist = Math.hypot(clickX - s.x, clickY - s.y);
                        if (dist < 25) {
                            clickedSomething = true;
                            let blockedByFire = state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30);
                            if (blockedByFire) { addFeedback(s.x, s.y, "前方有火!", "#e74c3c"); return; }
                            
                            if (s.trappedInVehicle && !s.trappedInVehicle.isBreached) { addFeedback(s.x, s.y, "受困車內!", "#e74c3c"); return; }

                            const distToPlayer = Math.hypot(player.x - s.x, player.y - s.y);
                            if (distToPlayer < interactRadius) {
                                menu.active = true; menu.mode = 'main';
                                menu.x = s.x; menu.y = s.y; menu.target = s;
                            } else {
                                addFeedback(s.x, s.y, "太遠了!", "#e74c3c");
                            }
                            return;
                        }
                    }
                    
                    if (!clickedSomething && !state.placementMode.active) {
                        addFeedback(clickX, clickY, "●", "rgba(255,255,255,0.5)");
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('contextmenu', handleContextMenu); // 新增：監聽右鍵
                window.addEventListener('mousemove', handleMouseMove); 

                const drawRect = (x, y, w, h, color) => { ctx.fillStyle = color; ctx.fillRect(x, y, w, h); };
                const drawCircle = (x, y, r, color) => { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); };
                
                const drawRoundedRect = (x, y, w, h, r, color) => { 
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                    ctx.lineTo(x + r, y + h);
                    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                    ctx.lineTo(x, y + r);
                    ctx.quadraticCurveTo(x, y, x + r, y);
                    ctx.closePath();
                    ctx.fillStyle = color; 
                    ctx.fill(); 
                };

                const drawFirefighterHighRes = (x, y, angle, color = '#1a253a', frame = 0, moving = false) => {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5;
                    const walkCycle = moving ? Math.sin(frame * 0.2) : 0;
                    const leftLegOffset = walkCycle * 3;
                    const rightLegOffset = -walkCycle * 3;
                    ctx.fillStyle = '#1a253a';
                    ctx.beginPath(); 
                    drawRoundedRect(-8, -5 + leftLegOffset, 6, 12, 3, '#1a253a');
                    drawRoundedRect(2, -5 + rightLegOffset, 6, 12, 3, '#1a253a');
                    
                    const jacketGrad = ctx.createLinearGradient(-10, -10, 10, 10);
                    jacketGrad.addColorStop(0, '#1a253a'); jacketGrad.addColorStop(1, '#2c3e50');
                    ctx.fillStyle = jacketGrad;
                    ctx.beginPath();
                    ctx.moveTo(-11, -8); ctx.lineTo(11, -8); ctx.lineTo(10, 8); ctx.lineTo(-10, 8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 2; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(-8, -6); ctx.lineTo(8, 6); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(8, -6); ctx.lineTo(-8, 6); ctx.stroke();
                    
                    drawRoundedRect(-4, -4, 8, 12, 3, '#f39c12'); ctx.strokeStyle='#333'; ctx.lineWidth=1; ctx.stroke();
                    
                    const helmetGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, 10);
                    helmetGrad.addColorStop(0, '#e74c3c'); helmetGrad.addColorStop(1, '#c0392b');
                    ctx.fillStyle = helmetGrad;
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#922b21'; ctx.beginPath(); ctx.arc(0, 2, 8, 0, Math.PI, false); ctx.fill();
                    ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(0, 8); ctx.stroke();
                    ctx.fillStyle = '#1a253a'; ctx.beginPath(); ctx.arc(-11, -2, 4, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(11, -2, 4, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#95a5a6'; ctx.beginPath(); ctx.arc(-11, 4 + leftLegOffset*0.5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(11, 4 + rightLegOffset*0.5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                };

                const drawSurvivorHighRes = (s) => {
                    if (s.trappedInVehicle && !s.trappedInVehicle.isBreached) return;
                    ctx.save();
                    ctx.translate(s.x, s.y);
                    ctx.fillStyle = s.data.clothColor; ctx.beginPath(); ctx.ellipse(0, 6, 9, 16, 0, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#f5cba7'; ctx.beginPath(); ctx.arc(0, -6, 3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#f5cba7'; ctx.beginPath(); ctx.arc(0, -10, 7, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#3e2723'; ctx.beginPath(); ctx.arc(0, -12, 7, Math.PI, 0, true); ctx.fill();
                    ctx.strokeStyle = s.data.clothColor; ctx.lineWidth = 4; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(-8, 0); ctx.quadraticCurveTo(-14, 2, -12, 10); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(8, 0); ctx.quadraticCurveTo(14, 2, 12, 10); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-4, 18); ctx.lineTo(-6, 28); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(4, 18); ctx.lineTo(6, 28); ctx.stroke();
                    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.arc(2, -10, 1, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(-2, -10, 1, 0, Math.PI*2); ctx.fill();
                    if (s.triageTag) {
                        ctx.strokeStyle = { 'green': '#2ecc71', 'yellow': '#f1c40f', 'red': '#e74c3c', 'black': '#2d3436' }[s.triageTag];
                        ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 2, 22, 0, Math.PI*2); ctx.stroke();
                    }
                    if (s.isDead) {
                        ctx.fillStyle = 'rgba(230,230,230,0.9)'; 
                        ctx.beginPath(); ctx.ellipse(0, 8, 12, 26, 0, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 1; ctx.stroke();
                    }
                    ctx.restore();
                };

                const drawEmergencyVehicle = (v) => {
                    ctx.save(); ctx.translate(v.x + v.w/2, v.y + v.h/2); ctx.rotate(v.angle);
                    ctx.shadowColor = 'rgba(0,0,0,0.4)'; ctx.shadowBlur = 10;
                    if (v.type === 'firetruck') {
                        drawRoundedRect(-v.w/2, -v.h/2, v.w, v.h, 6, '#c0392b');
                        ctx.fillStyle = '#e74c3c'; ctx.fillRect(-v.w/2 + 5, -v.h/2 + 5, v.w - 10, v.h - 10);
                        ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.rect(-v.w/2 + 10, -5, v.w - 20, 10); ctx.fill();
                        for(let x = -v.w/2 + 15; x < v.w/2 - 10; x += 10) { ctx.clearRect(x, -3, 2, 6); }
                    } else if (v.type === 'ambulance') {
                        drawRoundedRect(-v.w/2, -v.h/2, v.w, v.h, 6, '#ecf0f1');
                        ctx.fillStyle = '#34495e'; ctx.beginPath(); 
                        ctx.fillRect(-v.w/2 + 5, -v.h/2 + 5, 20, v.h - 10); 
                        ctx.fillStyle = '#e74c3c'; ctx.fillRect(-20, -5, 25, 10); ctx.fillRect(-12.5, -12.5, 10, 25);
                    } else if (v.type === 'police') {
                        drawRoundedRect(-v.w/2, -v.h/2, v.w, v.h, 6, '#2c3e50'); 
                        ctx.fillStyle = '#ecf0f1'; ctx.fillRect(-v.w/2 + 25, -v.h/2, 35, v.h); 
                        ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-5, -v.h/2 + 2, 10, v.h - 4);
                    }
                    ctx.shadowBlur = 20;
                    if (Math.floor(Date.now() / 200) % 2 === 0) {
                        ctx.shadowColor = 'red'; ctx.fillStyle = 'rgba(255, 0, 0, 0.9)'; ctx.beginPath(); ctx.arc(-10, 0, 6, 0, Math.PI*2); ctx.fill();
                        ctx.shadowColor = 'blue'; ctx.fillStyle = 'rgba(0, 0, 255, 0.9)'; ctx.beginPath(); ctx.arc(10, 0, 6, 0, Math.PI*2); ctx.fill();
                    } else {
                        ctx.shadowColor = 'blue'; ctx.fillStyle = 'rgba(0, 0, 255, 0.9)'; ctx.beginPath(); ctx.arc(-10, 0, 6, 0, Math.PI*2); ctx.fill();
                        ctx.shadowColor = 'red'; ctx.fillStyle = 'rgba(255, 0, 0, 0.9)'; ctx.beginPath(); ctx.arc(10, 0, 6, 0, Math.PI*2); ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                    ctx.restore();
                };

                const drawFire = (hazard) => {
                    const flicker = Math.random() * 10;
                    const r = hazard.r + flicker;
                    const gradient = ctx.createRadialGradient(hazard.x, hazard.y, r * 0.2, hazard.x, hazard.y, r * 2);
                    gradient.addColorStop(0, 'rgba(255, 100, 0, 0.4)'); gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(hazard.x, hazard.y, r * 2, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = `rgba(255, ${150 + Math.random()*100}, 0, 0.8)`; ctx.beginPath(); ctx.arc(hazard.x + (Math.random()-0.5)*10, hazard.y + (Math.random()-0.5)*10, r * 0.5, 0, Math.PI*2); ctx.fill();
                };

                const drawMenu = (menu) => {
                    if (!menu.active) return;
                    const mx = menu.x - 40; const my = menu.y - 60; 
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
                    // 修改: 若是治療選單，縮短連線以配合向上移動的選單
                    let lineBottom = my + 45;
                    if (menu.mode === 'treatment') lineBottom = my + 15;

                    ctx.beginPath(); ctx.moveTo(menu.x, menu.y - 10); ctx.lineTo(menu.x, lineBottom); ctx.stroke();

                    if (menu.mode === 'main') {
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx, my, 40, 40); ctx.strokeStyle = '#fff'; ctx.strokeRect(mx, my, 40, 40);
                        // 修改: 繪製四張重疊的檢傷卡片 (綠黃紅黑)
    // 依照圖片順序：綠 -> 黃 -> 紅 -> 黑 (由後往前堆疊)
    const cards = ['green', 'yellow', 'red', 'black'];
    const stripColors = { 'green': '#00b894', 'yellow': '#f39c12', 'red': '#e74c3c', 'black': '#2d3436' };
    
    cards.forEach((c, i) => {
        // 計算堆疊位置 (每張向右偏移 6px)
        // 起始 X 設為 mx + 5，讓四張卡片整體居中於 40px 的按鈕內
        let cx = mx + 5 + (i * 6); 
        let cy = my + 8; // 垂直位置
        const w = 14;    // 卡片寬度 (稍微縮小以容納四張)
        const h = 20;    // 卡片高度

        // 1. 把手 (頂部突起)
        ctx.fillStyle = '#2d3436'; ctx.fillRect(cx + 5, cy - 3, 4, 3);
        
        // 2. 外框 (深色背景)
        ctx.fillStyle = '#2d3436'; ctx.fillRect(cx, cy, w, h);
        
        // 3. 本體 (米色)
        ctx.fillStyle = '#fff8e1'; ctx.fillRect(cx + 1, cy + 1, w - 2, h - 2);
        
        // 4. 顏色條 (底部色帶)
        ctx.fillStyle = stripColors[c]; ctx.fillRect(cx + 1, cy + h - 4, w - 2, 3);
        
        // 5. 表情 (簡化版像素點)
        ctx.fillStyle = '#2d3436'; 
        ctx.fillRect(cx + 3, cy + 5, 2, 2); // 左眼
        ctx.fillRect(cx + 9, cy + 5, 2, 2); // 右眼
        ctx.fillRect(cx + 5, cy + 10, 4, 1); // 嘴巴
    });
    // --- 右側按鈕 (醫療) ---
    ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx + 45, my, 40, 40); ctx.strokeStyle = '#fff'; ctx.strokeRect(mx + 45, my, 40, 40);
    ctx.fillStyle = '#2ecc71'; ctx.fillRect(mx + 62, my + 10, 6, 20); ctx.fillRect(mx + 55, my + 17, 20, 6);
                    } else if (menu.mode === 'triage') {
                        // --- 修改開始: 替換為圖片風格的圖示 ---
    const colors = ['green', 'yellow', 'red', 'black'];
                        const btnW = 30;
                        const btnH = 30;
                        const gap = 5;
                        // 往左移以騰出空間
                        const startX = mx - 25; 
                        const startY = my - 12; // 垂直置中
    // 背景稍微加高以容納新圖示
    // 繪製背景 (調整為方形以容納 2x2)
    ctx.fillStyle = 'rgba(0,0,0,0.85)'; 
    ctx.fillRect(startX - 5, startY - 5, (btnW * 2) + gap + 10, (btnH * 2) + gap + 10);
    ctx.strokeStyle = '#555';
    ctx.strokeRect(startX - 5, startY - 5, (btnW * 2) + gap + 10, (btnH * 2) + gap + 10);
    colors.forEach((c, i) => {
          let col = i % 2;
                            let row = Math.floor(i / 2);
                            
                            let bx = startX + col * (btnW + gap);
                            let by = startY + row * (btnH + gap);
                            
                            // 繪製按鈕底色
                            const stripColors = { 'green': '#00b894', 'yellow': '#f39c12', 'red': '#e74c3c', 'black': '#2d3436' };
                            
                            // 外框
                            ctx.fillStyle = '#2d3436';
                            ctx.fillRect(bx, by, btnW, btnH);
                            
                            // 內部 (米色)
                            ctx.fillStyle = '#fff8e1';
                            ctx.fillRect(bx + 2, by + 2, btnW - 4, btnH - 4);
                            
                            // 顏色標籤 (佔據下半部較大區域)
                            ctx.fillStyle = stripColors[c];
                            ctx.fillRect(bx + 2, by + btnH - 8, btnW - 4, 6);

                            // 表情 (眼睛)
                            ctx.fillStyle = '#2d3436';
                            ctx.fillRect(bx + 8, by + 10, 3, 3);  // 左眼
                            ctx.fillRect(bx + 19, by + 10, 3, 3); // 右眼
                            
                            // 嘴巴 (根據顏色做點變化)
                            if (c === 'green') { // 笑臉
                                ctx.fillRect(bx + 10, by + 18, 2, 2);
                                ctx.fillRect(bx + 18, by + 18, 2, 2);
                                ctx.fillRect(bx + 12, by + 20, 6, 2);
                            } else if (c === 'black') { // X嘴
                                ctx.beginPath(); ctx.moveTo(bx+12, by+18); ctx.lineTo(bx+18, by+22); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(bx+18, by+18); ctx.lineTo(bx+12, by+22); ctx.stroke();
                            } else { // 平嘴
                                ctx.fillRect(bx + 12, by + 19, 6, 2);
                            }
                        });
                    
                     // --- 新增：繪製右側常駐的「醫療按鈕」 ---
                        // (複製自 Main Mode)
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx + 45, my, 40, 40); ctx.strokeStyle = '#fff'; ctx.strokeRect(mx + 45, my, 40, 40);
                        ctx.fillStyle = '#2ecc71'; ctx.fillRect(mx + 62, my + 10, 6, 20); ctx.fillRect(mx + 55, my + 17, 20, 6);

                    } else if (menu.mode === 'treatment') {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(mx - 25, my - 15, 130, 70);
                        ctx.fillStyle = '#e74c3c'; ctx.fillRect(mx - 20, my - 10, 120, 25);
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("使用止血帶", mx - 10, my + 7);
                        ctx.fillStyle = '#3498db'; ctx.fillRect(mx - 20, my + 20, 120, 25);
                        ctx.fillStyle = 'white'; ctx.fillText("暢通呼吸道", mx - 10, my + 37);
                    } else if (menu.mode === 'hazard_fire') {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(mx - 10, my, 100, 40);
                        ctx.fillStyle = '#3498db'; ctx.fillRect(mx - 5, my + 5, 90, 30);
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("請求滅火", mx + 15, my + 25);
                    } else if (menu.mode === 'hazard_vehicle') {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(mx - 10, my, 100, 40);
                        ctx.fillStyle = '#e67e22'; ctx.fillRect(mx - 5, my + 5, 90, 30);
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("破壞車體", mx + 15, my + 25);
                    }
                };

                const drawSurvivorInfo = (player) => {
                    const interactRadius = 60;
                    // --- 修改開始：定義左側區域邊界 ---
                    // 消防車位置約在 750 (50 + 700)，設定 950 為界線，涵蓋左側與消防車周邊
                    const safeZoneBoundary = 950; 
                    state.survivors.forEach(s => {
                        // 判斷該傷患是否為當前選單的目標
                        const isMenuTarget = state.interactionMenu.active && state.interactionMenu.target === s;
                        const distToPlayer = Math.hypot(player.x - s.x, player.y - s.y);
                         // --- 修改顯示邏輯 ---
                        // 1. 檢查是否在左側安全區域 (inSafeZone)
                        const inSafeZone = s.x < safeZoneBoundary;

                        // 2. 顯示條件：
                        //    (A) 是當前點擊的目標 (isMenuTarget) -> 絕對顯示
                        //    (B) 距離夠近 + 有檢傷卡 + "不在"安全區域 -> 自動顯示
                        const showInfo = isMenuTarget || (distToPlayer < interactRadius && s.triageTag && !inSafeZone);
                        if (showInfo && !s.isBeingCarried && !s.isEvacuating) { 
                            // 定義資訊欄尺寸
                            const w = 140; 
                            const h = 130; 
                    
                            // 基礎間距
                            let gap = 20;
                             // --- 修改開始: 動態計算避讓偏移量 ---
                            let leftOffset = 40;  // 預設向左偏移 (資訊欄在左時，距離 s.x 的距離)
                            let rightOffset = 20; // 預設向右偏移 (資訊欄在右時，距離 s.x 的距離)
                            // 如果選單開啟中，加大間距以避開選單 (選單寬度約 130px 左右，設 85 安全)
                            if (isMenuTarget) {
                                const mode = state.interactionMenu.mode;
                                // 根據選單模式的寬度設定邊界，確保不重疊
                                if (mode === 'triage') {
                                    // 檢傷模式 (2x2 Grid)
                                    // 左邊界約為 -65 (s.x - 65)，我們設 75 留緩衝
                                    // 右邊界約為 +15 (s.x + 15)，我們設 25 留緩衝
                                    leftOffset = 75; 
                                    rightOffset = 25; 
                                } else if (mode === 'treatment') {
                                    // 治療模式 (寬條狀)
                                    // 左右邊界較寬 (-65 ~ +65)
                                    leftOffset = 75;
                                    rightOffset = 75;
                                } else {
                                    // 主選單 (Main)
                                    // 左邊界 -40, 右邊界 +85 (含右側醫療按鈕)
                                    leftOffset = 50;
                                    rightOffset = 90;
                                }
                            }
                            
                            // --- 修改開始: 判斷顯示位置 ---
                            let infoX;
                            // 如果傷患在玩家的左邊 (s.x < player.x)，資訊欄顯示在傷患右邊
                            if (s.x < player.x) {
                                infoX = s.x + rightOffset; 
                            } else {
                                // 如果傷患在玩家的右邊 (s.x > player.x)，資訊欄顯示在傷患左邊
                                // 減去寬度 (w) 和偏移量 (20)
                                infoX = s.x - leftOffset - w;  
                            }
                            // Y 軸維持原樣 (顯示在上方)
                            const infoY = s.y - 40; 
                            drawRoundedRect(infoX, infoY, w, h, 5, 'rgba(0, 0, 0, 0.8)');
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(infoX, infoY, w, h);
                            ctx.font = '10px "Segoe UI"'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                            
                            const d = s.data;
                            let yOffset = infoY + 8; const lineHeight = 16;
                            ctx.fillStyle = '#ecf0f1';
                            ctx.fillText(`性別: ${d.sex}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`年齡: ${d.age} 歲`, infoX + 8, yOffset); yOffset += lineHeight;
                            
                            let severityColor = '#ecf0f1';
                            if (d.severity === 'red' || d.severity === 'black') severityColor = '#e74c3c';
                            if (d.severity === 'yellow') severityColor = '#f1c40f';
                            if (d.severity === 'green') severityColor = '#2ecc71';
                            ctx.fillStyle = severityColor;
                            ctx.fillText(`傷情: ${d.injuryText}`, infoX + 8, yOffset); yOffset += lineHeight;
                            
                            ctx.fillStyle = '#ecf0f1';
                            ctx.fillText(`呼吸: ${d.resp}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`脈搏: ${d.pulse}`, infoX + 8, yOffset); yOffset += lineHeight;
                            if (d.consciousness === '無意識' || d.consciousness === '混亂') ctx.fillStyle = '#e74c3c';
                            else ctx.fillStyle = '#ecf0f1';
                            ctx.fillText(`意識: ${d.consciousness}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillStyle = d.isBleeding ? '#e74c3c' : '#2ecc71';
                            ctx.fillText(`大出血: ${d.isBleeding ? '是' : '否'}`, infoX + 8, yOffset);
                        }
                    });
                };

                const drawNPCGroups = (groups) => {
                    groups.forEach(group => {
                        drawFirefighterHighRes(group.followerX, group.followerY, 0, '#1a253a', state.frameCount, true);
                        drawFirefighterHighRes(group.leaderX, group.leaderY, 0, '#1a253a', state.frameCount, true);
                        ctx.save();
                        ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 6; ctx.lineCap = 'round';
                        ctx.beginPath(); ctx.moveTo(group.followerX, group.followerY - 5); ctx.lineTo(group.leaderX, group.leaderY - 5); ctx.stroke();
                        ctx.restore();
                        if (group.carrying && group.target) {
                            const midX = (group.leaderX + group.followerX) / 2;
                            const midY = (group.leaderY + group.followerY) / 2 - 5;
                            drawRoundedRect(midX - 5, midY - 12, 10, 24, 3, group.target.data.clothColor);
                            drawCircle(midX, midY - 15, 6, '#f5cba7');
                        }
                    });
                };

                const drawFirefighters = (squads) => {
                    squads.forEach(s => {
                        drawFirefighterHighRes(s.x, s.y, 0, '#e67e22', state.frameCount, s.state === 'moving_to_fire');
                        drawFirefighterHighRes(s.x - 20, s.y + 10, 0, '#e67e22', state.frameCount, s.state === 'moving_to_fire');
                        if (s.state === 'extinguishing') {
                            ctx.strokeStyle = 'rgba(52, 152, 219, 0.7)'; ctx.lineWidth = 4;
                            ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.target.x, s.target.y); ctx.stroke();
                        }
                    });
                };
                 // 新增: 繪製破壞小組 (含破壞剪動畫)
                const drawRescueSquads = (squads) => {
                    squads.forEach(s => {
                        // 1. 主操作手
                        drawFirefighterHighRes(s.x, s.y, 0, '#e67e22', state.frameCount, s.state !== 'breaking');
                        
                        // 2. 副手 (稍微跟在後面)
                        drawFirefighterHighRes(s.x - 20, s.y + 15, 0, '#e67e22', state.frameCount, s.state !== 'breaking');

                        // 3. 繪製破壞器材 (僅在破壞狀態時顯示作動)
                        if (s.state === 'breaking') {
                            ctx.save();
                            // 將座標原點移到主操作手前方
                            ctx.translate(s.x + 10, s.y);
                            
                            // 計算目標車輛方向
                            const angle = Math.atan2(s.target.y - s.y, s.target.x - s.x);
                            ctx.rotate(angle);

                            // 模擬油壓剪開合動作
                            const bite = Math.sin(state.frameCount * 0.5) * 0.5; // 開合幅度
                            
                            // 器材機身 (深灰色)
                            ctx.fillStyle = '#555'; 
                            ctx.fillRect(0, -4, 25, 8);
                            // 把手
                            ctx.fillStyle = '#222';
                            ctx.fillRect(5, -8, 4, 16);

                            // 剪刀頭 (橘色) - 上顎
                            ctx.save();
                            ctx.translate(25, -2);
                            ctx.rotate(-0.5 + bite); // 基礎角度 + 動態
                            ctx.fillStyle = '#d35400';
                            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(15, -4); ctx.lineTo(12, 4); ctx.fill();
                            ctx.restore();

                            // 剪刀頭 (橘色) - 下顎
                            ctx.save();
                            ctx.translate(25, 2);
                            ctx.rotate(0.5 - bite);
                            ctx.fillStyle = '#d35400';
                            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(15, 4); ctx.lineTo(12, -4); ctx.fill();
                            ctx.restore();

                            // 破壞火花特效
                            if (Math.random() > 0.7) {
                                ctx.fillStyle = '#f1c40f';
                                ctx.fillRect(38 + Math.random()*10, (Math.random()-0.5)*10, 2, 2);
                            }
                            ctx.restore();
                        }
                    });
                };
                const drawStaticNpcs = (npcs) => {
                    npcs.forEach(npc => { drawFirefighterHighRes(npc.x, npc.y, 0, '#1a253a', state.frameCount, false); });
                    state.decorations.forEach(d => {
                        if (d.type === 'stretcher') {
                            ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 6;
                            ctx.beginPath(); ctx.moveTo(d.x - 10, d.y); ctx.lineTo(d.x + 10, d.y); ctx.stroke();
                        }
                    });
                };

             
                const drawTriageMats = (mats) => {
                    mats.forEach(m => {
                        ctx.save();
                        const colors = { 'green': 'rgba(46, 204, 113, 0.4)', 'yellow': 'rgba(241, 196, 15, 0.4)', 'red': 'rgba(231, 76, 60, 0.4)', 'black': 'rgba(44, 62, 80, 0.6)','command_post': 'rgba(255, 255, 255, 0.4)',    
                        'ambulance_staging': 'rgba(52, 152, 219, 0.4)','decon': 'rgba(149, 165, 166, 0.4)'};
                        ctx.fillStyle = colors[m.color]||'rgba(255,255,255,0.2)';
                        ctx.fillRect(m.x, m.y, m.w, m.h);
                        const borderColors = { 'green': '#2ecc71', 'yellow': '#f1c40f', 'red': '#e74c3c', 'black': '#2c3e50' };
                        ctx.strokeStyle = borderColors[m.color] || '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(m.x, m.y, m.w, m.h);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        const labels = { 'green': '輕傷區', 'yellow': '中傷區', 'red': '重傷區', 'black': '臨時停屍間','command_post': '指揮站', 'ambulance_staging': '救護車待命區', 'decon': '除汙區' };
                        ctx.fillText(labels[m.color], m.x + m.w/2, m.y + m.h/2);
                        ctx.restore();
                    });
                };

                const drawPlacementPreview = (mode) => {
                    if (!mode.active) return;
                    
                    const p = state.player; // 取得玩家參考

                    ctx.save();
                   

                    // --- 計算跟隨玩家頭上的座標 ---
                    // 不再使用 mode.x/mode.y (地墊座標)，而是直接鎖定玩家座標 (p.x, p.y)
                    const cx = p.x;
                    const cy = p.y - 50; // 基礎高度 (角色頭頂上方)

                    // --- 1. 箭頭 (指向角色頭頂) ---
                    const bounce = Math.sin(state.frameCount * 0.2) * 5; // 上下浮動動畫
                    const arrowY = cy + bounce; 

                    ctx.fillStyle = '#f1c40f'; 
                    ctx.beginPath();
                    ctx.moveTo(cx - 10, arrowY - 15); // 左上
                    ctx.lineTo(cx + 10, arrowY - 15); // 右上
                    ctx.lineTo(cx, arrowY);           // 下尖端 (指向角色)
                    ctx.closePath();
                    
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
                    ctx.fill();
                    ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.stroke();
                    ctx.shadowBlur = 0;

                    // --- 2. 文字設定 ---
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = 'rgba(0,0,0,0.8)'; // 文字黑邊

                    // --- 3. 操作提示 "按 [E]..." (在箭頭上方) ---
                    const promptText = "按 [E] 設置 或 [點擊左鍵]";
                    const promptY = arrowY - 20;

                    ctx.font = 'bold 14px "Segoe UI"';
                    ctx.strokeText(promptText, cx, promptY);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(promptText, cx, promptY);

                    // --- 4. 區域名稱 (如：輕傷區) (在操作提示上方) ---
                    const labels = { 
                        'green': '輕傷區', 'yellow': '中傷區', 'red': '重傷區', 'black': '臨時停屍間',
                        'command_post': '指揮站', 'ambulance_staging': '救護車待命區', 'decon': '除汙區'
                    };
                    const labelText = labels[mode.color] || '';
                    const labelY = promptY - 20; 

                    // 根據區域類型設定文字顏色
                    const labelColors = {
                        'green': '#2ecc71', 'yellow': '#f1c40f', 'red': '#e74c3c', 'black': '#bdc3c7',
                        'command_post': '#ffffff', 'ambulance_staging': '#3498db', 'decon': '#95a5a6'
                    };

                    ctx.font = 'bold 18px "Segoe UI"'; // 標題字大一點
                    ctx.strokeText(labelText, cx, labelY);
                    ctx.fillStyle = labelColors[mode.color] || '#fff';
                    ctx.fillText(labelText, cx, labelY);

                    ctx.restore();
                };

                const update = () => {
                    const p = state.player;
                    state.frameCount++;
                 // --- 新增：計算目的地 (地墊中心隨機點 或 消防車後方) ---
                    const getTriageDest = (tag) => {
                        const mat = state.triageMats.find(m => m.color === tag);
                        if (mat) {
                            // 若有對應顏色的地墊，回傳地墊範圍內的隨機點
                            return {
                                x: mat.x + 10 + Math.random() * (mat.w - 20),
                                y: mat.y + 10 + Math.random() * (mat.h - 20)
                            };
                        }
                        // 若無設置地墊，預設前往消防車後方待命 (消防車 X 約在 50 + LEFT_EXPANSION)
                        return {
                            x: (50 + LEFT_EXPANSION) - 80 + Math.random() * 40, 
                            y: WORLD_HEIGHT/2 - 50 + Math.random() * 100
                        };
                    };
             
                    // --- 新增：地墊位置自動更新 (顯示在角色前方) ---
    if (state.placementMode.active) {
        const pm = state.placementMode;
       

        let targetX = p.x;
        let targetY = p.y;
        
       targetX = p.x;
        targetY = p.y; 

        // 更新地墊座標 (置中)
        pm.x = targetX - pm.w / 2;
        pm.y = targetY - pm.h / 2;

        // 驗證位置是否合法 (檢查障礙物、其他地墊、傷患)
        let valid = true;
        // 0. 【新增】檢查是否在安全區域 (消防車左側)
                        // 消防車 X = 50 + LEFT_EXPANSION，我們以此作為邊界
                        const safeZoneLimit = 50 + LEFT_EXPANSION;
                        if (pm.x + pm.w > safeZoneLimit) {
                            valid = false;
                        }
        // 1. 檢查障礙物
        for (let o of state.obstacles) {
            if (pm.x < o.x + o.w && pm.x + pm.w > o.x && pm.y < o.y + o.h && pm.y + pm.h > o.y) {
                valid = false; break;
            }
        }
        // 2. 檢查重疊地墊
        if (valid) {
            for (let m of state.triageMats) {
                if (pm.x < m.x + m.w && pm.x + pm.w > m.x && pm.y < m.y + m.h && pm.y + pm.h > m.y) {
                    valid = false; break;
                }
            }
        }
        // 3. 檢查是否壓到傷患
        if (valid) {
                for (let s of state.survivors) {
                if (Math.hypot(pm.x + pm.w/2 - s.x, pm.y + pm.h/2 - s.y) < 20) {
                    valid = false; break;
                }
            }
        }
        pm.valid = valid;
    }
                    p.moving = false;
                    let nextX = p.x;
                    let nextY = p.y;
                    
                    if (state.stats.hp <= 0) {
                        state.isGameOver = true; 
                        setGameOver(true);
                        return;
                    }

                    if (state.interactionMenu.active && state.interactionMenu.target) {
                        const target = state.interactionMenu.target;
                        let targetX = target.x;
                        let targetY = target.y;
                        if (target.w) { targetX += target.w / 2; targetY += target.h / 2; }
                        const dist = Math.hypot(p.x - targetX, p.y - targetY);
                        if (dist > 80) { 
                            state.interactionMenu.active = false;
                            state.interactionMenu.target = null;
                            state.interactionMenu.mode = 'main'; 
                        }
                    }

                    for (let i = state.firefightingSquads.length - 1; i >= 0; i--) {
                        let s = state.firefightingSquads[i];
                        if (s.state === 'moving_to_fire') {
                            const dx = s.target.x - s.x;
                            const dy = s.target.y - s.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist < 100) { 
                                s.state = 'extinguishing';
                            } else {
                                s.x += (dx / dist) * 2;
                                s.y += (dy / dist) * 2;
                            }
                        } else if (s.state === 'extinguishing') {
                            s.target.life--;
                            if (s.target.life <= 0) {
                                const hzIndex = state.hazards.indexOf(s.target);
                                if (hzIndex > -1) state.hazards.splice(hzIndex, 1);
                                s.state = 'leaving';
                            }
                        } else if (s.state === 'leaving') {
                            s.x -= 2;
                            if (s.x < -50) state.firefightingSquads.splice(i, 1);
                        }
                    }
                    // 新增: 破壞小組更新邏輯
                    for (let i = state.rescueSquads.length - 1; i >= 0; i--) {
                        let s = state.rescueSquads[i];
                        if (s.state === 'moving_to_vehicle') {
                            // 移動到車輛左側一點的位置
                            let tx = s.target.x - 40; 
                            let ty = s.target.y + s.target.h/2;
                            const dx = tx - s.x;
                            const dy = ty - s.y;
                            const dist = Math.hypot(dx, dy);
                            
                            if (dist < 10) {
                                s.state = 'breaking';
                                // 設定 600 frames = 約 10 秒
                                s.target.breakTimer = 600; 
                                addFeedback(s.target.x + s.target.w/2, s.target.y - 20, "破壞作業開始...", "#f39c12");
                            } else {
                                // 移動速度
                                s.x += (dx / dist) * 2.5;
                                s.y += (dy / dist) * 2.5;
                            }
                        } else if (s.state === 'breaking') {
                            // 破壞中：breakTimer 會在下方的 obstacles 迴圈中自動倒數
                            // 這裡只需要檢查是否完成
                            if (s.target.isBreached) {
                                s.state = 'leaving';
                                addFeedback(s.target.x + s.target.w/2, s.target.y - 20, "作業完成，撤收!", "#2ecc71");
                            }
                        } else if (s.state === 'leaving') {
                            // 返回出發點
                            let tx = 50 + 700;
                            let ty = 540/2 - 150;
                            const dx = tx - s.x;
                            const dy = ty - s.y;
                            const dist = Math.hypot(dx, dy);
                            
                            if (dist < 10) {
                                state.rescueSquads.splice(i, 1); // 移除小組
                            } else {
                                s.x += (dx / dist) * 2;
                                s.y += (dy / dist) * 2;
                            }
                        }
                    }
                    state.obstacles.forEach(o => {
                        if (o.breakTimer > 0) {
                            o.breakTimer--;
                            if (o.breakTimer <= 0) {
                                o.isBreached = true;
                                addFeedback(o.x + o.w/2, o.y, "破壞完成", "#2ecc71");
                                // --- 修改開始：將傷患移出車外 ---
                                // 搜尋受困於此車輛的傷患
                                const survivor = state.survivors.find(s => s.trappedInVehicle === o);
                                if (survivor) {
                                    // 將傷患位置設定到車輛下方 (Y軸增加)，確保完全露出
                                    // 偏移量設為車高 + 50px，確保有足夠點擊空間
                                    survivor.x = o.x + o.w / 2; // 水平置中
                                    survivor.y = o.y + o.h + 50; 

                                    // 簡單邊界檢查，如果太下面就改移到上面
                                    if (survivor.y > WORLD_HEIGHT - 30) {
                                        survivor.y = o.y - 50;
                                    }
                                    
                                    addFeedback(survivor.x, survivor.y, "傷患已移出", "#3498db");
                                    }
                            }
                        }
                    });

                   // 新程式碼：檢查場上是否有「無人處理」的重傷患
                    const unassignedTargets = state.survivors.filter(s => 
                        s.triageTag && 
                        (s.triageTag === 'red' || s.triageTag === 'yellow' || s.triageTag === 'black') && // 針對紅/黃/黑卡
                        !s.isEvacuating &&      // 非自行移動中
                        !s.hasArrived &&        // 尚未抵達安置區
                        !s.isBeingCarried &&    // 尚未被搬起
                        !state.npcGroups.some(g => g.target === s) && // 目前沒有任何小組鎖定他
                        (!s.trappedInVehicle || s.trappedInVehicle.isBreached) && // 沒有受困
                        !state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30) // 周圍無火
                    );

                    // 限制場上同時存在的搬運組上限 (例如 5 組)，避免太亂
                    if (unassignedTargets.length > 0 && state.npcGroups.length < 5) {
                        // 簡單的冷卻時間，避免同一幀生成所有人 (利用 frameCount)
                        if (state.frameCount % 60 === 0) {
                            // 優先處理紅卡 (雖然 filter 已經篩選過，這裡取第一個即可)
                            // 根據嚴重程度排序：黑 > 紅 > 黃 (或依需求調整)
                            unassignedTargets.sort((a, b) => {
                                const p = { 'black': 3, 'red': 2, 'yellow': 1 };
                                return p[b.triageTag] - p[a.triageTag];
                            });
                            
                            const target = unassignedTargets[0];

                            state.npcGroups.push({
                                leaderX: 20 + LEFT_EXPANSION, leaderY: 600, // 從畫面邊緣出現
                                followerX: 0 + LEFT_EXPANSION, followerY: 600,
                                target: target,           // 直接鎖定目標
                                state: 'moving_to_target', // 直接前往，不經過 searching
                                carrying: false
                            });
                        }
                    }

                    for (let i = state.npcGroups.length - 1; i >= 0; i--) {
                        let group = state.npcGroups[i];
                        const speed = 1.0;
                        if (group.state === 'searching') {
                            // 預防萬一：如果處於 searching 狀態但沒目標，直接撤離
                            group.state = 'leaving';
                            
                        }
                            
                         else if (group.state === 'moving_to_target') {
                            // (這段保持不變)
                            const dx = group.target.x - group.leaderX;
                            const dy = group.target.y - group.leaderY;
                            const dist = Math.hypot(dx, dy);
                            if (dist < 10) {
                                group.state = 'carrying';
                                group.carrying = true;
                                addFeedback(group.leaderX, group.leaderY, "開始搬運", "#fff");
                            } else {
                                group.leaderX += (dx / dist) * speed;
                                group.leaderY += (dy / dist) * speed;
                            }
                        } else if (group.state === 'carrying') {
                            // --- 修改：搬運至對應區域 ---
                            const dest = getTriageDest(group.target.triageTag);
                            const dx = dest.x - group.leaderX; 
                            const dy = dest.y - group.leaderY; 
                            const dist = Math.hypot(dx, dy);
                            
                            if (dist < 10) {
                                // 抵達目的地：放下傷患
                                group.target.x = dest.x;
                                group.target.y = dest.y;
                                group.target.isBeingCarried = false;
                                group.target.hasArrived = true; // 標記為已安置
                                
                                // NPC 重置狀態去搜尋下一個
                                group.target = null;
                                group.carrying = false;
                                group.state = 'searching'; 
                            } else {
                                group.leaderX += (dx / dist) * speed;
                                group.leaderY += (dy / dist) * speed;
                                if (group.target) {
                                    group.target.x = (group.leaderX + group.followerX) / 2;
                                    group.target.y = (group.leaderY + group.followerY) / 2;
                                }
                            }
                        } 
                        // ... leaving 狀態保持不變 ...
                        else if (group.state === 'leaving') {
                             group.leaderX -= speed;
                            if (group.leaderX < -50 + LEFT_EXPANSION) state.npcGroups.splice(i, 1);
                        }

                        // ... 跟隨者邏輯保持不變 ...
                        if (group.state !== 'searching' || group.leaderX > 0) { 
                             const fdx = group.leaderX - group.followerX;
                             const fdy = group.leaderY - group.followerY;
                             const fdist = Math.hypot(fdx, fdy);
                             if (fdist > 25) {
                                 group.followerX += (fdx / fdist) * speed; 
                                 group.followerY += (fdy / fdist) * speed;
                             }
                        } else {
                            group.followerX = group.leaderX - 20;
                            group.followerY = group.leaderY;
                        }
                    }

                    // --- 修改：傷患自行移動邏輯 (取代原本的 splice 移除) ---
                    for (let i = state.survivors.length - 1; i >= 0; i--) {
                        let s = state.survivors[i];
                        if (s.isEvacuating && !s.hasArrived) { // 只有尚未抵達的才需要移動
                            const dest = getTriageDest('green'); // 綠色標籤去綠色區或待命區
                            
                            const dx = dest.x - s.x;
                            const dy = dest.y - s.y;
                            const dist = Math.hypot(dx, dy);

                            if (dist < 10) {
                                s.isEvacuating = false;
                                s.hasArrived = true; // 標記已抵達
                                addFeedback(s.x, s.y, "抵達待命區", "#2ecc71");
                            } else {
                                s.x += (dx / dist) * 0.8; // 輕傷移動速度
                                s.y += (dy / dist) * 0.8;
                            }
                        }
                    }

                    state.survivors.forEach(s => {
                        if (s.tourniquetTimer !== null && s.tourniquetTimer > 0) {
                            s.tourniquetTimer -= 1/240; 
                            if (s.tourniquetTimer <= 0) {
                                s.tourniquetTimer = 0;
                                s.isDead = true;
                                s.triageTag = 'black'; 
                                s.data.consciousness = '無意識';
                                s.data.resp = '無';
                                s.data.pulse = '無';
                                s.data.injuryText = '失血過多死亡';
                                s.data.severity = 'black';
                                addFeedback(s.x, s.y, "傷患死亡", "#000");
                            }
                        }
                    });

                    const isTryingToMove = state.keys.w || state.keys.s || state.keys.a || state.keys.d;
                    let speed = p.speed;

                    if (isTryingToMove) {
                        state.stats.sp = Math.max(0, state.stats.sp - 0.2);
                        if (state.stats.sp <= 0) speed = speed * 0.5;
                    } else {
                        state.stats.sp = Math.min(state.stats.maxSp, state.stats.sp + 0.1);
                    }

                    if (state.keys.w) { nextY -= speed; p.dir = 1; p.moving = true; }
                    if (state.keys.s) { nextY += speed; p.dir = 0; p.moving = true; }
                    if (state.keys.a) { nextX -= speed; p.dir = 2; p.moving = true; }
                    if (state.keys.d) { nextX += speed; p.dir = 3; p.moving = true; }

                    state.camera.x = p.x - GAME_WIDTH / 2;
                    state.camera.y = p.y - GAME_HEIGHT / 2;
                    state.camera.x = Math.max(0, Math.min(state.camera.x, WORLD_WIDTH - GAME_WIDTH)); // 更新邊界
                    state.camera.y = Math.max(0, Math.min(state.camera.y, 1200 - GAME_HEIGHT));

                    state.decorations.forEach(d => {
                        if (d.type === 'oil') {
                            const dist = Math.hypot(p.x - d.x, p.y - d.y);
                            if (dist < d.r) {
                                state.stats.hp = Math.max(0, state.stats.hp - 0.05); 
                                if (state.frameCount % 60 === 0) {
                                    addFeedback(p.x, p.y - 30, "受傷! (油漬)", "#e74c3c");
                                }
                            }
                        }
                    });

                    let pBox = { x: nextX - 5, y: nextY - 5, w: 10, h: 10 };
                    let collide = false;

                    // --- 火焰碰撞邏輯 ---
                    for (let h of state.hazards) {
                        const dist = Math.hypot(nextX - h.x, nextY - h.y);
                        // 如果距離小於火焰半徑 (稍微寬一點，讓視覺上碰到顏色就擋住)
                        if (dist < h.r + 10) { 
                            collide = true; // 視為碰撞，無法前進
                            // 扣血
                            state.stats.hp = Math.max(0, state.stats.hp - 0.5);
                            if (state.frameCount % 30 === 0) {
                                addFeedback(p.x, p.y - 40, "高溫! 無法靠近!", "#e74c3c");
                            }
                            break;
                        }
                    }

                    for(let o of state.obstacles) {
                        if (o.type === 'metal_debris') {
                            if (pBox.x < o.x + o.w && pBox.x + 10 > o.x && pBox.y < o.y + o.h && pBox.y + 10 > o.y) {
                                state.stats.hp = Math.max(0, state.stats.hp - 0.1);
                                if (state.frameCount % 45 === 0) addFeedback(p.x, p.y - 30, "割傷! (金屬)", "#e74c3c");
                            }
                        }

                        let obBox = o.type === 'guardrail' ? {x: o.x, y: o.y, w: o.w, h: o.h} : o.hitbox;
                        if (!obBox) obBox = {x: o.x, y: o.y, w: o.w, h: o.h};
                        if (pBox.x < obBox.x + obBox.w && pBox.x + pBox.w > obBox.x && pBox.y < obBox.y + obBox.h && pBox.y + pBox.h > obBox.y) {
                            collide = true; break;
                        }
                    }
                    if (!collide) { p.x = nextX; p.y = nextY; }
                    if (p.moving) { p.animTimer++; p.frame = Math.floor(p.animTimer / 5); }

                    state.survivors.forEach(s => {
                        if (s.data.isBleeding && Math.random() > 0.8) { 
                            state.particles.push({
                                x: s.x + (Math.random() - 0.5) * 8, 
                                y: s.y + (Math.random() - 0.5) * 8,
                                vx: (Math.random() - 0.5) * 0.1, 
                                vy: (Math.random() - 0.5) * 0.1,
                                life: 15 + Math.random() * 10, 
                                size: 1.5,
                                color: 'rgba(231, 76, 60, 0.9)'
                            });
                        }
                    });

                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        let pt = state.particles[i];
                        pt.x += pt.vx; pt.y += pt.vy; 
                        pt.life--; 
                        if (!pt.color.includes('150')) pt.size = Math.max(0, pt.size - 0.05);
                        else pt.size += 0.1; 

                        if(pt.life <= 0) {
                            if (pt.color.includes('150')) { 
                                let car = state.obstacles[Math.floor(Math.random() * state.obstacles.length)];
                                if(car && car.type !== 'guardrail' && car.type !== 'wall') {
                                    pt.x = car.x + car.w/2; pt.y = car.y + car.h/2; pt.life = rand(50, 150); pt.size = rand(2, 5);
                                }
                            } else {
                                state.particles.splice(i, 1);
                            }
                        }
                    }

                    for(let i = state.feedbacks.length - 1; i >= 0; i--) {
                        let f = state.feedbacks[i];
                        f.y += f.vy; f.life--;
                        if(f.life <= 0) state.feedbacks.splice(i, 1);
                    }

                    if (state.frameCount % 10 === 0) {
                        setPlayerStatsUI({...state.stats});
                    }
                };

                const draw = () => {
                    ctx.save();
                    ctx.translate(-state.camera.x, -state.camera.y);
                    
                    // 背景更新寬度
                    drawRect(0, 0, WORLD_WIDTH, 1200, PALETTE.asphalt);
                    
                    if (state.placementMode.active) {
                        const zoneWidth = 50 + LEFT_EXPANSION; // 消防車位置
                        
                        ctx.save();
                        // 1. 半透明綠色背景
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.1)'; 
                        ctx.fillRect(0, 0, zoneWidth, 1200);
                        
                        // 2. 邊界虛線
                        ctx.strokeStyle = '#2ecc71';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([15, 10]); // 虛線樣式
                        ctx.beginPath();
                        ctx.moveTo(zoneWidth, 0);
                        ctx.lineTo(zoneWidth, 1200);
                        ctx.stroke();
                        
                        // 3. 文字提示
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.6)';
                        ctx.font = 'bold 30px "Segoe UI"';
                        ctx.textAlign = 'center';
                        ctx.fillText("安全作業區域 (由此處開始部署)", zoneWidth / 2, 200);
                        
                        ctx.restore();
                    }
                    // ↑↑↑↑↑↑ 綠色半透明區域程式碼位置 (由此結束) ↑↑↑↑↑↑

                    ctx.fillStyle = PALETTE.markingWhite;
                    const laneCount = 8; 
                    const laneH = (1200 - 80) / laneCount;
                    for(let l=1; l<laneCount; l++) {
                        let ly = 40 + l * laneH;
                        for(let lx=0; lx<WORLD_WIDTH; lx+=80) ctx.fillRect(lx, ly - 2, 40, 4);
                    }
                    ctx.fillStyle = PALETTE.markingYellow;
                    ctx.fillRect(0, 40, WORLD_WIDTH, 4);
                    ctx.fillRect(0, 1200 - 44, WORLD_WIDTH, 4);

                    drawTriageMats(state.triageMats);

                    state.decorations.forEach(d => {
                        if(d.type === 'skid') {
                            ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.angle); drawRect(0, 0, d.w, d.h, 'rgba(0,0,0,0.6)'); ctx.restore();
                        } else if (d.type === 'oil') {
                            ctx.fillStyle = PALETTE.oil; ctx.beginPath(); ctx.ellipse(d.x, d.y, d.r, d.r*0.6, 0, 0, Math.PI*2); ctx.fill();
                        } else if (d.type === 'glass') { drawRect(d.x, d.y, d.size, d.size, PALETTE.glass); }
                    });

                    state.hazards.forEach(h => drawFire(h));

                    state.emergencyVehicles.forEach(v => drawEmergencyVehicle(v));
                    drawFirefighters(state.firefightingSquads); 
                    drawRescueSquads(state.rescueSquads); // 新增這行
                    const renderList = [];
                    state.obstacles.forEach(o => {
                        if(o.type !== 'vehicle_block') renderList.push({type: 'obstacle', obj: o, y: o.y + o.h})
                    });
                    
                    state.survivors.forEach(s => {
                        let isLifted = false;
                        if (s.isBeingCarried) {
                            const carrierGroup = state.npcGroups.find(g => g.target === s && g.state === 'carrying');
                            if (carrierGroup) isLifted = true;
                        }

                        if (!isLifted || s.isEvacuating) { 
                            renderList.push({type: 'survivor', obj: s, y: s.y})
                        }
                    });
                    
                    renderList.push({type: 'player', y: state.player.y});
                    renderList.sort((a, b) => a.y - b.y);

                    renderList.forEach(item => {
                        if(item.type === 'obstacle') {
                            let o = item.obj;
                            if (o.type === 'metal_debris') {
                                ctx.save(); ctx.translate(o.x + o.w/2, o.y + o.h/2); ctx.rotate(o.angle);
                                ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.moveTo(-o.w/2, -o.h/2); ctx.lineTo(o.w/2, -o.h/4); ctx.lineTo(0, o.h/2); ctx.fill();
                                ctx.restore();
                            } else if(o.type === 'guardrail') {
                                drawRect(o.x, o.y, o.w, o.h, '#7f8c8d'); drawRect(o.x, o.y+5, o.w, 10, '#95a5a6'); 
                                for(let gx=0; gx<WORLD_WIDTH; gx+=100) drawRect(gx, o.y, 10, o.h, '#555');
                            } else if(o.type !== 'wall') {
                                drawRect(o.x+5, o.y+5, o.w, o.h, 'rgba(0,0,0,0.5)'); drawRect(o.x, o.y, o.w, o.h, o.color);
                                ctx.fillStyle = '#2c3e50';
                                if (o.isBreached) { 
                                    ctx.fillStyle = '#555'; 
                                }
                                let cabinW = o.rotated ? o.w*0.6 : o.w-4; let cabinH = o.rotated ? o.h-4 : o.h*0.5;
                                let cabinX = o.rotated ? o.x + (o.w-cabinW)/2 : o.x+2; let cabinY = o.rotated ? o.y+2 : o.y+(o.h-cabinH)/2;
                                drawRect(cabinX, cabinY, cabinW, cabinH, o.color);
                                ctx.fillStyle = '#2c3e50';
                                if(o.rotated) { drawRect(cabinX, cabinY, 4, cabinH); drawRect(cabinX+cabinW-4, cabinY, 4, cabinH); }
                                else { drawRect(cabinX, cabinY, cabinW, 4); drawRect(cabinX, cabinY+cabinH-4, cabinW, 4); }
                                
                                if (o.isBreached) { 
                                    ctx.fillStyle = '#000';
                                    ctx.fillText("破壞", o.x + o.w/2 - 10, o.y + o.h/2);
                                } else if (o.breakTimer > 0) {
                                    ctx.fillStyle = '#e67e22';
                                    ctx.fillText(`${Math.ceil(o.breakTimer/60)}s`, o.x + o.w/2 - 5, o.y + o.h/2);
                                }
                            }
                        } else if (item.type === 'survivor') {
                            drawSurvivorHighRes(item.obj);
                            let s = item.obj;
                            ctx.fillStyle = '#fff'; ctx.font = '10px Arial';
                            if (s.tourniquetTimer !== null && s.tourniquetTimer > 0) {
                                ctx.fillStyle = '#e74c3c'; ctx.font = 'bold 12px Arial'; ctx.fillText(Math.ceil(s.tourniquetTimer) + "s", s.x - 10, s.y - 25);
                            } else if (s.isDead) {
                                ctx.fillStyle = '#666'; ctx.font = 'bold 10px Arial'; ctx.fillText("DEAD", s.x - 12, s.y - 15);
                            } else if (s.triageTag) {
                                let tagText = "UNK";
                                if (s.triageTag === 'green') tagText = "III";
                                if (s.triageTag === 'yellow') tagText = "II";
                                if (s.triageTag === 'red') tagText = "I";
                                if (s.triageTag === 'black') tagText = "0";
                                ctx.fillText(tagText, s.x-4, s.y-10);
                            } else {
                                if(Math.floor(Date.now()/600)%2===0) { ctx.fillText('HELP', s.x-10, s.y-15); }
                            }
                        } else if (item.type === 'player') {
                            drawFirefighterHighRes(state.player.x, state.player.y, 0, '#1a253a', state.frameCount, state.player.moving);
                        }
                    });

                    drawNPCGroups(state.npcGroups);
                    drawStaticNpcs(state.staticNpcs);

                    state.particles.forEach(pt => { 
                        ctx.fillStyle = pt.color || 'rgba(150, 150, 150, 0.3)';
                        ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI*2); ctx.fill(); 
                    });

                    drawPlacementPreview(state.placementMode);

                    drawMenu(state.interactionMenu);
                    drawSurvivorInfo(state.player);

                    state.feedbacks.forEach(f => {
                        ctx.fillStyle = f.color;
                        ctx.font = 'bold 14px "Courier New"';
                        ctx.shadowColor = 'black';
                        ctx.shadowBlur = 2;
                        ctx.fillText(f.text, f.x - 20, f.y);
                        ctx.shadowBlur = 0;
                    });

                    ctx.restore();

                    ctx.save();
                    let time = Date.now();
                    let policeAlpha = (Math.sin(time / 200) + 1) / 2 * 0.1;
                    ctx.fillStyle = `rgba(0, 0, 255, ${policeAlpha})`; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                    if (Math.sin(time / 200 + Math.PI) > 0) { ctx.fillStyle = `rgba(255, 0, 0, ${policeAlpha})`; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); }
                    ctx.restore();
                };

                const loop = () => {
                    update();
                    draw();
                    if (!gameState.current.isGameOver) {
                        state.animationFrameId = requestAnimationFrame(loop);
                    }
                };
                loop();

                return () => {
                    window.removeEventListener('resize', resize);
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                    canvas.removeEventListener('click', handleCanvasClick);
                    canvas.removeEventListener('contextmenu', handleContextMenu); 
                   // 新增：移除監聽 // 移除 mousemove
                    window.removeEventListener('mousemove', handleMouseMove); 
                    cancelAnimationFrame(state.animationFrameId);
                };
            }, [gameOver]);

            return (
                <div className="flex justify-center items-center h-screen bg-[#050505] text-white overflow-hidden font-mono relative">
                <div className="relative shadow-[0_0_50px_rgba(0,0,20,0.5)] border-2 border-[#333] bg-[#111]">
                    <canvas ref={canvasRef} className="block image-pixelated cursor-crosshair" />
                    
                    {gameOver && (
                        <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-50 animate-fade-in">
                            <h1 className="text-5xl text-red-600 font-bold mb-8 tracking-widest drop-shadow-[0_0_10px_rgba(255,0,0,0.8)] animate-pulse">
                                GAME OVER
                            </h1>
                            <div className="text-gray-400 mb-8 text-center text-sm">
                                任務失敗：生命跡象消失<br/>
                                總計檢傷：{survivorCount}/{totalSurvivors}
                            </div>
                            <button 
                                onClick={handleRestart}
                                className="px-8 py-3 bg-white text-black font-bold text-lg hover:bg-gray-300 hover:scale-105 transition transform rounded shadow-lg border-2 border-transparent hover:border-gray-500"
                            >
                                重新遊戲
                            </button>
                        </div>
                    )}

                    {/* 地墊選擇選單 */}
                    {showMatSelector && (
                        <div className="absolute bottom-20 left-1/2 -translate-x-1/2 bg-black/90 p-4 rounded-lg border border-gray-500 shadow-xl flex gap-4 z-50">
                             {[
                                    { id: 'green', label: '輕傷區', bg: 'bg-green-500', hover: 'hover:bg-green-400', text: 'text-black' },
                                    { id: 'yellow', label: '中傷區', bg: 'bg-yellow-500', hover: 'hover:bg-yellow-400', text: 'text-black' },
                                    { id: 'red', label: '重傷區', bg: 'bg-red-600', hover: 'hover:bg-red-500', text: 'text-white' },
                                    { id: 'black', label: '黑卡區', bg: 'bg-gray-800', hover: 'hover:bg-gray-700', text: 'text-white' }
                                ].map(btn => {
                                    // 檢查該顏色是否已存在於場景中
                                    const isUsed = gameState.current.triageMats.some(m => m.color === btn.id);
                                    
                                    return (
                                        <button 
                                            key={btn.id}
                                            onClick={() => !isUsed && handleSelectMatColor(btn.id)} 
                                            disabled={isUsed}
                                            className={`
                                                w-16 h-10 font-bold text-xs rounded shadow relative transition-all
                                                ${isUsed 
                                                    ? 'bg-gray-700 text-gray-500 cursor-not-allowed border border-gray-600' 
                                                    : `${btn.bg} ${btn.hover} ${btn.text}`
                                                }
                                            `}
                                        >
                                            {btn.label}
                                            {isUsed && (
                                                <span className="absolute inset-0 flex items-center justify-center text-red-500/80 text-lg font-bold">✕</span>
                                            )}
                                        </button>
                                    );
                                })}
                            </div>
                        )}
                        {/* --- 修改結束 --- */}

                    <div className="absolute top-3 left-3 pointer-events-none select-none">
                        <div className="bg-black/60 p-1.5 mb-1 backdrop-blur-sm border-l-2 border-[#e74c3c] inline-block">
                            <h1 className="text-sm m-0 text-[#e74c3c] font-bold flex items-center gap-2 tracking-wide">
                                <IconAlert /> HIGHWAY PILE-UP
                            </h1>
                        </div>
                        <div className="bg-black/80 p-2 border-l-2 border-orange-500 text-gray-200 text-xs w-[220px] shadow-lg">
                            <div className="flex items-center gap-2 mb-1">
                                <IconMapPin /> <span className="text-gray-400">LOC:</span> 國道一號 35KM
                            </div>
                            <div className="flex items-center gap-2 mb-1">
                                <IconActivity /> <span className="text-gray-400">OBJ:</span> 搜尋 ({survivorCount}/{totalSurvivors})
                            </div>
                        </div>
                        <div className="mt-2 w-[150px] flex flex-col gap-1">
                            <div className="flex items-center gap-1 bg-black/60 p-1 rounded-sm">
                                <span className="text-[10px] font-bold text-red-400 w-4">HP</span>
                                <div className="h-2 flex-1 bg-gray-700 relative overflow-hidden rounded-sm">
                                    <div className="absolute top-0 left-0 h-full bg-red-600" style={{width: `${(playerStatsUI.hp/playerStatsUI.maxHp)*100}%`}}></div>
                                </div>
                            </div>
                            <div className="flex items-center gap-1 bg-black/60 p-1 rounded-sm">
                                <span className="text-[10px] font-bold text-blue-400 w-4">MP</span>
                                <div className="h-2 flex-1 bg-gray-700 relative overflow-hidden rounded-sm">
                                    <div className="absolute top-0 left-0 h-full bg-blue-600" style={{width: `${(playerStatsUI.mp/playerStatsUI.maxMp)*100}%`}}></div>
                                </div>
                            </div>
                            <div className="flex items-center gap-1 bg-black/60 p-1 rounded-sm">
                                <span className="text-[10px] font-bold text-yellow-400 w-4">SP</span>
                                <div className="h-2 flex-1 bg-gray-700 relative overflow-hidden rounded-sm">
                                    <div className="absolute top-0 left-0 h-full bg-yellow-600" style={{width: `${(playerStatsUI.sp/playerStatsUI.maxSp)*100}%`}}></div>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    {/* --- 修改：道具欄移至此處 (外層黑色區域) --- */}
                    <div className="absolute bottom-8 left-1/2 -translate-x-1/2 pointer-events-auto select-none z-50">
                        <div className="flex gap-1 bg-black/80 p-2 border border-gray-600 rounded-md shadow-[0_0_15px_rgba(0,0,0,0.8)]">
                            {items.map((item, i) => (
                                <div 
                                    key={i} 
                                    onClick={() => handleSlotClick(i)}
                                    className={`w-10 h-10 border bg-gray-900/50 hover:bg-gray-700/50 transition-colors relative cursor-pointer group
                                        ${selectedSlot === i ? 'border-yellow-400 shadow-[0_0_10px_rgba(253,224,71,0.5)]' : 'border-gray-600 hover:border-gray-400'}
                                    `}
                                    title={item.name}
                                >
                                    <span className="absolute bottom-0.5 right-1 text-[8px] text-gray-500 group-hover:text-gray-300 font-bold">{i === 9 ? 0 : i + 1}</span>
                                    <div className="w-full h-full flex items-center justify-center p-2">
                                        <div className="w-full h-full rounded-sm opacity-80" style={{backgroundColor: item.color}}></div>
                                    </div>
                                    <div className="absolute -top-8 left-1/2 -translate-x-1/2 bg-black text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 whitespace-nowrap pointer-events-none transition-opacity">
                                        {item.name}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
