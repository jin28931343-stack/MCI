<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <link 
    href="[https://fonts.googleapis.com/css2?family=DotGothic16&family=Press+Start+2P&display=swap](https://fonts.googleapis.com/css2?family=DotGothic16&family=Press+Start+2P&display=swap)" 
    rel="stylesheet">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>MCIæ¨¡æ“¬</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* ç¢ºä¿ç§»å‹•è¨­å‚™åœ¨è±å±æ™‚å¼·åˆ¶æ©«å± (æœ€ç°¡åŒ–ä¸”é€šç”¨) */
        @media only screen and (max-device-width: 1024px) and (orientation: portrait) {

            /* ä½¿ç”¨ vh/vw ä¾†ç¢ºä¿æ—‹è½‰å¾Œå¡«æ»¿æ•´å€‹è¦–å£ */
            html,
            body {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden;
            }

            body {
                /* ä¿®æ”¹ï¼šä½¿ç”¨ fixed å®šä½é˜²æ­¢æ»¾å‹•èˆ‡ç¶²å€åˆ—é€ æˆçš„åç§» */
                position: fixed;
                top: 50%;
                left: 50%;
                /* ä½¿ç”¨ 100vh/vw ç¢ºä¿å¡«æ»¿è¦–å£ */
                width: 100vh;
                height: 100vw;
                /* æ—‹è½‰ä¸­å¿ƒè¨­ç‚ºæ­£ä¸­å¤® */
                transform: translate(-50%, -50%) rotate(90deg);
                transform-origin: center center;
                visibility: visible;
                z-index: 9999;
                background-color: #050505;
            }

            /* ä¿®æ”¹ï¼šå¼·åˆ¶å…§éƒ¨å®¹å™¨å¡«æ»¿æ—‹è½‰å¾Œçš„ body ä¸¦ç½®ä¸­ */
            #root,
            .flex.justify-center.items-center.h-screen {
                width: 100% !important;
                height: 100% !important;
                position: absolute !important;
                top: 0;
                left: 0;
                margin: 0;
                /* ç¢ºä¿ Flex å±¬æ€§ç”Ÿæ•ˆ */
                display: flex;
                justify-content: center;
                align-items: center;
            }
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            /* Safari */
            touch-action: none;
            /* ç¦æ­¢é è¨­è§¸æ§è¡Œç‚ºï¼Œé˜²æ­¢ç•«é¢æ»‘å‹• */
        }

        canvas {
            image-rendering: auto;
        }

        ::-webkit-scrollbar {
            display: none;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        .animate-blink {
            animation: blink 1s infinite;
        }

        /* â˜…â˜…â˜… æ–°å¢ï¼šéŸ³è¨Šè¦–è¦ºåŒ–æ³¢å½¢å‹•ç•« â˜…â˜…â˜… */
        @keyframes sound-wave {
            0% {
                height: 3px;
            }

            50% {
                height: 15px;
            }

            100% {
                height: 3px;
            }
        }

        .playing-wave .bar {
            animation: sound-wave 0.5s infinite ease-in-out;
        }

        .playing-wave .bar:nth-child(1) {
            animation-delay: 0.0s;
        }

        .playing-wave .bar:nth-child(2) {
            animation-delay: 0.1s;
        }

        .playing-wave .bar:nth-child(3) {
            animation-delay: 0.2s;
        }

        .playing-wave .bar:nth-child(4) {
            animation-delay: 0.3s;
        }

        /* â˜…â˜…â˜… è™›æ“¬æ–æ¡¿ UI â˜…â˜…â˜… */
        .joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 150px;
            height: 150px;
            z-index: 100;
            touch-action: none;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* â˜…â˜…â˜… æ‰‹æ©Ÿç‰ˆåŠŸèƒ½æŒ‰éˆ• â˜…â˜…â˜… */
        .mobile-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            font-weight: bold;
            font-size: 14px;
            backdrop-filter: blur(5px);
            touch-action: manipulation;
            user-select: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        .btn-interact {
            bottom: 40px;
            right: 40px;
            border-color: #f1c40f;
            color: #f1c40f;
        }

        .btn-cancel {
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .btn-inventory {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            border-color: #3498db;
            color: #3498db;
        }

        /* â˜…â˜…â˜… è‡ªå®šç¾©åƒç´ ç®­é ­é¼ æ¨™ CSS â˜…â˜…â˜… */
        .cursor-pixel {
            /* ä½¿ç”¨ SVG Data URI ç¹ªè£½åƒç´ é¢¨æ ¼ç®­é ­ (ç™½åº•é»‘é‚Š) */
            cursor: url("data:image/svg+xml,%3Csvg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='shadow' x='-2' y='-2' width='200%25' height='200%25'%3E%3CfeDropShadow dx='1' dy='1' stdDeviation='1' flood-color='rgba(0,0,0,0.5)'/%3E%3C/filter%3E%3Cpath d='M2 2 L2 20 L6 16 L10 25 L13 23 L9 14 L15 14 L2 2 Z' fill='white' stroke='black' stroke-width='2' stroke-linejoin='round' filter='url(%23shadow)'/%3E%3C/svg%3E") 2 2, auto;
        }

        /* === é–‹é ­å‹•ç•«æ¨£å¼ (æ–°å¢) === */
        :root {
            --bg-color: #1a1a2e;
            --ruin-color: #0f0f1a;
            --fire-color: #e94560;
        }

        /* å‹•ç•«å®¹å™¨è¦†è“‹å±¤ */
        #intro-app-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            z-index: 99999;
            /* ç¢ºä¿åœ¨æœ€ä¸Šå±¤ */
            font-family: 'DotGothic16', sans-serif;
            user-select: none;
        }

        #intro-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            background: linear-gradient(to bottom, #111 0%, #332 100%);
        }

        .ruins-bg {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 40%;
            background-color: var(--ruin-color);
            clip-path: polygon(0% 100%, 0% 20%, 5% 20%, 5% 10%, 10% 10%, 10% 40%,
                    15% 40%, 15% 5%, 25% 5%, 25% 30%, 30% 30%, 30% 60%,
                    40% 60%, 40% 10%, 50% 10%, 50% 50%, 55% 50%, 55% 20%,
                    65% 20%, 65% 55%, 75% 55%, 75% 15%, 85% 15%, 85% 40%,
                    90% 40%, 90% 10%, 95% 10%, 95% 30%, 100% 30%, 100% 100%);
            z-index: 1;
        }

        .smoke {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #555;
            box-shadow: 10px -10px 0 #444, 20px 0 0 #666;
            opacity: 0.6;
            animation: floatUp 4s infinite linear;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 0.6;
            }

            100% {
                transform: translateY(-100px) scale(2);
                opacity: 0;
            }
        }

        .road {
            position: absolute;
            bottom: 5%;
            width: 100%;
            height: 60px;
            z-index: 5;
        }

        .vehicle {
            position: absolute;
            font-size: 80px;
            bottom: 0;
            left: 100%;
            filter: drop-shadow(4px 4px 0px rgba(0, 0, 0, 0.5));
        }

        @keyframes driveBy {
            0% {
                left: 100%;
                transform: scaleX(1);
            }

            40% {
                left: 40%;
                transform: scaleX(1) skewX(10deg);
            }

            100% {
                left: -20%;
                transform: scaleX(1);
            }
        }

        .siren-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            mix-blend-mode: overlay;
        }

        @keyframes sirenFlash {
            0% {
                background-color: rgba(255, 0, 0, 0.4);
                opacity: 0.6;
            }

            50% {
                background-color: rgba(0, 0, 255, 0.4);
                opacity: 0.6;
            }

            100% {
                background-color: rgba(255, 0, 0, 0.4);
                opacity: 0.6;
            }
        }

        #transition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
        }

        #title-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 30;
            opacity: 0;
            width: 100%;
        }

        .main-title {
            font-family: 'DotGothic16', sans-serif;
            font-size: 5rem;
            color: #fff;
            text-shadow: 4px 4px 0 #e94560, 8px 8px 0 #000;
            margin-bottom: 0px;
            letter-spacing: 5px;
        }

        .sub-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            color: #ffd700;
            text-shadow: 2px 2px 0 #000;
            margin-top: 20px;
            margin-bottom: 50px;
        }

        .start-btn {
            background-color: #e94560;
            color: white;
            border: 4px solid #fff;
            padding: 15px 30px;
            font-family: 'DotGothic16', sans-serif;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 4px 4px 0 #000;
            transition: transform 0.1s;
            animation: pulse 1.5s infinite;
        }

        .start-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 0 0 0 #000;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
        }

        @keyframes shake {

            10%,
            90% {
                transform: translate3d(-1px, 0, 0);
            }

            20%,
            80% {
                transform: translate3d(2px, 0, 0);
            }

            30%,
            50%,
            70% {
                transform: translate3d(-4px, 0, 0);
            }

            40%,
            60% {
                transform: translate3d(4px, 0, 0);
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef, useState } = React;

        const IconAlert = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" /><path d="M12 9v4" /><path d="M12 17h.01" /></svg>;
        const IconMapPin = () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z" /><circle cx="12" cy="10" r="3" /></svg>;
        const IconActivity = () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2" /></svg>;
        // â˜…â˜…â˜… éŸ³é‡åœ–ç¤º â˜…â˜…â˜…
        const IconVolume = ({ muted }) => muted ?
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><line x1="23" y1="9" x2="17" y2="15" /><line x1="17" y1="9" x2="23" y2="15" /></svg> :
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" /></svg>;
        // === æ–°å¢çš„ IntroScreen çµ„ä»¶ ===
        const IntroScreen = ({ onStart }) => {
            useEffect(() => {
                const police = document.getElementById('police');
                const ambulance = document.getElementById('ambulance');
                const fire = document.getElementById('fire');
                const sirenOverlay = document.getElementById('siren-overlay');
                const appContainer = document.getElementById('intro-app-container');
                const transitionOverlay = document.getElementById('transition-overlay');
                const titleContainer = document.getElementById('title-container');

                const createSmokeParticles = () => {
                    const container = document.getElementById('smoke-container');
                    if (!container) return;
                    for (let i = 0; i < 15; i++) {
                        let smoke = document.createElement('div');
                        smoke.className = 'smoke';
                        smoke.style.left = Math.random() * 100 + '%';
                        smoke.style.bottom = (Math.random() * 20 + 10) + '%';
                        smoke.style.animationDelay = Math.random() * 2 + 's';
                        smoke.style.animationDuration = (Math.random() * 3 + 3) + 's';
                        container.appendChild(smoke);
                    }
                };

                const runIntroSequence = () => {
                    createSmokeParticles();

                    // å•Ÿå‹•è­¦ç¤ºç‡ˆ
                    if (sirenOverlay) sirenOverlay.style.animation = "sirenFlash 0.3s infinite";

                    // è»Šè¼›ç§»å‹•åºåˆ—
                    if (police) police.style.animation = "driveBy 1.5s linear forwards";

                    setTimeout(() => {
                        if (ambulance) ambulance.style.animation = "driveBy 1.5s linear forwards";
                        if (appContainer) appContainer.classList.add('shake');
                    }, 800);

                    setTimeout(() => {
                        if (fire) fire.style.animation = "driveBy 1.5s linear forwards";
                        if (appContainer) {
                            appContainer.classList.remove('shake');
                            void appContainer.offsetWidth; // trigger reflow
                            appContainer.classList.add('shake');
                        }
                    }, 1600);

                    setTimeout(() => {
                        if (sirenOverlay) {
                            sirenOverlay.style.animation = "none";
                            sirenOverlay.style.opacity = "0";
                        }
                        if (transitionOverlay) {
                            transitionOverlay.style.transition = "opacity 0.5s ease-in";
                            transitionOverlay.style.backgroundColor = "black";
                            transitionOverlay.style.opacity = "1";
                        }
                    }, 3200);

                    setTimeout(() => {
                        if (transitionOverlay) {
                            transitionOverlay.style.transition = "none";
                            transitionOverlay.style.backgroundColor = "white";

                            setTimeout(() => {
                                transitionOverlay.style.transition = "opacity 1.5s ease-out";
                                transitionOverlay.style.opacity = "0";
                                if (titleContainer) {
                                    titleContainer.style.transition = "opacity 2s ease-in";
                                    titleContainer.style.opacity = "1";
                                }
                            }, 100);
                        }
                    }, 4000);
                };

                runIntroSequence();
            }, []);

            const handleStart = () => {
                const transitionOverlay = document.getElementById('transition-overlay');
                const introLayer = document.getElementById('intro-layer');

                if (transitionOverlay) {
                    transitionOverlay.style.backgroundColor = "black";
                    transitionOverlay.style.transition = "opacity 1s ease-in";
                    transitionOverlay.style.opacity = "1";
                }

                setTimeout(() => {
                    if (introLayer) introLayer.style.display = "none";
                    // è§¸ç™¼çˆ¶çµ„ä»¶çš„é–‹å§‹éŠæˆ²å›èª¿
                    onStart();
                }, 1000);
            };

            return (
                <div id="intro-app-container">
                    <div id="intro-layer">
                        <div id="smoke-container"></div>
                        <div className="ruins-bg"></div>
                        <div id="siren-overlay" className="siren-overlay"></div>
                        <div className="road">
                            <div id="police" className="vehicle">ğŸš“</div>
                            <div id="ambulance" className="vehicle">ğŸš‘</div>
                            <div id="fire" className="vehicle">ğŸš’</div>
                        </div>
                        <div id="title-container">
                            <h1 className="main-title">å¤§å‚·ç¾å ´</h1>
                            <h2 className="sub-title">MASS CASUALTY INCIDENT</h2>
                            <button className="start-btn" onClick={handleStart}>é»æ“Šé–‹å§‹ START</button>
                        </div>
                    </div>
                    <div id="transition-overlay"></div>
                </div>
            );
        };

        function App() {
            const canvasRef = useRef(null);
            const [gameStarted, setGameStarted] = useState(false);
            const [missionComplete, setMissionComplete] = useState(false);
            const [resultStats, setResultStats] = useState(null);
            const [survivorCount, setSurvivorCount] = useState(0);
            const [evacuatedCount, setEvacuatedCount] = useState(0);
            const [selectedSlot, setSelectedSlot] = useState(0);
            // â˜…â˜…â˜… å°ˆé–€ç”¨æ–¼å¼·åˆ¶ç•«é¢æ›´æ–°çš„ stateï¼Œé¿å…æ±™æŸ“ survivorCount â˜…â˜…â˜…
            const [updateCount, forceUpdate] = useState(0);
            // â˜…â˜…â˜…  Ref ä¾†è¿½è¹¤ selectedSlotï¼Œè§£æ±º Event Listener è®€ä¸åˆ°æœ€æ–°ç‹€æ…‹çš„å•é¡Œ â˜…â˜…â˜…
            const selectedSlotRef = useRef(selectedSlot);
            const [showRadioPanel, setShowRadioPanel] = useState(false);
            // â˜…â˜…â˜… å¿…é ˆåŠ å…¥æ­¤ useEffectï¼Œè®“ Ref è·Ÿéš¨ State æ›´æ–°â˜…â˜…â˜…
            useEffect(() => {
                selectedSlotRef.current = selectedSlot;
            }, [selectedSlot]);
            const [gameOver, setGameOver] = useState(false);
            const [showMatSelector, setShowMatSelector] = useState(false);
            // â˜…â˜…â˜… æ§åˆ¶é“å…·æ¬„é¡¯ç¤ºçš„ç‹€æ…‹ (é è¨­éš±è—ï¼ŒæŒ‰ I åˆ‡æ›) â˜…â˜…
            const [showInventory, setShowInventory] = useState(false);
            // â˜…â˜…â˜… éŸ³è¨Šæ§åˆ¶ç›¸é—œ State èˆ‡ Ref â˜…â˜…â˜…
            const audioCtxRef = useRef(null);
            const [isMuted, setIsMuted] = useState(true);
            const isMutedRef = useRef(true); // ç”¨æ–¼åœ¨ Scheduler ä¸­è®€å–
            const nextNoteTimeRef = useRef(0);
            const schedulerTimerRef = useRef(null);
            const sequenceStepRef = useRef(0);
            const [score, setScore] = useState(0);
            // â˜…â˜…â˜… è™›æ“¬æ–æ¡¿èˆ‡æŒ‰éˆ• Ref â˜…â˜…â˜…
            const joystickRef = useRef({ active: false, identifier: null, baseX: 0, baseY: 0, vecX: 0, vecY: 0 });
            const [joystickUI, setJoystickUI] = useState({ x: 0, y: 0, active: false });
            // ç”¨æ–¼å°‡ useEffect å…§éƒ¨çš„ handler æš´éœ²çµ¦å¤–éƒ¨ JSX ä½¿ç”¨
            const keyDownHandlerRef = useRef(null);
            const cancelActionRef = useRef(null);
            // åŒæ­¥éœéŸ³ç‹€æ…‹åˆ° Ref
            useEffect(() => { isMutedRef.current = isMuted; }, [isMuted]);
            const handleJoystickTouchStart = (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const rect = e.currentTarget.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                joystickRef.current = {
                    active: true,
                    identifier: touch.identifier,
                    baseX: centerX,
                    baseY: centerY,
                    vecX: 0,
                    vecY: 0
                };
                setJoystickUI({ x: 0, y: 0, active: true });
            };
            const handleJoystickTouchEnd = (e) => {
                e.preventDefault();
                joystickRef.current = { ...joystickRef.current, active: false, vecX: 0, vecY: 0 };
                setJoystickUI({ x: 0, y: 0, active: false });
            };
            const handleJoystickTouchMove = (e) => {
                e.preventDefault();
                if (!joystickRef.current.active) return;

                const touchList = e.changedTouches;
                let touch = null;
                // å°‹æ‰¾å°æ‡‰çš„ touch ID
                for (let i = 0; i < touchList.length; i++) {
                    if (touchList[i].identifier === joystickRef.current.identifier) {
                        touch = touchList[i];
                        break;
                    }
                }
                if (!touch) return;

                const rect = e.currentTarget.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // è¨ˆç®—ç›¸å°æ–¼æ–æ¡¿ä¸­å¿ƒçš„åç§»é‡
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;

                const maxDist = 35; // æ–æ¡¿æœ€å¤§ç§»å‹•åŠå¾‘
                const dist = Math.hypot(dx, dy);

                // é™åˆ¶åœ¨åœ“å½¢ç¯„åœå…§
                if (dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio;
                    dy *= ratio;
                }

                // æ›´æ–° UI ä½ç½®
                setJoystickUI({ x: dx, y: dy, active: true });

                // æ›´æ–°é‚è¼¯å‘é‡ (æ­¸ä¸€åŒ– -1 ~ 1)ä¾›éŠæˆ²è¿´åœˆä½¿ç”¨
                joystickRef.current.vecX = dx / maxDist;
                joystickRef.current.vecY = dy / maxDist;
            };
            // â˜…â˜…â˜… æ¨¡æ“¬æŒ‰éµè§¸ç™¼ (çµ¦ UI æŒ‰éˆ•ç”¨) â˜…â˜…â˜…
            const triggerKey = (keyName) => {
                if (keyDownHandlerRef.current) {
                    keyDownHandlerRef.current({ key: keyName, preventDefault: () => { } });
                }
            };
            const triggerCancel = () => {
                if (cancelActionRef.current) cancelActionRef.current();
            };
            // â˜…â˜…â˜… åˆå§‹åŒ–éŸ³è¨Šç’°å¢ƒ (8-bit Synth) â˜…â˜…â˜…
            const initAudio = () => {
                if (!audioCtxRef.current) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioCtxRef.current = new AudioContext();
                }
                if (audioCtxRef.current.state === 'suspended') {
                    audioCtxRef.current.resume();
                }
            };

            // â˜…â˜…â˜… æ’­æ”¾å–®éŸ³ (Oscillator) â˜…â˜…â˜…
            const playOscillator = (freq, type, startTime, duration, vol) => {
                if (!audioCtxRef.current || isMutedRef.current) return;
                const ctx = audioCtxRef.current;
                const osc = ctx.createOscillator();
                const gainNode = ctx.createGain();

                osc.type = type; // square, sawtooth, triangle
                osc.frequency.setValueAtTime(freq, startTime);

                // ç°¡å–®çš„ Envelope
                gainNode.gain.setValueAtTime(vol, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);

                osc.connect(gainNode);
                gainNode.connect(ctx.destination);

                osc.start(startTime);
                osc.stop(startTime + duration);
            };

            // â˜…â˜…â˜… æ’­æ”¾é¼“è² (Noise) â˜…â˜…â˜…
            const playDrum = (startTime) => {
                if (!audioCtxRef.current || isMutedRef.current) return;
                const ctx = audioCtxRef.current;
                const bufferSize = ctx.sampleRate * 0.1;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = ctx.createGain();
                // é«˜é€šæ¿¾æ³¢æ¨¡æ“¬ Hi-hat
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);

                gain.gain.setValueAtTime(0.05, startTime);
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
                noise.start(startTime);
            }

            // â˜…â˜…â˜… éŸ³æ¨‚æ’ç¨‹å™¨ (Music Loop) â˜…â˜…â˜…
            const scheduler = () => {
                if (!audioCtxRef.current) return;
                const lookahead = 25.0; // æ¯«ç§’
                const scheduleAheadTime = 0.1; // ç§’
                const bpm = 130; // ç·Šå¼µç¯€å¥
                const secondsPerBeat = 60.0 / bpm;
                const ctx = audioCtxRef.current;

                while (nextNoteTimeRef.current < ctx.currentTime + scheduleAheadTime) {
                    scheduleNote(sequenceStepRef.current, nextNoteTimeRef.current);
                    nextNoteTimeRef.current += secondsPerBeat / 4; // 16åˆ†éŸ³ç¬¦
                    sequenceStepRef.current = (sequenceStepRef.current + 1) % 16;
                }
                schedulerTimerRef.current = setTimeout(scheduler, lookahead);
            };

            // â˜…â˜…â˜… æ¨‚å¥ç·¨æ›² (Pattern) â˜…â˜…â˜…
            const scheduleNote = (step, time) => {
                if (isMutedRef.current) return;

                // 1. Bassline (Driving Square Wave)
                // Pattern: C2... Eb2... G2...
                const root = 65.41; // C2
                const flat3 = 77.78; // Eb2
                const fifth = 98.00; // G2

                let freq = root;
                if (step >= 8 && step < 12) freq = flat3;
                if (step >= 12) freq = fifth;

                if (step % 2 === 0) { // 8th notes
                    playOscillator(freq, 'square', time, 0.1, 0.1);
                }

                // 2. High Arp (Emergency Alarm Feel)
                if (step === 0 || step === 8) {
                    playOscillator(523.25, 'sawtooth', time, 0.1, 0.03); // C5
                }
                if (step === 4 || step === 12) {
                    playOscillator(783.99, 'sawtooth', time, 0.1, 0.03); // G5
                }

                // 3. Rhythm (Tick)
                if (step % 4 === 0) {
                    playDrum(time);
                }
            };

            // â˜…â˜…â˜… é–‹é—œéŸ³æ¨‚å‡½å¼ â˜…â˜…â˜…
            const toggleAudio = () => {
                const newVal = !isMuted;
                setIsMuted(newVal);
                if (!newVal) { // é–‹å•ŸéŸ³æ¨‚
                    initAudio();
                    if (!schedulerTimerRef.current) {
                        nextNoteTimeRef.current = audioCtxRef.current.currentTime + 0.1;
                        scheduler();
                    }
                } else {
                    // éœéŸ³æ™‚ä¸éœ€ç‰¹åˆ¥åœæ­¢ Contextï¼Œåªéœ€è®“ scheduleNote ä¸ç™¼è²å³å¯ï¼Œä¿æŒåŒæ­¥
                }
            };

            // æ¸…é™¤ Timer
            useEffect(() => {
                return () => clearTimeout(schedulerTimerRef.current);
            }, []);
            const statsTracker = useRef({
                tourniquet: { correct: 0, total: 0 },
                airway: { correct: 0, total: 0 },
                deconCount: 0
            });

            // --- ç‹€æ…‹è¿½è¹¤å„é¡åˆ¥å·²å®‰ç½®äººæ•¸ ---
            // â˜…â˜…â˜… æ–°å¢ï¼šæ§åˆ¶å¹³æ¿ UI é¡¯ç¤ºçš„ç‹€æ…‹ â˜…â˜…â˜…
            const [showTabletUI, setShowTabletUI] = useState(false);
            // â˜…â˜…â˜… æ–°å¢ï¼šç›®å‰åœ¨å¹³æ¿ä»‹é¢ä¸­é¸ä¸­çš„å‚·æ‚£ â˜…â˜…â˜…
            const [selectedPatient, setSelectedPatient] = useState(null);
            const [triageCounts, setTriageCounts] = useState({
                green: 0,
                yellow: 0,
                red: 0,
                black: 0,
            });

            const [playerStatsUI, setPlayerStatsUI] = useState({
                hp: 100, maxHp: 100,
                mp: 80, maxMp: 100,
                sp: 100, maxSp: 100
            });

            const totalSurvivors = 30;

            const gameState = useRef({
                isGameOver: false,
                keys: { w: false, s: false, a: false, d: false },
                player: {
                    x: 300, y: 600, width: 30, height: 30, speed: 1.75, dir: 3, frame: 0, moving: false, animTimer: 0
                },
                camera: { x: 0, y: 0 },
                stats: { hp: 100, maxHp: 100, mp: 80, maxMp: 100, sp: 100, maxSp: 100 },
                obstacles: [],
                energyDrinks: [],      // å­˜æ”¾å ´ä¸Šçš„é£²æ–™ç‰©ä»¶
                energySpawnTimer: 0,   // ç”Ÿæˆè¨ˆæ™‚å™¨
                spBuffTimer: 0,        // SP ç„¡é™ Buff è¨ˆæ™‚å™¨
                emergencyVehicles: [],
                npcGroups: [],
                firefightingSquads: [],
                staticNpcs: [],
                decorations: [],
                triageMats: [],
                hazards: [],
                particles: [],
                survivors: [],
                feedbacks: [],
                firefightingSquads: [],
                rescueSquads: [], // ç ´å£æ•‘æ´å°çµ„é™£åˆ—
                staticNpcs: [],
                interactionMenu: {
                    active: false, x: 0, y: 0, target: null, mode: 'main', selectedIndex: 0
                },
                placementMode: {
                    active: false,
                    type: null,
                    color: null,
                    w: 120, h: 80,
                    valid: false,
                    x: 0, y: 0
                },
                // â˜…â˜…â˜… æ¬é‹ç³»çµ±å†·å»è¨ˆæ™‚å™¨ (åˆå§‹åŒ–ç‚º 0) â˜…â˜…â˜…
                carrySystemCooldown: 0,
                ambulanceCooldown: 0, // æ•‘è­·è»Šå‘¼å«å†·å»æ™‚é–“
                megaphoneCooldown: 0,
                survivorsFoundCount: 0,
                animationFrameId: null,
                frameCount: 0,
                npcSpawnTimer: 0
            });

            const items = [
                { name: "ç„¡ç·šé›»", color: "#34495e", type: "radio", imgSrc: "PIC/radio.png" },        // 1
                { name: "æª¢å‚·å¹³æ¿", color: "#9b59b6", type: "tablet", imgSrc: "PIC/tablet.png" },       // 2
                { name: "æª¢å‚·åœ°å¢Š", color: "#27ae60", type: "mat", imgSrc: "PIC/mat.png" },          // 3
                { name: "æŒ‡æ®ç«™", color: "#ffffff", type: "command_post", imgSrc: "PIC/command_post.png" }, // 4
                { name: "é™¤æ±™ç«™", color: "#95a5a6", type: "decon", imgSrc: "PIC/decon.png" },        // 5
                { name: "æ•‘è­·è»Šå¾…å‘½å€", color: "#3498db", type: "ambulance_staging", imgSrc: "PIC/ambulance_staging.png" },//6 
                { name: "å¤§è²å…¬", color: "#e67e22", type: "megaphone", imgSrc: "PIC/megaphone.png" }, // 7
            ];


            const handleSlotClick = (index) => {
                const item = items[index];
                if (selectedSlotRef.current === index) {
                    setSelectedSlot(-1);
                    setShowMatSelector(false);
                    setShowTabletUI(false);
                    setShowRadioPanel(false); // é—œé–‰ç„¡ç·šé›»é¢æ¿
                    setSelectedPatient(null);
                    gameState.current.placementMode.active = false;
                    // (ç§»é™¤èˆŠçš„ interactionMenu æ¸…é™¤é‚è¼¯ï¼Œå› ç‚ºä¸å†ä½¿ç”¨äº†)
                    return;
                }
                if (!item) return;
                else if (item.type === 'megaphone') {
                    setShowMatSelector(false);
                    setShowTabletUI(false);
                    setShowRadioPanel(false);
                    gameState.current.placementMode.active = false;
                    gameState.current.interactionMenu.active = false;

                    const state = gameState.current;

                    // æª¢æŸ¥å†·å» (30ç§’)
                    if (state.megaphoneCooldown > 0) {
                        state.feedbacks.push({
                            x: state.player.x,
                            y: state.player.y - 50,
                            text: `å¤§è²å…¬å†·å»ä¸­ (${Math.ceil(state.megaphoneCooldown / 60)}s)`,
                            color: "#bdc3c7",
                            life: 60,
                            vy: -0.5
                        });
                        return;
                    }

                    // è¨­å®šå†·å»æ™‚é–“ (30ç§’ * 60 FPS)
                    state.megaphoneCooldown = 1800;

                    // é‚è¼¯ï¼šæœå°‹ç•«é¢å…§çš„ç¶ è‰²å‚·æ‚£ï¼Œä¸¦è§¸ç™¼ç§»å‹•
                    const camX = state.camera.x;
                    const camY = state.camera.y;
                    const viewW = 960; // éŠæˆ²å¯¬åº¦
                    const viewH = 540; // éŠæˆ²é«˜åº¦
                    let count = 0;
                    state.survivors.forEach(s => {
                        // â˜…â˜…â˜… ä¿®æ”¹ï¼šåªè¦æ˜¯ã€Œå¯¦éš›è¼•å‚· (Green)ã€ä¸”ã€Œåœ¨ç•«é¢å…§ã€ï¼Œä¸è«–æ˜¯å¦å·²æª¢å‚·ï¼Œéƒ½å¼·åˆ¶è™•ç† â˜…â˜…â˜…
                        const isInView = s.x >= camX && s.x <= camX + viewW && s.y >= camY && s.y <= camY + viewH;

                        if (isInView && s.data.severity === 'green' && !s.hasArrived && !s.onAmbulance) {

                            // 1. å¼·åˆ¶æª¢å‚·é‚è¼¯ï¼šå¦‚æœå°šæœªè¢«æ¨™è¨˜ç‚ºç¶ è‰²ï¼Œè‡ªå‹•æ¨™è¨˜ä¸¦åŠ åˆ†
                            if (s.triageTag !== 'green') {
                                s.triageTag = 'green';
                                s.found = true;

                                // è£œä¸ŠåŠ åˆ†é‚è¼¯ (æ¯”ç…§æ‰‹å‹•æª¢å‚·æ­£ç¢º +100)
                                if (!s.hasBeenScored) {
                                    setScore(prev => prev + 100);
                                    state.feedbacks.push({
                                        x: s.x, y: s.y - 50, text: "å¼·åˆ¶æª¢å‚· +100", color: "#f1c40f", life: 60, vy: -0.5
                                    });
                                    s.hasBeenScored = true;
                                }
                            }

                            // 2. è§¸ç™¼ç§»å‹•é‚è¼¯
                            if (!s.isEvacuating) {
                                s.isEvacuating = true; // å°‡ç‹€æ…‹è¨­ç‚ºç§»å‹•ä¸­
                                count++;

                                // çµ¦äºˆå€‹åˆ¥å‚·æ‚£ä¸€é»è¦–è¦ºå›é¥‹
                                state.feedbacks.push({
                                    x: s.x, y: s.y - 20, text: "æ”¶åˆ°é›†åˆæŒ‡ä»¤!", color: "#2ecc71", life: 40, vy: -0.5
                                });
                            }
                        }
                    });

                    // â˜…â˜…â˜… æ›´æ–°å…¨åŸŸæª¢å‚·è¨ˆæ•¸ (å› ç‚ºå¯èƒ½æœ‰æ–°çš„å‚·æ‚£è¢«å¼·åˆ¶æª¢å‚·) â˜…â˜…â˜…
                    state.survivorsFoundCount = state.survivors.filter(s => s.found).length;
                    setSurvivorCount(state.survivorsFoundCount);

                    // ç©å®¶å›é¥‹
                    state.feedbacks.push({
                        x: state.player.x,
                        y: state.player.y - 60,
                        text: count > 0 ? `å»£æ’­ï¼š${count}åè¼•å‚·è€…å‰å¾€é›†åˆé»` : "ç¯„åœå…§ç„¡å¯ç§»å‹•è¼•å‚·è€…",
                        color: "#e67e22",
                        life: 90,
                        vy: -0.5
                    });
                    return;
                }


                setSelectedSlot(index);
                // --- ç§»é™¤ MP æª¢æŸ¥ï¼šé»æ“Šé“å…·æ™‚ä¸å†æª¢æŸ¥ MP ---
                // if (item.type === 'radio' && gameState.current.stats.mp < 10) {
                //      addFeedback(gameState.current.player.x, gameState.current.player.y - 50, "MPä¸è¶³!", "#e74c3c");
                //      setSelectedSlot(-1); // å–æ¶ˆé¸æ“‡
                //      return; 
                // }
                // â˜…â˜…â˜… åˆ‡æ›é“å…·æ™‚å…ˆé—œé–‰å…¶ä»– UI â˜…â˜…â˜…
                setShowMatSelector(false);
                setShowTabletUI(false);
                gameState.current.placementMode.active = false;
                gameState.current.interactionMenu.active = false; // åˆ‡æ›é“å…·æ™‚é—œé–‰äº’å‹•é¸å–®
                if (item.type === "mat") {
                    setShowMatSelector(true);
                } else if (item.type === 'tablet') {
                    // â˜…â˜…â˜… å¦‚æœæ˜¯å¹³æ¿ï¼Œé–‹å•Ÿ UI â˜…â˜…â˜…
                    setShowTabletUI(true);
                } else if (['command_post', 'ambulance_staging', 'decon'].includes(item.type)) {
                    // â˜…â˜…â˜… é™åˆ¶ç‰¹æ®Šå€åŸŸåªèƒ½è¨­ç½®ä¸€å€‹ â˜…â˜…â˜…
                    // æª¢æŸ¥å ´æ™¯ä¸­æ˜¯å¦å·²å­˜åœ¨ç›¸åŒé¡å‹çš„å€åŸŸ (ä½¿ç”¨ color ä½œç‚ºè­˜åˆ¥)
                    const alreadyExists = gameState.current.triageMats.some(m => m.color === item.type);

                    if (alreadyExists) {
                        // é¡¯ç¤ºæç¤ºè¨Šæ¯ (ç›´æ¥æ“ä½œ state å› ç‚º addFeedback åœ¨ useEffect å…§éƒ¨ç„¡æ³•ç›´æ¥å‘¼å«)
                        gameState.current.feedbacks.push({
                            x: gameState.current.player.x,
                            y: gameState.current.player.y - 50,
                            text: "æ­¤å€åŸŸåªèƒ½è¨­ç½®ä¸€å€‹",
                            color: "#e74c3c",
                            life: 60,
                            vy: -0.5
                        });
                        setSelectedSlot(-1); // å–æ¶ˆç•¶å‰é¸ä¸­çš„é“å…·
                        return; // ä¸­æ­¢å¾ŒçºŒæ”¾ç½®é‚è¼¯
                    }

                    // è¨­å®šç‰¹æ®Šå€å¡Šçš„æ”¾ç½®æ¨¡å¼
                    gameState.current.placementMode = {
                        active: true,
                        type: 'zone',
                        color: item.type, // ä½¿ç”¨ type ä½œç‚ºé¡è‰²éµå€¼
                        w: 160, h: 120,   // è¨­å®šæ¯”æª¢å‚·åœ°å¢Šç¨å¤§
                        valid: false,
                        x: 0, y: 0
                    };

                } else if (item.type === 'radio') {
                    setShowRadioPanel(true); // é–‹å•Ÿç„¡ç·šé›»é¢æ¿

                } else if (['breaker_tool', 'extinguisher_tool'].includes(item.type)) {
                    gameState.current.feedbacks.push({
                        x: gameState.current.player.x,
                        y: gameState.current.player.y - 50,
                        text: "è«‹é»æ“Šç›®æ¨™ä½¿ç”¨",
                        color: item.color,
                        life: 60,
                        vy: -0.5
                    });
                }
            };

            const handleSelectMatColor = (color) => {
                setShowMatSelector(false);
                gameState.current.placementMode = {
                    active: true,
                    type: 'triage_mat',
                    color: color,
                    w: 100, h: 100,
                    valid: false,
                    x: 0, y: 0
                };
            };

            const handleRestart = () => {
                setGameOver(true);
                setTimeout(() => {
                    setMissionComplete(false); // é—œé–‰ä»»å‹™å®Œæˆç•«é¢
                    setResultStats(null);      // æ¸…é™¤çµç®—æ•¸æ“š
                    setScore(0);               // é‡ç½®åˆ†æ•¸

                    // ç¢ºä¿ UI ä¸Šçš„è¨ˆæ•¸å™¨æ­¸é›¶ (é›–ç„¶ useEffect æœƒé‡ç½®éƒ¨åˆ†ï¼Œä½†æ‰‹å‹•ç¢ºä¿ UI åŒæ­¥æ›´å®‰å…¨)
                    setSurvivorCount(0);
                    setEvacuatedCount(0);
                    setTriageCounts({ green: 0, yellow: 0, red: 0, black: 0 });

                    // é—œéµï¼šå°‡ gameOver è¨­å› falseã€‚
                    // é€™æœƒè§¸ç™¼ä¾è³´ [gameOver] çš„ useEffect åŸ·è¡Œåˆå§‹åŒ–é‚è¼¯ï¼Œç”Ÿæˆæ–°çš„å‚·æ‚£èˆ‡å ´æ™¯ã€‚
                    setGameOver(false);
                }, 50);
            };

            const generateSurvivorData = (isTrapped) => {
                const sex = Math.random() > 0.5 ? 'ç”·' : 'å¥³';
                const age = Math.floor(Math.random() * (70 - 12 + 1)) + 12;

                const severityRoll = Math.random();
                let severity = 'green';
                let consciousness = 'æ¸…é†’';
                let resp = Math.random() > 0.5 ? '24æ¬¡/min' : '12æ¬¡/min';
                let pulse = 'æ©ˆå‹•è„ˆæ‘¸çš„åˆ°';
                let injuryText = Math.random() > 0.5 ? 'æ“¦å‚·ã€é©šåš‡' : 'è‡‰éƒ¨æµè¡€';
                let isBleeding = false;
                // å®šç¾©ç´…è‰²å‚·æ‚£çš„å‘¼å¸é€Ÿç‡é¸é … (32, 8, 24) 
                const redRespOptions = ['32æ¬¡/min', '8æ¬¡/min', '24æ¬¡/min'];

                // å—å›°å‚·æ‚£å¼·åˆ¶è¨­å®šç‚ºç´…è‰²æˆ–é»‘è‰² 
                if (isTrapped) {
                    if (Math.random() > 0.7) { // 30% æ©Ÿç‡æ­»äº¡(é»‘)
                        severity = 'black';
                        consciousness = 'ç„¡æ„è­˜';
                        resp = 'ç„¡';
                        pulse = 'ç„¡';
                        injuryText = 'åš´é‡æ“ å£“è®Šå½¢ã€ç„¡ç”Ÿå‘½å¾µè±¡';
                        isBleeding = false;
                    } else { // 70% æ©Ÿç‡é‡å‚·(ç´…)
                        severity = 'red';
                        consciousness = Math.random() > 0.5 ? 'ç„¡æ„è­˜' : 'å°ç—›æœ‰åæ‡‰';
                        resp = redRespOptions[Math.floor(Math.random() * redRespOptions.length)];
                        pulse = Math.random() > 0.5 ? 'æ©ˆå‹•è„ˆæ‘¸ä¸åˆ°' : 'CRT>2ç§’';
                        injuryText = Math.random() > 0.5 ? 'å—å›°å£“å‚·ã€æ‡·ç–‘å…§å‡ºè¡€' : 'é›™è…³è®Šå½¢';
                        isBleeding = true;
                    }
                } else {
                    if (severityRoll > 0.9) {
                        severity = 'black'; consciousness = 'ç„¡æ„è­˜'; resp = 'ç„¡'; pulse = 'ç„¡'; injuryText = 'ç„¡å‘¼å¸';
                        isBleeding = false;
                    } else if (severityRoll > 0.75) {
                        severity = 'red'; consciousness = Math.random() > 0.5 ? 'ç„¡æ„è­˜' : 'å°ç—›æœ‰åæ‡‰';
                        resp = redRespOptions[Math.floor(Math.random() * redRespOptions.length)];
                        pulse = Math.random() > 0.5 ? 'æ©ˆå‹•è„ˆå¾®å¼±,CRT>2ç§’' : 'æ©ˆå‹•è„ˆæ‘¸ä¸åˆ°'; injuryText = Math.random() > 0.5 ? 'æ‰‹è‡‚è®Šå½¢ã€è¡¨æƒ…ç—›è‹¦' : 'è‡‰è‰²è’¼ç™½ã€å¤šè™•æ’•è£‚å‚·';
                        isBleeding = Math.random() > 0.3;
                    } else if (severityRoll > 0.50) {
                        severity = 'yellow'; consciousness = Math.random() > 0.5 ? 'å°è²éŸ³æœ‰åæ‡‰' : 'å¯ä»¥è½æŒ‡ä»¤'; resp = Math.random() > 0.5 ? '18æ¬¡/åˆ†' : '24æ¬¡/åˆ†'; pulse = Math.random() > 0.5 ? 'CRT<2sec' : 'æ©ˆå‹•è„ˆæ‘¸çš„åˆ°'; injuryText = Math.random() > 0.5 ? 'éª¨æŠ˜ã€ç„¡æ³•è¡Œèµ°' : 'é ­æšˆã€å˜”åç„¡æ³•è¡Œèµ°';
                        isBleeding = false;
                    } else {
                        isBleeding = false;
                    }
                }

                const clothColor = `hsl(${Math.random() * 360}, 40%, 60%)`;
                // â˜…â˜…â˜… éš¨æ©Ÿè¨­å®šæ˜¯å¦è¢«æ±™æŸ“ (ä¾‹å¦‚ 30% æ©Ÿç‡) â˜…â˜…â˜…
                const isContaminated = Math.random() > 0.7;
                // â˜…â˜…â˜… å›å‚³ç‰©ä»¶åŠ å…¥ isContaminated â˜…â˜…â˜…
                return {
                    sex, age, severity, consciousness, resp, pulse, injuryText, isBleeding, clothColor, isContaminated,
                    initialSeverity: severity,      // è¨˜éŒ„åˆå§‹å‚·æƒ… (ç”¨æ–¼è¨ˆç®—ç´…è‰²å„ªå…ˆå¾Œé€ç‡)
                    wasContaminated: isContaminated // è¨˜éŒ„æ˜¯å¦æ›¾ç¶“æ±™æŸ“ (ç”¨æ–¼è¨ˆç®—é™¤æ±™ç‡)
                };
            };

            useEffect(() => {
               if (!gameStarted || gameOver || !canvasRef.current) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const state = gameState.current;

                const GAME_WIDTH = 960;
                const GAME_HEIGHT = 540;

                // --- è¨­å®šæ“´å¼µ ---
                // å·¦å´åç§»é‡ (ç´„ 4 å°æ¶ˆé˜²è»Šå¯¬åº¦ + ç·©è¡ = 700px)
                const LEFT_EXPANSION = 700;
                // åŸæœ¬ä¸–ç•Œå¯¬åº¦ 2000ï¼ŒåŠ ä¸Šæ“´å¼µå€åŸŸ
                const WORLD_WIDTH = 2000 + LEFT_EXPANSION;
                const WORLD_HEIGHT = 1200;

                // --- é‡ç½® ---
                state.isGameOver = false;
                state.obstacles = [];
                state.emergencyVehicles = [];
                state.npcGroups = [];
                state.firefightingSquads = [];
                state.staticNpcs = [];
                state.decorations = [];
                state.triageMats = [];
                state.hazards = [];
                state.particles = [];
                state.survivors = [];
                state.feedbacks = [];
                state.energyDrinks = [];
                state.energySpawnTimer = 0;
                state.survivorsFoundCount = 0;
                state.frameCount = 0;
                state.npcSpawnTimer = 0;
                state.rescueSquads = [];
                state.ambulanceCooldown = 0; // â˜…â˜…â˜… æ•‘è­·è»Šå†·å»æ™‚é–“åˆå§‹åŒ– â˜…â˜…â˜…
                state.stats = { hp: 100, maxHp: 100, mp: 80, maxMp: 100, sp: 100, maxSp: 100 };

                // ç©å®¶èµ·å§‹ä½ç½®ä¹Ÿè·Ÿè‘—å‘å³ç§»ï¼Œä¿æŒç›¸å°ä½ç½®
                state.player.x = 210 + LEFT_EXPANSION;
                state.player.y = WORLD_HEIGHT / 2 + 100;

                // æ”å½±æ©Ÿåˆå§‹ä½ç½®å¯ä»¥è¨­åœ¨æ“´å¼µå€é‚Šç·£ï¼Œè®“ç©å®¶çœ‹åˆ°ç©ºåœ°
                state.camera = { x: LEFT_EXPANSION - 300, y: 0 }; // ç¨å¾®å¾€å·¦ä¸€é»çœ‹
                if (state.camera.x < 0) state.camera.x = 0;

                state.interactionMenu = { active: false, x: 0, y: 0, target: null, mode: 'main' };
                state.placementMode.active = false;
                setSurvivorCount(0);
                setEvacuatedCount(0);
                setPlayerStatsUI({ ...state.stats });
                setShowMatSelector(false);
                const checkTriageCounts = () => {
                    const counts = { green: 0, yellow: 0, red: 0, black: 0 };
                    state.survivors.forEach(s => {
                        // è¨ˆç®—å·²æŠµé”å°æ‡‰å€åŸŸçš„å‚·æ‚£
                        if (s.hasArrived && s.triageTag) {
                            counts[s.triageTag] = counts[s.triageTag] + 1;
                        }
                    });
                    setTriageCounts(counts);
                };

                const resize = () => {
                    if (!canvas) return;
                    let winW = document.documentElement.clientWidth || window.innerWidth;
                    let winH = document.documentElement.clientHeight || window.innerHeight;
                    // æª¢æŸ¥æ˜¯å¦è™•æ–¼ã€ŒCSSå¼·åˆ¶æ©«å±ã€æ¨¡å¼ (å³æ‰‹æ©Ÿç›´ç«‹æ™‚)
                    // æ³¨æ„ï¼šéœ€é…åˆ CSS ä¸­çš„ @media (orientation: portrait) æ—‹è½‰è¨­å®š
                    const isForcedLandscape = window.matchMedia("(max-device-width: 1024px) and (orientation: portrait)").matches;

                    if (isForcedLandscape) {
                        // å› ç‚º CSS å°‡ body æ—‹è½‰äº† 90 åº¦ï¼Œæ‰€ä»¥ã€Œè¦–è¦ºä¸Šã€çš„å¯¬åº¦å…¶å¯¦æ˜¯ window.innerHeight
                        // æˆ‘å€‘éœ€è¦äº¤æ›å¯¬é«˜ä¾†è¨ˆç®—æ­£ç¢ºçš„ç¸®æ”¾æ¯”ä¾‹
                        [winW, winH] = [winH, winW];
                    }

                    // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ï¼Œç¢ºä¿å¡«æ»¿è¢å¹•ä¸”ä¸æº¢å‡º
                    let scale = Math.min(winW / GAME_WIDTH, winH / GAME_HEIGHT);
                    canvas.style.width = `${GAME_WIDTH * scale}px`;
                    canvas.style.height = `${GAME_HEIGHT * scale}px`;
                };

                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;
                window.addEventListener('resize', resize);
                // å¢åŠ ç›£è½è½‰å‘äº‹ä»¶ (é‡å°ç§»å‹•è£ç½®)
                window.addEventListener('orientationchange', () => {
                    setTimeout(resize, 100); // å»¶é²ä¸€ä¸‹ç­‰å¾…ç€è¦½å™¨é‡æ–°æ’ç‰ˆ
                });
                resize();

                const PALETTE = {
                    asphalt: '#2d3436', markingWhite: '#b2bec3', markingYellow: '#f1c40f', oil: '#000000', glass: '#81ecec',
                    carColors: ['#e74c3c', '#3498db', '#ecf0f1', '#95a5a6', '#f39c12'],
                    playerVest: '#3498db', playerReflect: '#f1c40f'
                };
                const rand = (min, max) => Math.random() * (max - min) + min;

                const addFeedback = (x, y, text, color = "#fff") => {
                    state.feedbacks.push({ x: x, y: y - 20, text: text, color: color, life: 60, vy: -0.5 });
                };

                // --- ç”Ÿæˆè»Šè¼›èˆ‡éšœç¤™ç‰© (æ‰€æœ‰Xåº§æ¨™éƒ½è¦åŠ ä¸Š LEFT_EXPANSION) ---

                // å®šç¾©æ¶ˆé˜²è»Šä½ç½® (åŠ ä¸Šåç§»)
                const firetruckData = { type: 'firetruck', x: 50 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 150, w: 140, h: 60, angle: 0.3 };

                // --- è¨ˆç®—æ¶ˆé˜²è»Šå‰å¾Œæ·¨ç©ºå€åŸŸ ---
                const ftClearanceLength = 420;
                const ftClearanceZone = {
                    minX: firetruckData.x - ftClearanceLength,
                    maxX: firetruckData.x + firetruckData.w + ftClearanceLength,
                    minY: firetruckData.y - 50,
                    maxY: firetruckData.y + firetruckData.h + 50
                };

                state.emergencyVehicles.push(firetruckData);
                // â˜…â˜…â˜… åˆå§‹æ•‘è­·è»ŠåŠ å…¥ passengers èˆ‡ ID â˜…â˜…â˜…
                state.emergencyVehicles.push({
                    id: Math.random(), type: 'ambulance', passengers: [], state: 'waiting',
                    x: 80 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 + 100, w: 100, h: 50, angle: -0.2
                });

                state.emergencyVehicles.push({ type: 'police', x: 30 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 + 200, w: 80, h: 40, angle: 0.1 });

                // é˜»æ“‹æ–¹å¡Š (åŠ ä¸Šåç§»)
                state.obstacles.push({ x: 50 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 150, w: 140, h: 60, type: 'vehicle_block' });
                state.obstacles.push({ x: 80 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 + 100, w: 100, h: 50, type: 'vehicle_block' });
                state.obstacles.push({ x: 30 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 + 200, w: 80, h: 40, type: 'vehicle_block' });

                state.staticNpcs.push({ x: 100 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 70, dir: 1 });
                state.staticNpcs.push({ x: 120 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 70, dir: 1 });
                state.decorations.push({ type: 'stretcher', x: 110 + LEFT_EXPANSION, y: WORLD_HEIGHT / 2 - 55, angle: 0 });

                // éš¨æ©Ÿè£é£¾ (Skid, Oil, Glass) - ç¯„åœå¾ LEFT_EXPANSION é–‹å§‹ï¼Œä¿æŒå·¦å´ä¹¾æ·¨
                for (let i = 0; i < 30; i++) state.decorations.push({ type: 'skid', x: rand(LEFT_EXPANSION, WORLD_WIDTH), y: rand(50, WORLD_HEIGHT - 50), w: rand(50, 150), h: rand(2, 4), angle: rand(-0.2, 0.2) });
                for (let i = 0; i < 30; i++) state.decorations.push({ type: 'oil', x: rand(LEFT_EXPANSION, WORLD_WIDTH), y: rand(50, WORLD_HEIGHT - 50), r: rand(20, 45) });
                for (let i = 0; i < 150; i++) state.decorations.push({ type: 'glass', x: rand(LEFT_EXPANSION, WORLD_WIDTH), y: rand(0, WORLD_HEIGHT), size: rand(1, 3) });

                // ç«ç„°ç”Ÿæˆ (ç¯„åœèª¿æ•´)
                for (let i = 0; i < 8; i++) {
                    // å¾ 300 + LEFT_EXPANSION é–‹å§‹ç”Ÿæˆï¼Œç¢ºä¿é›¢èµ·å§‹é»æœ‰è·é›¢
                    let fx = rand(300 + LEFT_EXPANSION, WORLD_WIDTH - 100);
                    let fy = rand(100, WORLD_HEIGHT - 100);

                    if (fx > ftClearanceZone.minX && fx < ftClearanceZone.maxX && fy > ftClearanceZone.minY && fy < ftClearanceZone.maxY) {
                        continue;
                    }

                    state.hazards.push({ id: i, type: 'fire', x: fx, y: fy, r: rand(30, 60), beingExtinguished: false, life: 300 });
                }

                // é‡‘å±¬ç¢ç‰‡ç”Ÿæˆ (ç¯„åœèª¿æ•´)
                for (let i = 0; i < 20; i++) {
                    let mx = rand(100 + LEFT_EXPANSION, WORLD_WIDTH - 100);
                    let my = rand(100, WORLD_HEIGHT - 100);

                    if (mx > ftClearanceZone.minX && mx < ftClearanceZone.maxX && my > ftClearanceZone.minY && my < ftClearanceZone.maxY) {
                        continue;
                    }
                    state.obstacles.push({ type: 'metal_debris', x: mx, y: my, w: rand(20, 40), h: rand(10, 20), angle: rand(0, Math.PI) });
                }

                // é‚Šç•Œè­·æ¬„ (æ›´æ–°å¯¬åº¦)
                state.obstacles.push({ x: 0, y: 0, w: WORLD_WIDTH, h: 40, type: 'guardrail' });
                state.obstacles.push({ x: 0, y: WORLD_HEIGHT - 40, w: WORLD_WIDTH, h: 40, type: 'guardrail' });
                // ç‰†å£ä½ç½®æ›´æ–°
                state.obstacles.push({ x: -10, y: 0, w: 10, h: WORLD_HEIGHT, type: 'wall' });
                state.obstacles.push({ x: WORLD_WIDTH, y: 0, w: 10, h: WORLD_HEIGHT, type: 'wall' });

                // ä¸€èˆ¬è»Šè¼›ç”Ÿæˆ (ç¯„åœèª¿æ•´)
                for (let i = 0; i < 30; i++) {
                    let type = Math.random() > 0.8 ? 'truck' : 'sedan';
                    // ç”Ÿæˆç¯„åœå¾ 300 + LEFT_EXPANSION é–‹å§‹
                    let x = rand(300 + LEFT_EXPANSION, WORLD_WIDTH - 170);
                    let y = rand(170, WORLD_HEIGHT - 170);
                    let rotated = Math.random() > 0.3;
                    let w = (type === 'sedan' ? (rotated ? 80 : 40) : (rotated ? 120 : 50));
                    let h = (type === 'sedan' ? (rotated ? 40 : 80) : (rotated ? 50 : 120));

                    // æª¢æŸ¥æ¶ˆé˜²è»Šæ·¨ç©ºå€
                    if (x + w > ftClearanceZone.minX && x < ftClearanceZone.maxX && y + h > ftClearanceZone.minY && y < ftClearanceZone.maxY) {
                        continue;
                    }

                    let overlap = state.obstacles.some(o => x < o.x + o.w + 10 && x + w + 10 > o.x && y < o.y + o.h + 10 && y + h + 10 > o.y);
                    if (!overlap) {
                        state.obstacles.push({
                            x, y, w, h, type, rotated,
                            color: type === 'truck' ? '#fff' : PALETTE.carColors[Math.floor(Math.random() * PALETTE.carColors.length)],
                            hitbox: { x: x + 2, y: y + 2, w: w - 4, h: h - 4 },
                            isBreached: false, breakTimer: 0
                        });
                    }
                }

                let cars = state.obstacles.filter(o => o.type !== 'guardrail' && o.type !== 'wall' && o.type !== 'vehicle_block' && o.type !== 'metal_debris');
                for (let i = 0; i < totalSurvivors; i++) {
                    let car = cars[Math.floor(Math.random() * cars.length)];
                    // è¨­å®š 30% æ©Ÿç‡å—å›°æ–¼è»Šå…§ (éœ€ç ´å£)ï¼Œ70% æ©Ÿç‡æ•£è½åœ¨å¤–
                    let inCar = Math.random() > 0.7;

                    let sx, sy;

                    if (inCar && car) {
                        // ã€å—å›°è»Šå…§ã€‘ï¼šå¼·åˆ¶ä½ç½®èˆ‡è»Šé«”é‡ç–Š (ä½æ–¼è»Šè¼›ä¸­å¿ƒ)
                        sx = car.x + car.w / 2;
                        sy = car.y + car.h / 2;
                    } else {
                        // ã€éå—å›°ã€‘ï¼šä½ç½®ä¸èƒ½èˆ‡è»Šé«”é‡ç–Šï¼Œä½†å¯ä»¥é è¿‘
                        let validPosition = false;
                        let attempts = 0;

                        // å˜—è©¦å°‹æ‰¾åˆæ³•ä½ç½® (æœ€å¤šå˜—è©¦ 50 æ¬¡ä»¥é˜²ç„¡çª®è¿´åœˆ)
                        while (!validPosition && attempts < 50) {
                            attempts++;

                            // æ±ºå®šç”Ÿæˆå€åŸŸ
                            if (car && Math.random() > 0.4) {
                                // ç­–ç•¥ A: åœ¨è»Šè¼›ã€Œé™„è¿‘ã€ç”Ÿæˆ (ç¯„åœç¨å¤§ï¼Œå…è¨±é è¿‘)
                                sx = car.x + rand(-60, car.w + 60);
                                sy = car.y + rand(-60, car.h + 60);
                            } else {
                                // ç­–ç•¥ B: å…¨åœ°åœ–éš¨æ©Ÿ
                                sx = rand(300 + LEFT_EXPANSION, WORLD_WIDTH - 150);
                                sy = rand(150, WORLD_HEIGHT - 150);
                            }

                            // 1. åŸºç¤é‚Šç•Œæª¢æŸ¥
                            if (sx < 350 + LEFT_EXPANSION) sx = 350 + LEFT_EXPANSION;
                            if (sx > WORLD_WIDTH - 150) sx = WORLD_WIDTH - 150;
                            if (sy < 150) sy = 150;
                            if (sy > WORLD_HEIGHT - 150) sy = WORLD_HEIGHT - 150;

                            // 2. é¿é–‹æ¶ˆé˜²è»Šä½œæ¥­æ·¨ç©ºå€
                            if (sx > ftClearanceZone.minX && sx < ftClearanceZone.maxX && sy > ftClearanceZone.minY && sy < ftClearanceZone.maxY) {
                                continue;
                            }

                            // 3. ã€ä¿®æ­£ã€‘ç¢°æ’æª¢æ¸¬ï¼šåŠ å¤§åˆ¤å®šé‚Šè· (Margin)
                            // å‚·æ‚£ç¹ªè£½åŠå¾‘ç´„ç‚º 15~20pxï¼Œè¨­å®š margin = 20 ç¢ºä¿ä¸æœƒèˆ‡è»Šé«”é‡ç–Š
                            let isOverlapping = false;
                            const safeMargin = 20; // â˜…â˜…â˜… ä¿®æ”¹è™•ï¼šåŠ å¤§é‚Šè· (åŸç‚º 5) â˜…â˜…â˜…

                            for (let o of state.obstacles) {
                                // åªæª¢æŸ¥å¯¦é«”è»Šè¼›èˆ‡è»Šè¼›é˜»æ“‹å¡Š
                                if (o.type === 'sedan' || o.type === 'truck' || o.type === 'vehicle_block') {
                                    if (sx > o.x - safeMargin && sx < o.x + o.w + safeMargin &&
                                        sy > o.y - safeMargin && sy < o.y + o.h + safeMargin) {
                                        isOverlapping = true;
                                        break; // ç™¼ç¾é‡ç–Š
                                    }
                                }
                            }

                            // å¦‚æœæ²’æœ‰é‡ç–Šï¼Œæ¨™è¨˜ç‚ºåˆæ³•ä½ç½®
                            if (!isOverlapping) {
                                validPosition = true;
                            }
                        }

                        // å¦‚æœå˜—è©¦ 50 æ¬¡éƒ½å¤±æ•— (æ¥µå°‘è¦‹)ï¼Œå‰‡å¼·åˆ¶æ”¾ç½®åœ¨å·¦å´å®‰å…¨ç©ºåœ°
                        if (!validPosition) {
                            sx = LEFT_EXPANSION + rand(50, 150);
                            sy = WORLD_HEIGHT / 2 + rand(-50, 50);
                            inCar = false; // ç¢ºä¿æ¨™è¨˜ç‚ºéå—å›°
                        }
                    }

                    // ç”Ÿæˆå‚·æ‚£æ•¸æ“šä¸¦åŠ å…¥é™£åˆ—
                    const data = generateSurvivorData(inCar);
                    state.survivors.push({
                        x: sx, y: sy, found: false, triageTag: null, treatments: [], data: data,
                        // â˜…â˜…â˜… æ–°å¢ï¼šonAmbulance ç‹€æ…‹ï¼Œæ¨™è¨˜æ˜¯å¦å·²ä¸Šè»Š â˜…â˜…â˜…
                        tourniquetTimer: data.isBleeding ? 180 : null, isDead: false, isEvacuating: false, isBeingCarried: false, onAmbulance: false, trappedInVehicle: inCar ? car : null
                    });
                }
                // --- æ–°å¢ï¼šå–æ¶ˆåŠŸèƒ½çš„å…±ç”¨é‚è¼¯ ---
                const cancelAction = () => {
                    let performed = false;
                    if (selectedSlotRef.current !== -1) {
                        setSelectedSlot(-1);        // æ¸…é™¤é“å…·æ¬„é¸ä¸­ç‹€æ…‹
                        setShowTabletUI(false);     // é—œé–‰å¹³æ¿ UI
                        setShowRadioPanel(false); // é—œé–‰ç„¡ç·šé›»
                        setSelectedPatient(null);   // æ¸…é™¤å¹³æ¿é¸ä¸­çš„å‚·æ‚£
                        setShowMatSelector(false);  // é—œé–‰åœ°å¢Šé¸æ“‡å™¨

                        // å¼·åˆ¶é—œé–‰éŠæˆ²å…§çš„æ”¾ç½®æ¨¡å¼
                        state.placementMode.active = false;

                        // å¦‚æœæ˜¯ç„¡ç·šé›»é¸å–®ï¼Œä¹Ÿå¼·åˆ¶é—œé–‰
                        if (state.interactionMenu.mode === 'radio') {
                            state.interactionMenu.active = false;
                            state.interactionMenu.mode = 'main';
                        }

                        // â˜…â˜…â˜…æ”¹ç‚ºæ‰‹å‹•æ¨å…¥ feedbacks é™£åˆ—ï¼Œé¿å… addFeedback å°è‡´ç•¶æ©Ÿ â˜…â˜…â˜…
                        state.feedbacks.push({
                            x: state.player.x,
                            y: state.player.y - 50,
                            text: "å·²å–æ¶ˆé“å…·",
                            color: "#bdc3c7",
                            life: 60,
                            vy: -0.5
                        });
                        performed = true;
                    }
                    // â˜…â˜…â˜… æŒ‰ C æˆ–å³éµæ™‚é—œé–‰å¹³æ¿ â˜…â˜…â˜…
                    if (showTabletUI || showRadioPanel) { // åŠ å…¥ showRadioPanel åˆ¤æ–·
                        setShowTabletUI(false);
                        setShowRadioPanel(false); // é—œé–‰
                        setSelectedPatient(null);
                        if (!performed && selectedSlotRef.current === -1) {
                            setSelectedSlot(-1);
                        }
                        performed = true;
                    }
                    // 1. å–æ¶ˆæ”¾ç½®æ¨¡å¼
                    if (state.placementMode.active) {
                        state.placementMode.active = false;
                        setShowMatSelector(false); // ç¢ºä¿UIé—œé–‰
                        // â˜…â˜…â˜… æ‰‹å‹•æ¨å…¥ feedback â˜…â˜…â˜…
                        state.feedbacks.push({
                            x: state.player.x,
                            y: state.player.y - 50,
                            text: "å·²å–æ¶ˆè¨­ç½®",
                            color: "#bdc3c7",
                            life: 60,
                            vy: -0.5
                        });
                        performed = true;
                    }
                    // 2. é—œé–‰äº’å‹•é¸å–®
                    if (state.interactionMenu.active) {
                        state.interactionMenu.active = false;
                        state.interactionMenu.target = null;
                        state.interactionMenu.mode = 'main';
                        // é¿å…é‡è¤‡é¡¯ç¤ºæç¤º
                        if (!performed) {
                            // â˜…â˜…â˜… ä¿®æ­£ï¼šæ‰‹å‹•æ¨å…¥ feedback â˜…â˜…â˜…
                            state.feedbacks.push({
                                x: state.player.x,
                                y: state.player.y - 50,
                                text: "å·²é—œé–‰é¸å–®",
                                color: "#bdc3c7",
                                life: 60,
                                vy: -0.5
                            });
                        }
                    }
                    // 3. è£œå¼·ï¼šç¢ºä¿å¹³æ¿ UI é—œé–‰ (é‡å°éé“å…·é¸å–é–‹å•Ÿçš„æƒ…æ³ï¼Œè‹¥æœ‰çš„è©±)
                    if (showTabletUI) {
                        setShowTabletUI(false);
                        setSelectedPatient(null);
                        if (!performed && selectedSlotRef.current === -1) {
                            // åªæœ‰åœ¨é‚„æ²’è™•ç†éæ™‚æ‰åŸ·è¡Œï¼Œé¿å…è¡çª
                            setSelectedSlot(-1);
                        }
                    }
                };
                // --- æ–°å¢ï¼šæ»‘é¼ å³éµè™•ç† (å–æ¶ˆ) ---
                const handleContextMenu = (e) => {
                    e.preventDefault(); // é˜»æ­¢ç€è¦½å™¨é è¨­å³éµé¸å–®
                    if (state.isGameOver) return;
                    cancelAction();
                };
                cancelActionRef.current = cancelAction;
                const handleKeyDown = (e) => {
                    const state = gameState.current;
                    if (state.isGameOver) return;

                    const menu = state.interactionMenu;

                    // â˜…â˜…â˜… æ–°å¢ï¼šé¸å–®éµç›¤å°èˆªé‚è¼¯ â˜…â˜…â˜…
                    if (menu.active) {
                        // å®šç¾©å„æ¨¡å¼çš„é¸é …æ•¸é‡
                        const getOptionCount = (mode) => {
                            if (mode === 'main') return 2; // [æª¢å‚·, é†«ç™‚]
                            if (mode === 'triage') return 5; // [ç¶ , é»ƒ, ç´…, é»‘, é†«ç™‚]
                            if (mode === 'treatment') return 2; // [æ­¢è¡€, å‘¼å¸]
                            if (mode === 'radio') return 4; // [æ•‘è­·, æ¶ˆé˜², ç ´å£, æ¬é‹]
                            if (mode === 'hazard_fire') return 1;
                            if (mode === 'hazard_vehicle') return 1;
                            return 0;
                        };
                        const count = getOptionCount(menu.mode);

                        // è™•ç†æ–¹å‘éµ (æ”¯æ´ WASD èˆ‡ æ–¹å‘éµ)
                        let change = 0;
                        if (['ArrowLeft'].includes(e.key)) change = -1;
                        if (['ArrowRight'].includes(e.key)) change = 1;
                        if (['ArrowUp'].includes(e.key)) change = -1; // å‚ç›´é¸å–®å‘ä¸Š
                        if (['ArrowDown'].includes(e.key)) change = 1; // å‚ç›´é¸å–®å‘ä¸‹

                        if (change !== 0) {
                            menu.selectedIndex = (menu.selectedIndex + change + count) % count;
                            return; // é˜»æ­¢è§’è‰²ç§»å‹• (å› ç‚ºç¾åœ¨ WASD ä¸æœƒè®“ change è®Šå‹•ï¼Œæ‰€ä»¥ä¸æœƒåŸ·è¡Œé€™è¡Œï¼Œè§’è‰²å³å¯ç§»å‹•)
                        }

                        // æŒ‰ E éµç¢ºèªé¸æ“‡ (æ¨¡æ“¬é»æ“Šè©²é¸é …çš„ä½ç½®)
                        if (e.key === 'e' || e.key === 'E' || e.key === 'Enter') {
                            let targetX = menu.x, targetY = menu.y;
                            const mx = menu.x - 40, my = menu.y - 60;

                            // æ ¹æ“šç•¶å‰æ¨¡å¼èˆ‡ selectedIndex è¨ˆç®—æ¨¡æ“¬é»æ“Šåº§æ¨™
                            if (menu.mode === 'main') {
                                if (menu.selectedIndex === 0) { targetX = mx + 20; targetY = my + 20; }
                                else { targetX = mx + 65; targetY = my + 20; }
                            }
                            else if (menu.mode === 'triage') {
                                if (menu.selectedIndex === 4) { // å³å´é†«ç™‚æŒ‰éˆ•
                                    targetX = mx + 65; targetY = my + 20;
                                } else { // 2x2 Grid
                                    const startX = mx - 25; const startY = my - 12;
                                    const btnW = 30, btnH = 30, gap = 5;
                                    const col = menu.selectedIndex % 2;
                                    const row = Math.floor(menu.selectedIndex / 2);
                                    targetX = startX + col * (btnW + gap) + btnW / 2;
                                    targetY = startY + row * (btnH + gap) + btnH / 2;
                                }
                            }
                            else if (menu.mode === 'treatment') {
                                if (menu.selectedIndex === 0) { targetX = mx + 40; targetY = my + 2.5; }
                                else { targetX = mx + 40; targetY = my + 32.5; }
                            }
                            else if (menu.mode === 'radio') {
                                const radioX = menu.x - 50; const radioY = menu.y - 120;
                                const btnH = 25, gap = 5;
                                const row = menu.selectedIndex;
                                targetX = radioX + 50;
                                targetY = (radioY + gap) + row * (btnH + gap) + btnH / 2;
                            }
                            else if (['hazard_fire', 'hazard_vehicle'].includes(menu.mode)) {
                                targetX = mx + 40; targetY = my + 20;
                            }

                            // åŸ·è¡Œæ¨¡æ“¬é»æ“Š
                            const rect = canvasRef.current.getBoundingClientRect();
                            const scaleX = canvasRef.current.width / rect.width;
                            const scaleY = canvasRef.current.height / rect.height;
                            const clientX = ((targetX - state.camera.x) / scaleX) + rect.left;
                            const clientY = ((targetY - state.camera.y) / scaleY) + rect.top;

                            handleCanvasClick({ clientX, clientY, preventDefault: () => { } });
                            return;
                        }
                    }

                    // ... (ä¿ç•™åŸæœ‰çš„å…¶ä»–æŒ‰éµé‚è¼¯ï¼Œå¦‚ C, I ç­‰) ...
                    if (e.key >= '1' && e.key <= '9') handleSlotClick(parseInt(e.key) - 1);
                    else if (e.key === '0') handleSlotClick(9);
                    if (e.key === 'c' || e.key === 'C') { cancelAction(); }
                    if (e.key === 'i' || e.key === 'I') { setShowInventory(prev => !prev); }

                    if (e.key === 'w' || e.key === 'ArrowUp') state.keys.w = true;
                    if (e.key === 's' || e.key === 'ArrowDown') state.keys.s = true;
                    if (e.key === 'a' || e.key === 'ArrowLeft') state.keys.a = true;
                    if (e.key === 'd' || e.key === 'ArrowRight') state.keys.d = true;

                    // --- æŒ‰ä¸‹ E éµäº’å‹• (åƒ…ç•¶é¸å–®æœªé–‹å•Ÿæ™‚) ---
                    if ((e.key === 'e' || e.key === 'E') && !menu.active) {
                        // ... (ä¿ç•™åŸæœ‰çš„ E éµäº’å‹•æœå°‹é‚è¼¯) ...
                        const p = state.player;
                        let targetX = p.x;
                        let targetY = p.y;

                        // 1. æ”¾ç½®æ¨¡å¼
                        if (state.placementMode.active) {
                            targetX = state.placementMode.x + state.placementMode.w / 2;
                            targetY = state.placementMode.y + state.placementMode.h / 2;
                        }
                        // 2. ä¸€èˆ¬æ¨¡å¼
                        else {
                            const interactRadius = 80;
                            let minDist = Infinity;
                            let bestTarget = null;

                            // (A) æª¢æŸ¥ç«ç„°
                            state.hazards.forEach(h => {
                                if (!h.beingExtinguished) {
                                    const dist = Math.hypot(p.x - h.x, p.y - h.y);
                                    if (dist < interactRadius + 20 && dist < minDist) {
                                        minDist = dist; bestTarget = { x: h.x, y: h.y };
                                    }
                                }
                            });
                            // (B) æª¢æŸ¥è»Šè¼›
                            if (!bestTarget) {
                                state.obstacles.forEach(o => {
                                    if (['sedan', 'truck'].includes(o.type)) {
                                        const cx = o.x + o.w / 2; const cy = o.y + o.h / 2;
                                        const dist = Math.hypot(p.x - cx, p.y - cy);
                                        const survivorInside = state.survivors.find(s => s.trappedInVehicle === o);
                                        if (dist < interactRadius + 20 && survivorInside && !o.isBreached && o.breakTimer === 0) {
                                            if (dist < minDist) { minDist = dist; bestTarget = { x: cx, y: cy }; }
                                        }
                                    }
                                });
                            }
                            // (C) æª¢æŸ¥å‚·æ‚£
                            if (!bestTarget) {
                                state.survivors.forEach(s => {
                                    if ((s.trappedInVehicle && !s.trappedInVehicle.isBreached) || s.isEvacuating || s.isBeingCarried || s.onAmbulance) return;
                                    const dist = Math.hypot(p.x - s.x, p.y - s.y);
                                    if (dist < interactRadius && dist < minDist) {
                                        minDist = dist; bestTarget = { x: s.x, y: s.y };
                                    }
                                });
                            }
                            if (bestTarget) { targetX = bestTarget.x; targetY = bestTarget.y; }
                        }

                        // åŸ·è¡Œæ¨¡æ“¬é»æ“Šä¾†é–‹å•Ÿé¸å–®
                        const rect = canvasRef.current.getBoundingClientRect();
                        const scaleX = canvasRef.current.width / rect.width;
                        const scaleY = canvasRef.current.height / rect.height;
                        const clientX = ((targetX - state.camera.x) / scaleX) + rect.left;
                        const clientY = ((targetY - state.camera.y) / scaleY) + rect.top;

                        handleCanvasClick({ clientX, clientY, preventDefault: () => { } });
                    }
                };

                const handleKeyUp = (e) => {
                    if (state.isGameOver) return;
                    if (e.key === 'w' || e.key === 'ArrowUp') state.keys.w = false;
                    if (e.key === 's' || e.key === 'ArrowDown') state.keys.s = false;
                    if (e.key === 'a' || e.key === 'ArrowLeft') state.keys.a = false;
                    if (e.key === 'd' || e.key === 'ArrowRight') state.keys.d = false;
                };

                const handleMouseMove = (e) => {

                };

                const handleCanvasClick = (e) => {
                    if (state.isGameOver) return;

                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const screenClickX = (e.clientX - rect.left) * scaleX;
                    const screenClickY = (e.clientY - rect.top) * scaleY;
                    const clickX = screenClickX + state.camera.x;
                    const clickY = screenClickY + state.camera.y;
                    const player = state.player;
                    const menu = state.interactionMenu;
                    // â˜…â˜…â˜… ä¿®æ­£ 1: ä½¿ç”¨ Ref å–å¾—æœ€æ–°çš„ selectedSlot â˜…â˜…â˜…
                    const currentSlot = selectedSlotRef.current;

                    if (state.placementMode.active) {
                        if (state.placementMode.valid) {
                            state.triageMats.push({
                                x: state.placementMode.x,
                                y: state.placementMode.y,
                                w: state.placementMode.w,
                                h: state.placementMode.h,
                                color: state.placementMode.color
                            });
                            addFeedback(state.placementMode.x + state.placementMode.w / 2, state.placementMode.y, "åœ°å¢Šæ”¾ç½®å®Œæˆ", "#fff");
                            state.placementMode.active = false;
                        } else {
                            addFeedback(clickX, clickY, "ç„¡æ³•æ”¾ç½®æ–¼æ­¤", "#e74c3c");
                        }
                        return;
                    }
                    // --- æ–°å¢ï¼šå·¥å…·ä½¿ç”¨é‚è¼¯ (åœ¨é¸å–®åˆ¤å®šä¹‹å‰) ---
                    if (currentSlot !== -1) {
                        const item = items[currentSlot];
                        if (item && (item.type === 'breaker_tool' || item.type === 'extinguisher_tool')) {
                            // 1. ç ´å£å™¨æ (MP-10)
                            if (item.type === 'breaker_tool') {
                                for (let o of state.obstacles) {
                                    if (['sedan', 'truck'].includes(o.type)) {
                                        // æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨è»Šè¼›ç¯„åœå…§
                                        if (clickX > o.x && clickX < o.x + o.w && clickY > o.y && clickY < o.y + o.h) {
                                            if (state.rescueSquads.length > 0) {
                                                addFeedback(clickX, clickY, "ç ´å£å°çµ„å¿™ç¢Œä¸­", "#e74c3c");
                                                return;
                                            }
                                            if (!o.isBreached && o.breakTimer === 0) {
                                                if (state.stats.mp >= 10) {
                                                    state.stats.mp -= 10;
                                                    // æ´¾é£ç ´å£å°çµ„ (é‚è¼¯åŒ Radio)
                                                    state.rescueSquads.push({
                                                        x: 50 + 700, y: 540 / 2 - 100, target: o, state: 'moving_to_vehicle'
                                                    });
                                                    addFeedback(o.x + o.w / 2, o.y, "æ´¾é£ç ´å£å°çµ„ (-10 MP)", "#e67e22");
                                                } else {
                                                    addFeedback(clickX, clickY, "MPä¸è¶³ (éœ€ 10)", "#e74c3c");
                                                }
                                            } else {
                                                addFeedback(clickX, clickY, "ç„¡éœ€/ç„¡æ³•ç ´å£", "#bdc3c7");
                                            }
                                            return; // é˜»æ­¢å¾ŒçºŒåˆ¤å®š
                                        }
                                    }
                                }
                            }
                            // 2. æ»…ç«å™¨ (MP-10)
                            if (item.type === 'extinguisher_tool') {
                                for (let h of state.hazards) {
                                    const dist = Math.hypot(clickX - h.x, clickY - h.y);
                                    if (dist < h.r) {
                                        if (!h.beingExtinguished) {
                                            if (state.stats.mp >= 10) {
                                                state.stats.mp -= 10;
                                                h.beingExtinguished = true;
                                                // æ´¾é£æ¶ˆé˜²å“¡
                                                state.firefightingSquads.push({
                                                    x: 0, y: 600, target: h, state: 'moving_to_fire'
                                                });
                                                addFeedback(h.x, h.y, "æ´¾é£æ»…ç« (-10 MP)", "#3498db");
                                            } else {
                                                addFeedback(clickX, clickY, "MPä¸è¶³ (éœ€ 10)", "#e74c3c");
                                            }
                                        } else {
                                            addFeedback(h.x, h.y, "æ­£åœ¨æ»…ç«ä¸­", "#bdc3c7");
                                        }
                                        return; // é˜»æ­¢å¾ŒçºŒåˆ¤å®š
                                    }
                                }
                            }
                        }
                    }
                    if (menu.active) {
                        const menuX = menu.x - 40; const menuY = menu.y - 60;

                        if (menu.mode === 'main') {
                            if (clickX >= menuX && clickX <= menuX + 40 && clickY >= menuY && clickY <= menuY + 40) {
                                menu.mode = 'triage'; return;
                            }
                            if (clickX >= menuX + 45 && clickX <= menuX + 85 && clickY >= menuY && clickY <= menuY + 40) {
                                menu.mode = 'treatment'; return;
                            }
                        }
                        else if (menu.mode === 'triage') {
                            const colors = ['green', 'yellow', 'red', 'black'];
                            // å®šç¾© 2x2 æŒ‰éˆ•åƒæ•¸
                            const btnW = 30;
                            const btnH = 30;
                            const gap = 5;
                            // è®“é¸å–®ç¨å¾®å¾€å³ç§»ä¸€é»ï¼Œé¿å…é®æ“‹
                            const startX = menuX - 25;
                            const startY = menuY - 12;

                            // --- æ–°å¢ï¼šæª¢æŸ¥æ˜¯å¦é»æ“Šäº†å³å´çš„ã€Œæ€¥æ•‘æŒ‰éˆ•ã€ ---
                            // ä½ç½®èˆ‡ Main æ¨¡å¼ä¸‹çš„å³å´æŒ‰éˆ•ç›¸åŒ (menuX + 45)
                            if (clickX >= menuX + 45 && clickX <= menuX + 85 && clickY >= menuY && clickY <= menuY + 40) {
                                menu.mode = 'treatment';
                                return;
                            }
                            for (let i = 0; i < 4; i++) {
                                // è¨ˆç®— 2x2 ä½ç½®: 0,1ç¬¬ä¸€åˆ—; 2,3ç¬¬äºŒåˆ—
                                let col = i % 2;
                                let row = Math.floor(i / 2);

                                let btnX = startX + col * (btnW + gap);
                                let btnY = startY + row * (btnH + gap);

                                if (clickX >= btnX && clickX <= btnX + btnW && clickY >= btnY && clickY <= btnY + btnH) {
                                    if (menu.target) {
                                        menu.target.triageTag = colors[i];
                                        menu.target.found = true;
                                        menu.target.hasArrived = false; // é‡ç½®æŠµé”ç‹€æ…‹ï¼Œè®“å‚·æ‚£èƒ½å†æ¬¡è¢«æ¬é‹æˆ–ç§»å‹•
                                        menu.target.isEvacuating = false; // é‡ç½®ç§»å‹•ç‹€æ…‹ (é¿å…å¾ç¶ å¡è½‰ç´…å¡æ™‚ä»ç¹¼çºŒè‡ªè¡Œç§»å‹•) 
                                        state.survivorsFoundCount = state.survivors.filter(s => s.found).length;
                                        setSurvivorCount(state.survivorsFoundCount);
                                        // æ¯”å°å‚·æ‚£å¯¦éš›å‚·æƒ… (data.severity) èˆ‡é¸æ“‡çš„é¡è‰² (colors[i])
                                        if (menu.target.data.severity === colors[i]) {
                                            if (!menu.target.hasBeenScored) {
                                                setScore(prev => prev + 100);
                                                addFeedback(menu.x, menu.y - 50, "æª¢å‚·æ­£ç¢º +100", "#f1c40f");
                                                menu.target.hasBeenScored = true; // æ¨™è¨˜æ­¤å‚·æ‚£å·²ç²å¾—åˆ†æ•¸
                                            }
                                        } else {
                                            // (é¸å¡«) è‹¥éœ€è¦é¡¯ç¤ºéŒ¯èª¤æç¤ºå¯åŠ åœ¨é€™
                                            // addFeedback(menu.x, menu.y - 50, "åˆ¤æ–·éŒ¯èª¤", "#95a5a6");
                                        }
                                        addFeedback(menu.x, menu.y, "æª¢å‚·å®Œæˆ", colors[i] === 'black' ? '#999' : colors[i]);

                                        // --- é–‹å§‹ï¼šæª¢æŸ¥å¯¦éš›å‚·æƒ… ---
                                        if (colors[i] === 'green') {
                                            // åªæœ‰ç©å®¶åˆ¤å®šç‚ºç¶ è‰² ä¸” å¯¦éš›å‚·æƒ…(data.severity)ä¹Ÿæ˜¯ç¶ è‰²ï¼Œæ‰æœƒç§»å‹•
                                            if (menu.target.data.severity === 'green') {
                                                menu.target.isEvacuating = true;
                                                addFeedback(menu.x, menu.y - 20, "å‚·æ‚£è‡ªè¡Œç§»å‹•ä¸­...", "#2ecc71");
                                            } else {
                                                // ç©å®¶åˆ¤æ–·ç‚ºè¼•å‚·ï¼Œä½†å¯¦éš›å‚·å‹¢è¼ƒé‡ -> ç„¡æ³•ç§»å‹•
                                                addFeedback(menu.x, menu.y - 20, "å‚·å‹¢éé‡ç„¡æ³•ç§»å‹•", "#e74c3c");
                                            }
                                        }
                                        // æª¢å‚·å®Œæˆå¾Œç«‹å³æª¢æŸ¥è¨ˆæ•¸
                                        checkTriageCounts();
                                    }
                                    menu.active = false; menu.mode = 'main'; return;
                                }
                            }
                        }
                        else if (menu.mode === 'treatment') {
                            if (clickX >= menuX - 20 && clickX <= menuX + 100 && clickY >= menuY - 50 && clickY <= menuY + 25) {
                                statsTracker.current.tourniquet.total++; // ç¸½å˜—è©¦æ¬¡æ•¸
                                if (menu.target && menu.target.data) {
                                    if (menu.target.data.isBleeding && !menu.target.isDead) {
                                        setScore(prev => prev + 100);
                                        addFeedback(menu.x, menu.y - 40, "æ­¢è¡€æ­£ç¢º +100", "#f1c40f");
                                        menu.target.data.isBleeding = false;
                                        menu.target.tourniquetTimer = null;
                                        addFeedback(menu.x, menu.y, "æ­¢è¡€æˆåŠŸ", "#2ecc71");
                                    } else {
                                        addFeedback(menu.x, menu.y, "ç„¡éœ€/ç„¡æ³•æ­¢è¡€", "#bdc3c7");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                            if (clickX >= menuX - 20 && clickX <= menuX + 100 && clickY >= menuY + 20 && clickY <= menuY + 45) {
                                statsTracker.current.airway.total++; // ç¸½å˜—è©¦æ¬¡æ•¸
                                if (menu.target && menu.target.data) {
                                    if (menu.target.isDead) {
                                        addFeedback(menu.x, menu.y, "å·²æ­»äº¡ (ç„¡æ•ˆ)", "#7f8c8d");
                                    }
                                    if (menu.target.data.resp === 'ç„¡') {
                                        setScore(prev => prev + 100);
                                        if (Math.random() > 0.5) {
                                            menu.target.data.resp = 'æ¢å¾© (å¾®å¼±)';
                                            menu.target.data.severity = 'red';
                                            menu.target.data.injuryText = 'æ°£é“é˜»å¡è§£é™¤';
                                            menu.target.triageTag = null;
                                            addFeedback(menu.x, menu.y, "æ¢å¾©å‘¼å¸!", "#2ecc71");
                                        } else {
                                            addFeedback(menu.x, menu.y, "ç„¡æ•ˆ (ä»ç„¡å‘¼å¸)", "#bdc3c7");
                                        }
                                    } else {
                                        addFeedback(menu.x, menu.y, "å‘¼å¸é“æš¢é€š", "#3498db");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }
                        else if (menu.mode === 'hazard_fire') {
                            if (clickX >= menuX - 10 && clickX <= menuX + 90 && clickY >= menuY && clickY <= menuY + 40) {
                                if (state.firefightingSquads.length > 0) {
                                    addFeedback(menu.x, menu.y, "æ¶ˆé˜²éšŠå¿™ç¢Œä¸­", "#e74c3c");
                                    menu.active = false; menu.mode = 'main'; return;
                                }
                                if (!menu.target.beingExtinguished) {
                                    menu.target.beingExtinguished = true;
                                    state.firefightingSquads.push({
                                        x: 0, y: 600, target: menu.target, state: 'moving_to_fire'
                                    });
                                    addFeedback(menu.x, menu.y, "è«‹æ±‚æ»…ç«æ”¯æ´...", "#3498db");
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }
                        else if (menu.mode === 'hazard_vehicle') {
                            if (clickX >= menuX - 10 && clickX <= menuX + 90 && clickY >= menuY && clickY <= menuY + 40) {
                                if (state.rescueSquads.length > 0) {
                                    addFeedback(menu.x, menu.y, "ç ´å£å°çµ„å¿™ç¢Œä¸­", "#e74c3c");
                                    menu.active = false; menu.mode = 'main'; return;
                                }
                                if (!menu.target.isBreached && menu.target.breakTimer === 0) {
                                    // ä¿®æ”¹: æª¢æŸ¥æ˜¯å¦å·²æœ‰å°çµ„ï¼Œè‹¥ç„¡å‰‡æ´¾é£
                                    const alreadyDispatched = state.rescueSquads.some(s => s.target === menu.target);
                                    if (!alreadyDispatched) {
                                        state.rescueSquads.push({
                                            // å¾æ¶ˆé˜²è»Šä½ç½®é™„è¿‘å‡ºç™¼ (åŠ ä¸Šåç§»é‡)
                                            x: 50 + 700,
                                            y: 540 / 2 - 100,
                                            target: menu.target,
                                            state: 'moving_to_vehicle'
                                        });
                                        addFeedback(menu.x, menu.y, "ç ´å£å™¨æå°çµ„å‡ºå‹•!", "#e67e22");
                                    } else {
                                        addFeedback(menu.x, menu.y, "æ”¯æ´å·²åœ¨é€”ä¸­", "#f1c40f");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }
                        // --- æ–°å¢ï¼šç„¡ç·šé›»é¸å–®è™•ç† (åœ¨ interactionMenu.active å…§) ---
                        else if (menu.mode === 'radio') {
                            const radioX = menu.x - 50;
                            const radioY = menu.y - 120;
                            const menuW = 100;
                            const menuH = 130;
                            const btnH = 25;
                            const gap = 5;
                            const btnW = menuW - 10;
                            const startX = radioX + 5;

                            // ç¹ªè£½èƒŒæ™¯ (ç‚ºäº†åˆ¤æ–·é»æ“Šç¯„åœ)
                            // drawRoundedRect(mx, my, 100, 100, 5, 'rgba(0,0,0,0.85)');
                            // ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; ctx.strokeRect(mx, my, 100, 100);
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.font = 'bold 12px "Segoe UI"';
                            // 1. è«‹æ±‚æ•‘è­·è»Š (æ‰£ MP 10)
                            if (clickX >= startX && clickX <= startX + btnW && clickY >= startY && clickY <= startY + btnH) {
                                // â˜…â˜…â˜… æ–°å¢ï¼šæª¢æŸ¥å†·å»æ™‚é–“ â˜…â˜…â˜…
                                if (state.ambulanceCooldown > 0) {
                                    addFeedback(menu.x, menu.y, `èª¿åº¦å†·å»ä¸­ (${Math.ceil(state.ambulanceCooldown / 60)}s)`, "#bdc3c7");
                                    return; // ç›´æ¥çµæŸï¼Œä¸åŸ·è¡Œå¾ŒçºŒ
                                }
                                const stagingArea = state.triageMats.find(m => m.color === 'ambulance_staging');
                                if (!stagingArea) {
                                    // è‹¥æœªè¨­ç½®ï¼Œé¡¯ç¤ºæç¤ºä¸¦ä¸æ‰£ MP
                                    addFeedback(menu.x, menu.y, "ç„¡è¨­ç½®æ•‘è­·è»Šå¾…å‘½å€", "#e74c3c");
                                } else {
                                    if (state.stats.mp >= 10) {
                                        state.stats.mp = Math.max(0, state.stats.mp - 10);
                                        // â˜…â˜…â˜… ä¿®æ­£ï¼šåŠ å…¥é€™è¡Œè¨­å®š 30 ç§’å†·å» (60 FPS * 30 = 1800) â˜…â˜…â˜…
                                        state.ambulanceCooldown = 1500;
                                        // éš¨æ©Ÿç”¢ç”Ÿ 1~3 å°æ•‘è­·è»Š
                                        const ambCount = Math.floor(Math.random() * 3) + 1;
                                        for (let k = 0; k < ambCount; k++) {
                                            // åœ¨å¾…å‘½å€ç¯„åœå…§éš¨æ©Ÿç”Ÿæˆä½ç½® (ç¨å¾®ä¿ç•™é‚Šè·)
                                            const ax = stagingArea.x + 10 + Math.random() * (stagingArea.w - 90);
                                            const ay = stagingArea.y + 10 + Math.random() * (stagingArea.h - 60);
                                            const aw = 80;
                                            const ah = 40;
                                            // åŠ å…¥è¦–è¦ºç‰©ä»¶
                                            // â˜…â˜…â˜… ä¿®æ”¹ï¼šç„¡ç·šé›»ç”Ÿæˆçš„æ•‘è­·è»ŠåŠ å…¥ passengers èˆ‡ ID â˜…â˜…â˜…
                                            // â˜…â˜…â˜… ä¿®æ”¹ï¼šå¾ç•«é¢å·¦å´ç”Ÿæˆï¼Œç‹€æ…‹è¨­ç‚º 'arriving' â˜…â˜…â˜…
                                            // â˜…â˜…â˜… ä¿®æ”¹ï¼šä¿®æ­£è®Šæ•¸éŒ¯èª¤ï¼Œä½¿ç”¨ ax, ay ä½œç‚ºç›®æ¨™ â˜…â˜…â˜…
                                            state.emergencyVehicles.push({
                                                id: Math.random(),
                                                type: 'ambulance',
                                                passengers: [],
                                                state: 'arriving', // è¨­å®šç‚ºé€²å ´ä¸­
                                                x: state.camera.x - 150 - (k * 100), // å¾ç•«é¢å·¦é‚Šå¤–å´ç”Ÿæˆï¼Œå¤šå°æ™‚ç¨å¾®éŒ¯é–‹
                                                y: ay, // ä¿®æ­£ï¼šä½¿ç”¨ ay ä½œç‚ºå‚ç›´ä½ç½®
                                                targetX: ax, // ä¿®æ­£ï¼šä½¿ç”¨ ax ä½œç‚ºç›®æ¨™ X
                                                targetY: ay, // ä¿®æ­£ï¼šä½¿ç”¨ ay ä½œç‚ºç›®æ¨™ Y
                                                w: aw,
                                                h: ah,
                                                angle: 0 // é€²å ´æ™‚è§’åº¦æ­¸é›¶
                                            });




                                        }
                                        addFeedback(menu.x, menu.y - 70, "-10 MP (æ•‘è­·è»Š)", "#3498db");
                                        addFeedback(menu.x, menu.y, "æ•‘è­·è»Šè¶•å¾€ä¸­...", "#3498db");
                                    } else {
                                        addFeedback(menu.x, menu.y, "MPä¸è¶³!", "#e74c3c");
                                    }
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }

                            // 2. è«‹æ±‚æ¶ˆé˜²è»Š (æ‰£ MP 10)
                            if (clickX >= startX && clickX <= startX + btnW && clickY >= startY + btnH + gap && clickY <= startY + btnH * 2 + gap) {
                                // æœå°‹ä¸€å€‹æœªè¢«æ»…ç«çš„ç«ç„°
                                const target = state.hazards.find(h => !h.beingExtinguished);
                                if (target) {
                                    if (state.stats.mp >= 10) {
                                        state.stats.mp = Math.max(0, state.stats.mp - 10);
                                        target.beingExtinguished = true;
                                        // æ´¾é£æ¶ˆé˜²å“¡ (å¾å·¦å´æ“´å¼µå€å‡ºç™¼)
                                        state.firefightingSquads.push({
                                            x: 50 + 700, y: 540 / 2 - 150, target: target, state: 'moving_to_fire'
                                        });
                                        addFeedback(menu.x, menu.y - 70, "-10 MP (æ¶ˆé˜²è»Š)", "#3498db");
                                        addFeedback(menu.x, menu.y, "æ´¾é£æ¶ˆé˜²è»Šæ”¯æ´", "#e74c3c");
                                    } else {
                                        addFeedback(menu.x, menu.y, "MPä¸è¶³!", "#e74c3c");
                                    }
                                } else {
                                    addFeedback(menu.x, menu.y, "ç›®å‰ç„¡ç«ç½éœ€è™•ç†", "#2ecc71");
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                            // 3. è«‹æ±‚ç ´å£å°çµ„ (æ‰£ MP 10)
                            if (clickX >= startX && clickX <= startX + btnW && clickY >= startY + btnH * 2 + gap * 2 && clickY <= startY + btnH * 3 + gap * 2) {
                                // æœå°‹ä¸€å€‹: æ˜¯è»Šè¼› + æœªç ´å£ + å…§æœ‰å‚·æ‚£ + å°šæœªæœ‰å°çµ„å‰å¾€
                                const target = state.obstacles.find(o =>
                                    ['sedan', 'truck'].includes(o.type) &&
                                    !o.isBreached &&
                                    o.breakTimer === 0 &&
                                    state.survivors.some(s => s.trappedInVehicle === o) &&
                                    !state.rescueSquads.some(sq => sq.target === o)
                                );

                                if (target) {
                                    if (state.stats.mp >= 10) {
                                        state.stats.mp = Math.max(0, state.stats.mp - 10);
                                        // æ´¾é£ç ´å£å°çµ„
                                        state.rescueSquads.push({
                                            x: 50 + 700, y: 540 / 2 - 100, target: target, state: 'moving_to_vehicle'
                                        });
                                        addFeedback(menu.x, menu.y - 70, "-10 MP (ç ´å£å°çµ„)", "#3498db");
                                        addFeedback(menu.x, menu.y, "æ´¾é£ç ´å£å°çµ„", "#e67e22");
                                    } else {
                                        addFeedback(menu.x, menu.y, "MPä¸è¶³!", "#e74c3c");
                                    }
                                } else {
                                    addFeedback(menu.x, menu.y, "ç„¡å—å›°è»Šè¼›éœ€è™•ç†", "#bdc3c7");
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                            // â˜…â˜…â˜… æ–°å¢ï¼š4. è«‹æ±‚æ¬é‹äººå“¡ (æ‰£ MP 10) â˜…â˜…â˜…
                            // Yè»¸ä½ç½®ï¼šå¾ç¬¬3å€‹æŒ‰éˆ•ä¸‹æ–¹é–‹å§‹ (btnH * 3 + gap * 3)
                            if (clickX >= startX && clickX <= startX + btnW && clickY >= startY + btnH * 3 + gap * 3 && clickY <= startY + btnH * 4 + gap * 3) {
                                // é™åˆ¶ï¼šæœ€å¤š 2 çµ„ (è‡ªå‹•ç”Ÿæˆçš„ä¹Ÿæœƒç®—åœ¨å…§)
                                if (state.npcGroups.length >= 2) {
                                    addFeedback(menu.x, menu.y, "æ¬é‹äººåŠ›å·²é”ä¸Šé™ (2çµ„)", "#e74c3c");
                                    menu.active = false; menu.mode = 'main'; return;
                                }
                                // æœå°‹ä¸€å€‹ï¼šå·²æª¢å‚·(ç´…é»ƒé»‘) + æœªç§»å‹• + æœªæŠµé” + ç„¡äººæ¬é‹ + ç„¡å—å›°/å·²ç ´å£ + å®‰å…¨(ç„¡ç«)
                                const unassignedTargets = state.survivors.filter(s =>
                                    s.triageTag &&
                                    ['red', 'yellow', 'black'].includes(s.triageTag) &&
                                    !s.isEvacuating &&
                                    !s.hasArrived &&
                                    !s.isBeingCarried &&
                                    !state.npcGroups.some(g => g.target === s) &&
                                    (!s.trappedInVehicle || s.trappedInVehicle.isBreached) &&
                                    !state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30)
                                );
                                if (unassignedTargets.length > 0) {
                                    if (state.stats.mp >= 10) {
                                        state.stats.mp = Math.max(0, state.stats.mp - 10);

                                        // å„ªå…ˆé †åºæ’åº (é»‘ > ç´… > é»ƒ)
                                        unassignedTargets.sort((a, b) => {
                                            const p = { 'black': 3, 'red': 2, 'yellow': 1 };
                                            return p[b.triageTag] - p[a.triageTag];
                                        });
                                        const target = unassignedTargets[0];

                                        // æ´¾é£æ¬é‹å°çµ„ (å¾å·¦å´å‡ºç¾)
                                        state.npcGroups.push({
                                            leaderX: 20 + 700, leaderY: 600,
                                            followerX: 0 + 700, followerY: 600,
                                            target: target,
                                            state: 'moving_to_target',
                                            carrying: false
                                        });

                                        addFeedback(menu.x, menu.y - 70, "-10 MP (æ¬é‹äººå“¡)", "#3498db");
                                        addFeedback(menu.x, menu.y, "å¢æ´¾æ¬é‹äººå“¡æ”¯æ´", "#9b59b6");
                                    } else {
                                        addFeedback(menu.x, menu.y, "MPä¸è¶³!", "#e74c3c");
                                    }
                                } else {
                                    addFeedback(menu.x, menu.y, "ç›®å‰ç„¡å‚·æ‚£éœ€æ¬é‹", "#bdc3c7");
                                }
                                menu.active = false; menu.mode = 'main'; return;
                            }
                        }
                        // å¦‚æœé»æ“Šäº†é¸å–®ä»¥å¤–çš„åœ°æ–¹...
                        if (clickX < radioX || clickX > radioX + menuW || clickY < radioY || clickY > radioY + menuH) {
                            menu.active = false; menu.mode = 'main'; return;
                        }

                    }



                    const interactRadius = 60;
                    let clickedSomething = false;

                    // æª¢æŸ¥ç«ç„°
                    if (!clickedSomething) {
                        for (let h of state.hazards) {
                            const dist = Math.hypot(clickX - h.x, clickY - h.y);
                            if (dist < h.r) {
                                clickedSomething = true;
                                const distToPlayer = Math.hypot(player.x - h.x, player.y - h.y);
                                if (distToPlayer < interactRadius + 50) {
                                    menu.active = true; menu.mode = 'hazard_fire';
                                    menu.x = h.x; menu.y = h.y; menu.target = h;
                                    menu.selectedIndex = 0;
                                } else {
                                    addFeedback(h.x, h.y, "å¤ªé äº†!", "#e74c3c");
                                }
                                return;
                            }
                        }
                    }

                    // æª¢æŸ¥è»Šè¼›
                    if (!clickedSomething) {
                        for (let o of state.obstacles) {
                            // æ’é™¤éè»Šè¼›çš„éšœç¤™ç‰©
                            if (o.type !== 'guardrail' && o.type !== 'wall' && o.type !== 'vehicle_block' && o.type !== 'metal_debris') {
                                // æª¢æŸ¥é»æ“Šåº§æ¨™æ˜¯å¦åœ¨è»Šè¼›ç¯„åœå…§
                                if (clickX > o.x && clickX < o.x + o.w && clickY > o.y && clickY < o.y + o.h) {

                                    // â˜…â˜…â˜… ä¿®æ”¹é‡é»ï¼šæª¢æŸ¥äº’å‹•æœ‰æ•ˆæ€§ â˜…â˜…â˜…
                                    const survivorInside = state.survivors.find(s => s.trappedInVehicle === o);

                                    // å¦‚æœã€Œè»Šé«”å·²ç ´å£ã€æˆ–ã€Œè»Šå…§ç„¡å‚·æ‚£å—å›°ã€ï¼Œå‰‡è¦–ç‚ºç„¡äº’å‹•ç›®æ¨™
                                    // ä½¿ç”¨ continue è·³éï¼Œè®“é»æ“Šäº‹ä»¶å¯ä»¥ç©¿é€è»Šè¼›ï¼Œè¢«å¾ŒçºŒçš„å‚·æ‚£åµæ¸¬æ•æ‰
                                    if (o.isBreached || !survivorInside) {
                                        continue;
                                    }

                                    // --- åªæœ‰ã€Œæœªç ´å£ã€ä¸”ã€Œæœ‰äººå—å›°ã€çš„è»Šè¼›ï¼Œæ‰æ””æˆªé»æ“Š ---
                                    clickedSomething = true;
                                    const distToPlayer = Math.hypot(player.x - (o.x + o.w / 2), player.y - (o.y + o.h / 2));

                                    if (distToPlayer < interactRadius + 40) {
                                        // è·é›¢è¶³å¤ ï¼Œé–‹å•Ÿäº’å‹•é¸å–®
                                        menu.active = true;
                                        menu.mode = 'hazard_vehicle';
                                        menu.x = o.x + o.w / 2;
                                        menu.y = o.y;
                                        menu.target = o;
                                        menu.selectedIndex = 0;
                                    } else {
                                        // è·é›¢å¤ªé çš„æç¤º
                                        addFeedback(o.x + o.w / 2, o.y, "é è¿‘æŸ¥çœ‹", "#e74c3c");
                                    }
                                    return; // æ””æˆªé»æ“Šï¼Œä¸å†å¾€ä¸‹æª¢æŸ¥å‚·æ‚£
                                }
                            }
                        }
                    }


                    // æª¢æŸ¥å‚·æ‚£
                    for (let s of state.survivors) {
                        const dist = Math.hypot(clickX - s.x, clickY - s.y);
                        if (dist < 25) {
                            clickedSomething = true;
                            let blockedByFire = state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30);
                            if (blockedByFire) { addFeedback(s.x, s.y, "å‰æ–¹æœ‰ç«!", "#e74c3c"); return; }

                            if (s.trappedInVehicle && !s.trappedInVehicle.isBreached) { addFeedback(s.x, s.y, "å—å›°è»Šå…§!", "#e74c3c"); return; }

                            const distToPlayer = Math.hypot(player.x - s.x, player.y - s.y);
                            if (distToPlayer < interactRadius) {
                                menu.active = true; menu.mode = 'main';
                                menu.x = s.x; menu.y = s.y; menu.target = s;
                                menu.selectedIndex = 0;
                            } else {
                                addFeedback(s.x, s.y, "å¤ªé äº†!", "#e74c3c");
                            }
                            return;
                        }
                    }

                    if (!clickedSomething && !state.placementMode.active) {
                        addFeedback(clickX, clickY, "â—", "rgba(255,255,255,0.5)");
                        player.targetX = clickX;
                        player.targetY = clickY;
                        player.movingToTarget = true;
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                canvas.addEventListener('click', handleCanvasClick);
                window.addEventListener('contextmenu', handleContextMenu);  // æ–°å¢ï¼šç›£è½å³éµ
                window.addEventListener('mousemove', handleMouseMove);

                const drawRect = (x, y, w, h, color) => { ctx.fillStyle = color; ctx.fillRect(x, y, w, h); };
                const drawCircle = (x, y, r, color) => { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); };

                const drawRoundedRect = (x, y, w, h, r, color) => {
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                    ctx.lineTo(x + r, y + h);
                    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                    ctx.lineTo(x, y + r);
                    ctx.quadraticCurveTo(x, y, x + r, y);
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                };

                const drawFirefighterHighRes = (x, y, angle, color = '#1a253a', frame = 0, moving = false) => {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5;
                    const walkCycle = moving ? Math.sin(frame * 0.2) : 0;
                    const leftLegOffset = walkCycle * 3;
                    const rightLegOffset = -walkCycle * 3;
                    ctx.fillStyle = '#1a253a';
                    ctx.beginPath();
                    drawRoundedRect(-8, -5 + leftLegOffset, 6, 12, 3, '#1a253a');
                    drawRoundedRect(2, -5 + rightLegOffset, 6, 12, 3, '#1a253a');

                    const jacketGrad = ctx.createLinearGradient(-10, -10, 10, 10);
                    jacketGrad.addColorStop(0, '#1a253a'); jacketGrad.addColorStop(1, '#2c3e50');
                    ctx.fillStyle = jacketGrad;
                    ctx.beginPath();
                    ctx.moveTo(-11, -8); ctx.lineTo(11, -8); ctx.lineTo(10, 8); ctx.lineTo(-10, 8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 2; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(-8, -6); ctx.lineTo(8, 6); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(8, -6); ctx.lineTo(-8, 6); ctx.stroke();

                    drawRoundedRect(-4, -4, 8, 12, 3, '#f39c12'); ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.stroke();

                    const helmetGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, 10);
                    helmetGrad.addColorStop(0, '#e74c3c'); helmetGrad.addColorStop(1, '#c0392b');
                    ctx.fillStyle = helmetGrad;
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#922b21'; ctx.beginPath(); ctx.arc(0, 2, 8, 0, Math.PI, false); ctx.fill();
                    ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(0, 8); ctx.stroke();
                    ctx.fillStyle = '#1a253a'; ctx.beginPath(); ctx.arc(-11, -2, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(11, -2, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#95a5a6'; ctx.beginPath(); ctx.arc(-11, 4 + leftLegOffset * 0.5, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(11, 4 + rightLegOffset * 0.5, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                };

                const drawSurvivorHighRes = (s) => {
                    if (s.trappedInVehicle && !s.trappedInVehicle.isBreached) return;
                    ctx.save();
                    ctx.translate(s.x, s.y);
                    ctx.fillStyle = s.data.clothColor; ctx.beginPath(); ctx.ellipse(0, 6, 9, 16, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#f5cba7'; ctx.beginPath(); ctx.arc(0, -6, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#f5cba7'; ctx.beginPath(); ctx.arc(0, -10, 7, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#3e2723'; ctx.beginPath(); ctx.arc(0, -12, 7, Math.PI, 0, true); ctx.fill();
                    ctx.strokeStyle = s.data.clothColor; ctx.lineWidth = 4; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(-8, 0); ctx.quadraticCurveTo(-14, 2, -12, 10); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(8, 0); ctx.quadraticCurveTo(14, 2, 12, 10); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-4, 18); ctx.lineTo(-6, 28); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(4, 18); ctx.lineTo(6, 28); ctx.stroke();
                    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.arc(2, -10, 1, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(-2, -10, 1, 0, Math.PI * 2); ctx.fill();
                    if (s.triageTag) {
                        ctx.strokeStyle = { 'green': '#2ecc71', 'yellow': '#f1c40f', 'red': '#e74c3c', 'black': '#2d3436' }[s.triageTag];
                        ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 2, 22, 0, Math.PI * 2); ctx.stroke();
                    }
                    if (s.isDead) {
                        ctx.fillStyle = 'rgba(230,230,230,0.9)';
                        ctx.beginPath(); ctx.ellipse(0, 8, 12, 26, 0, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 1; ctx.stroke();
                    }
                    ctx.restore();
                };

                const drawEmergencyVehicle = (v) => {
                    ctx.save(); ctx.translate(v.x + v.w / 2, v.y + v.h / 2); ctx.rotate(v.angle);
                    ctx.shadowColor = 'rgba(0,0,0,0.4)'; ctx.shadowBlur = 10;
                    if (v.type === 'firetruck') {
                        drawRoundedRect(-v.w / 2, -v.h / 2, v.w, v.h, 6, '#c0392b');
                        ctx.fillStyle = '#e74c3c'; ctx.fillRect(-v.w / 2 + 5, -v.h / 2 + 5, v.w - 10, v.h - 10);
                        ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.rect(-v.w / 2 + 10, -5, v.w - 20, 10); ctx.fill();
                        for (let x = -v.w / 2 + 15; x < v.w / 2 - 10; x += 10) { ctx.clearRect(x, -3, 2, 6); }
                    } else if (v.type === 'ambulance') {
                        drawRoundedRect(-v.w / 2, -v.h / 2, v.w, v.h, 6, '#ecf0f1');
                        ctx.fillStyle = '#34495e'; ctx.beginPath();
                        ctx.fillRect(-v.w / 2 + 5, -v.h / 2 + 5, 20, v.h - 10);
                        ctx.fillStyle = '#e74c3c'; ctx.fillRect(-20, -5, 25, 10); ctx.fillRect(-12.5, -12.5, 10, 25);
                    } else if (v.type === 'police') {
                        drawRoundedRect(-v.w / 2, -v.h / 2, v.w, v.h, 6, '#2c3e50');
                        ctx.fillStyle = '#ecf0f1'; ctx.fillRect(-v.w / 2 + 25, -v.h / 2, 35, v.h);
                        ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-5, -v.h / 2 + 2, 10, v.h - 4);
                    }
                    // â˜…â˜…â˜… æ–°å¢ï¼šç¹ªè£½å°å·´ (é»ƒè‰²å¤–è§€) â˜…â˜…â˜…
                    else if (v.type === 'mini_bus') {
                        drawRoundedRect(-v.w / 2, -v.h / 2, v.w, v.h, 8, '#f1c40f'); // é»ƒè‰²è»Šèº«
                        ctx.fillStyle = '#2c3e50';
                        // è»Šçª— (é•·æ¢å‹)
                        ctx.fillRect(-v.w / 2 + 10, -v.h / 2 + 5, v.w - 20, v.h - 10);
                        // è»Šé ‚ç‡ˆ
                        ctx.fillStyle = '#e67e22';
                        ctx.fillRect(-10, -6, 20, 12);
                    }
                    ctx.shadowBlur = 20;
                    if (Math.floor(Date.now() / 200) % 2 === 0) {
                        ctx.shadowColor = 'red'; ctx.fillStyle = 'rgba(255, 0, 0, 0.9)'; ctx.beginPath(); ctx.arc(-10, 0, 6, 0, Math.PI * 2); ctx.fill();
                        ctx.shadowColor = 'blue'; ctx.fillStyle = 'rgba(0, 0, 255, 0.9)'; ctx.beginPath(); ctx.arc(10, 0, 6, 0, Math.PI * 2); ctx.fill();
                    } else {
                        ctx.shadowColor = 'blue'; ctx.fillStyle = 'rgba(0, 0, 255, 0.9)'; ctx.beginPath(); ctx.arc(-10, 0, 6, 0, Math.PI * 2); ctx.fill();
                        ctx.shadowColor = 'red'; ctx.fillStyle = 'rgba(255, 0, 0, 0.9)'; ctx.beginPath(); ctx.arc(10, 0, 6, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                    ctx.restore();
                };

                const drawFire = (hazard) => {
                    const flicker = Math.random() * 10;
                    const r = hazard.r + flicker;
                    const gradient = ctx.createRadialGradient(hazard.x, hazard.y, r * 0.2, hazard.x, hazard.y, r * 2);
                    gradient.addColorStop(0, 'rgba(255, 100, 0, 0.4)'); gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(hazard.x, hazard.y, r * 2, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = `rgba(255, ${150 + Math.random() * 100}, 0, 0.8)`; ctx.beginPath(); ctx.arc(hazard.x + (Math.random() - 0.5) * 10, hazard.y + (Math.random() - 0.5) * 10, r * 0.5, 0, Math.PI * 2); ctx.fill();
                };

                const drawMenu = (menu) => {
                    if (!menu.active) return;
                    const mx = menu.x - 40; const my = menu.y - 60;
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
                    // ä¿®æ”¹: è‹¥æ˜¯æ²»ç™‚é¸å–®ï¼Œç¸®çŸ­é€£ç·šä»¥é…åˆå‘ä¸Šç§»å‹•çš„é¸å–®
                    let lineBottom = my + 45;
                    if (menu.mode === 'treatment') lineBottom = my + 15;
                    else if (menu.mode === 'radio') {
                        // åœ¨ radio æ¨¡å¼ä¸­ï¼Œæˆ‘å€‘å°‡é¸å–®å‘ä¸Šç§»å‹•æ›´å¤š (åœ¨ä¸‹é¢å®šç¾©çš„ radioY)
                        // ä½†é€£ç·šçš„ç›®æ¨™é»ä»ç„¶æ˜¯é¸å–®çš„åº•éƒ¨é‚Šç·£ï¼Œå³ radioY + menuH (ç´„ -20)
                        // é€™è£¡è®“é€£ç·šç•«åˆ°æ¯” my æ›´é«˜çš„ä½ç½® (my - 60 = menu.y - 120)
                        lineBottom = my - 60;
                    }
                    ctx.beginPath(); ctx.moveTo(menu.x, menu.y - 10); ctx.lineTo(menu.x, lineBottom); ctx.stroke();

                    if (menu.mode === 'main') {
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx, my, 40, 40); ctx.strokeStyle = '#fff'; ctx.strokeRect(mx, my, 40, 40);
                        // ä¿®æ”¹: ç¹ªè£½å››å¼µé‡ç–Šçš„æª¢å‚·å¡ç‰‡ (ç¶ é»ƒç´…é»‘)
                        // ä¾ç…§åœ–ç‰‡é †åºï¼šç¶  -> é»ƒ -> ç´… -> é»‘ (ç”±å¾Œå¾€å‰å †ç–Š)
                        const cards = ['green', 'yellow', 'red', 'black'];
                        const stripColors = { 'green': '#00b894', 'yellow': '#f39c12', 'red': '#e74c3c', 'black': '#2d3436' };

                        cards.forEach((c, i) => {
                            // è¨ˆç®—å †ç–Šä½ç½® (æ¯å¼µå‘å³åç§» 6px)
                            // èµ·å§‹ X è¨­ç‚º mx + 5ï¼Œè®“å››å¼µå¡ç‰‡æ•´é«”å±…ä¸­æ–¼ 40px çš„æŒ‰éˆ•å…§
                            let cx = mx + 5 + (i * 6);
                            let cy = my + 8; // å‚ç›´ä½ç½®
                            const w = 14;    // å¡ç‰‡å¯¬åº¦ (ç¨å¾®ç¸®å°ä»¥å®¹ç´å››å¼µ)
                            const h = 20;    // å¡ç‰‡é«˜åº¦

                            // 1. æŠŠæ‰‹ (é ‚éƒ¨çªèµ·)
                            ctx.fillStyle = '#2d3436'; ctx.fillRect(cx + 5, cy - 3, 4, 3);

                            // 2. å¤–æ¡† (æ·±è‰²èƒŒæ™¯)
                            ctx.fillStyle = '#2d3436'; ctx.fillRect(cx, cy, w, h);

                            // 3. æœ¬é«” (ç±³è‰²)
                            ctx.fillStyle = '#fff8e1'; ctx.fillRect(cx + 1, cy + 1, w - 2, h - 2);

                            // 4. é¡è‰²æ¢ (åº•éƒ¨è‰²å¸¶)
                            ctx.fillStyle = stripColors[c]; ctx.fillRect(cx + 1, cy + h - 4, w - 2, 3);

                            // 5. è¡¨æƒ… (ç°¡åŒ–ç‰ˆåƒç´ é»)
                            ctx.fillStyle = '#2d3436';
                            ctx.fillRect(cx + 3, cy + 5, 2, 2); // å·¦çœ¼
                            ctx.fillRect(cx + 9, cy + 5, 2, 2); // å³çœ¼
                            ctx.fillRect(cx + 5, cy + 10, 4, 1); // å˜´å·´
                        });
                        // --- å³å´æŒ‰éˆ• (é†«ç™‚) ---
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx + 45, my, 40, 40); ctx.strokeStyle = '#fff'; ctx.strokeRect(mx + 45, my, 40, 40);
                        ctx.fillStyle = '#2ecc71'; ctx.fillRect(mx + 62, my + 10, 6, 20); ctx.fillRect(mx + 55, my + 17, 20, 6);
                        ctx.lineWidth = 3; ctx.strokeStyle = '#f1c40f'; // é»ƒè‰²é«˜äº®
                        if (menu.selectedIndex === 0) ctx.strokeRect(mx, my, 40, 40);
                        if (menu.selectedIndex === 1) ctx.strokeRect(mx + 45, my, 40, 40);
                    } else if (menu.mode === 'triage') {
                        // --- ä¿®æ”¹é–‹å§‹: æ›¿æ›ç‚ºåœ–ç‰‡é¢¨æ ¼çš„åœ–ç¤º ---
                        const colors = ['green', 'yellow', 'red', 'black'];
                        const btnW = 30;
                        const btnH = 30;
                        const gap = 5;
                        // å¾€å·¦ç§»ä»¥é¨°å‡ºç©ºé–“
                        const startX = mx - 25;
                        const startY = my - 12; // å‚ç›´ç½®ä¸­
                        // èƒŒæ™¯ç¨å¾®åŠ é«˜ä»¥å®¹ç´æ–°åœ–ç¤º
                        // ç¹ªè£½èƒŒæ™¯ (èª¿æ•´ç‚ºæ–¹å½¢ä»¥å®¹ç´ 2x2)
                        ctx.fillStyle = 'rgba(0,0,0,0.85)';
                        ctx.fillRect(startX - 5, startY - 5, (btnW * 2) + gap + 10, (btnH * 2) + gap + 10);
                        ctx.strokeStyle = '#555';
                        ctx.strokeRect(startX - 5, startY - 5, (btnW * 2) + gap + 10, (btnH * 2) + gap + 10);
                        colors.forEach((c, i) => {
                            let col = i % 2;
                            let row = Math.floor(i / 2);

                            let bx = startX + col * (btnW + gap);
                            let by = startY + row * (btnH + gap);

                            // ç¹ªè£½æŒ‰éˆ•åº•è‰²
                            const stripColors = { 'green': '#00b894', 'yellow': '#f39c12', 'red': '#e74c3c', 'black': '#2d3436' };

                            // å¤–æ¡†
                            ctx.fillStyle = '#2d3436';
                            ctx.fillRect(bx, by, btnW, btnH);

                            // å…§éƒ¨ (ç±³è‰²)
                            ctx.fillStyle = '#fff8e1';
                            ctx.fillRect(bx + 2, by + 2, btnW - 4, btnH - 4);

                            // é¡è‰²æ¨™ç±¤ (ä½”æ“šä¸‹åŠéƒ¨è¼ƒå¤§å€åŸŸ)
                            ctx.fillStyle = stripColors[c];
                            ctx.fillRect(bx + 2, by + btnH - 8, btnW - 4, 6);

                            // è¡¨æƒ… (çœ¼ç›)
                            ctx.fillStyle = '#2d3436';
                            ctx.fillRect(bx + 8, by + 10, 3, 3);  // å·¦çœ¼
                            ctx.fillRect(bx + 19, by + 10, 3, 3); // å³çœ¼

                            // å˜´å·´ (æ ¹æ“šé¡è‰²åšé»è®ŠåŒ–)
                            if (c === 'green') { // ç¬‘è‡‰
                                ctx.fillRect(bx + 10, by + 18, 2, 2);
                                ctx.fillRect(bx + 18, by + 18, 2, 2);
                                ctx.fillRect(bx + 12, by + 20, 6, 2);
                            } else if (c === 'black') { // Xå˜´
                                ctx.beginPath(); ctx.moveTo(bx + 12, by + 18); ctx.lineTo(bx + 18, by + 22); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(bx + 18, by + 18); ctx.lineTo(bx + 12, by + 22); ctx.stroke();
                            } else { // å¹³å˜´
                                ctx.fillRect(bx + 12, by + 19, 6, 2);
                            }
                            if (menu.selectedIndex === i) {
                                ctx.lineWidth = 3; ctx.strokeStyle = '#f1c40f';
                                ctx.strokeRect(bx, by, btnW, btnH);
                            }
                        });

                        // --- æ–°å¢ï¼šç¹ªè£½å³å´å¸¸é§çš„ã€Œé†«ç™‚æŒ‰éˆ•ã€ ---
                        // (è¤‡è£½è‡ª Main Mode)
                        ctx.fillStyle = '#2c3e50'; ctx.fillRect(mx + 45, my, 40, 40); ctx.strokeStyle = '#fff'; ctx.strokeRect(mx + 45, my, 40, 40);
                        ctx.fillStyle = '#2ecc71'; ctx.fillRect(mx + 62, my + 10, 6, 20); ctx.fillRect(mx + 55, my + 17, 20, 6);
                        if (menu.selectedIndex === 4) {
                            ctx.lineWidth = 3; ctx.strokeStyle = '#f1c40f';
                            ctx.strokeRect(mx + 45, my, 40, 40);
                        }
                    } else if (menu.mode === 'treatment') {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(mx - 25, my - 15, 130, 70);
                        ctx.fillStyle = '#e74c3c'; ctx.fillRect(mx - 20, my - 10, 120, 25);
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("ä½¿ç”¨æ­¢è¡€å¸¶", mx - 10, my + 7);
                        ctx.fillStyle = '#3498db'; ctx.fillRect(mx - 20, my + 20, 120, 25);
                        ctx.fillStyle = 'white'; ctx.fillText("æš¢é€šå‘¼å¸é“", mx - 10, my + 37);
                    } else if (menu.mode === 'hazard_fire') {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(mx - 10, my, 100, 40);
                        ctx.fillStyle = '#3498db'; ctx.fillRect(mx - 5, my + 5, 90, 30);
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("è«‹æ±‚æ»…ç«", mx + 15, my + 25);
                    } else if (menu.mode === 'hazard_vehicle') {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(mx - 10, my, 100, 40);
                        ctx.fillStyle = '#e67e22'; ctx.fillRect(mx - 5, my + 5, 90, 30);
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText("ç ´å£è»Šé«”", mx + 15, my + 25);
                        // ã€ä¿®æ”¹ã€‘ç„¡ç·šé›»é¸å–®ç¹ªè£½é‚è¼¯
                    } else if (menu.mode === 'radio') {
                        // é¸å–®ç•«åœ¨ç©å®¶é ­ä¸Š (menu.x, menu.y - 60)
                        // é€™è£¡çš„ radioX/Y å¿…é ˆèˆ‡ handleCanvasClick ä¸­çš„å®šç¾©ä¸€è‡´
                        const radioX = menu.x - 50; // å¾€å·¦ç§» 50px
                        const radioY = menu.y - 120; // å¾€ä¸Šç§»æ›´å¤š (menu.y - 60 å‰›å¥½æ˜¯ myï¼Œæ‰€ä»¥é€™è£¡è¨­å®š -120 è®“å®ƒé«˜å‡º mx/my 60px)
                        const menuW = 100;
                        const menuH = 130;
                        const btnH = 25;
                        const gap = 5;
                        const btnW = menuW - 10;

                        // ç¹ªè£½èƒŒæ™¯
                        drawRoundedRect(radioX, radioY, menuW, menuH, 5, 'rgba(0,0,0,0.85)');
                        ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; ctx.strokeRect(radioX, radioY, menuW, menuH);

                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.font = 'bold 12px "Segoe UI"';
                        const radioOptions = [
                            { label: "è«‹æ±‚æ•‘è­·è»Š", color: '#3498db' },     // è—
                            { label: "è«‹æ±‚æ¶ˆé˜²è»Š", color: '#e74c3c' },     // ç´…
                            { label: "è«‹æ±‚ç ´å£å°çµ„", color: '#e67e22' },   // æ©˜
                            { label: "è«‹æ±‚æ¬é‹äººå“¡", color: '#9b59b6' }    // ç´«
                        ];
                        // çµ±ä¸€ç¹ªè£½æŒ‰éˆ•èˆ‡é«˜äº®æ¡†
                        radioOptions.forEach((opt, i) => {
                            const by = (radioY + gap) + i * (btnH + gap);

                            // ç¹ªè£½æŒ‰éˆ•æœ¬é«”
                            ctx.fillStyle = opt.color;
                            ctx.fillRect(radioX + 5, by, btnW, btnH);

                            // ç¹ªè£½æ–‡å­—
                            ctx.fillStyle = 'white';
                            ctx.fillText(opt.label, radioX + menuW / 2, by + btnH / 2);

                            // ç¹ªè£½é¸ä¸­é«˜äº® (åŸæœ¬çš„è¿´åœˆé‚è¼¯æ•´åˆè‡³æ­¤)
                            if (menu.selectedIndex === i) {
                                ctx.lineWidth = 3; ctx.strokeStyle = '#f1c40f';
                                ctx.strokeRect(radioX + 5, by, btnW, btnH);
                            }
                        });
                    }


                };




                const drawSurvivorInfo = (player) => {
                    const interactRadius = 60;
                    // --- ä¿®æ”¹é–‹å§‹ï¼šå®šç¾©å·¦å´å€åŸŸé‚Šç•Œ ---
                    // æ¶ˆé˜²è»Šä½ç½®ç´„åœ¨ 750 (50 + 700)ï¼Œè¨­å®š 950 ç‚ºç•Œç·šï¼Œæ¶µè“‹å·¦å´èˆ‡æ¶ˆé˜²è»Šå‘¨é‚Š
                    const safeZoneBoundary = 950;
                    state.survivors.forEach(s => {
                        // åˆ¤æ–·è©²å‚·æ‚£æ˜¯å¦ç‚ºç•¶å‰é¸å–®çš„ç›®æ¨™
                        const isMenuTarget = state.interactionMenu.active && state.interactionMenu.target === s;
                        const distToPlayer = Math.hypot(player.x - s.x, player.y - s.y);
                        // --- ä¿®æ”¹é¡¯ç¤ºé‚è¼¯ ---
                        // 1. æª¢æŸ¥æ˜¯å¦åœ¨å·¦å´å®‰å…¨å€åŸŸ (inSafeZone)
                        const inSafeZone = s.x < safeZoneBoundary;

                        // 2. é¡¯ç¤ºæ¢ä»¶ï¼š
                        //    (A) æ˜¯ç•¶å‰é»æ“Šçš„ç›®æ¨™ (isMenuTarget) -> çµ•å°é¡¯ç¤º
                        //    (B) è·é›¢å¤ è¿‘ + æœ‰æª¢å‚·å¡ + "ä¸åœ¨"å®‰å…¨å€åŸŸ -> è‡ªå‹•é¡¯ç¤º
                        const showInfo = isMenuTarget || (distToPlayer < interactRadius && s.triageTag && !inSafeZone);
                        if (showInfo && !s.isBeingCarried && !s.isEvacuating) {
                            // å®šç¾©è³‡è¨Šæ¬„å°ºå¯¸
                            const w = 140;
                            const h = 130;

                            // åŸºç¤é–“è·
                            let gap = 20;
                            // --- ä¿®æ”¹é–‹å§‹: å‹•æ…‹è¨ˆç®—é¿è®“åç§»é‡ ---
                            let leftOffset = 40;  // é è¨­å‘å·¦åç§» (è³‡è¨Šæ¬„åœ¨å·¦æ™‚ï¼Œè·é›¢ s.x çš„è·é›¢)
                            let rightOffset = 20; // é è¨­å‘å³åç§» (è³‡è¨Šæ¬„åœ¨å³æ™‚ï¼Œè·é›¢ s.x çš„è·é›¢)
                            // å¦‚æœé¸å–®é–‹å•Ÿä¸­ï¼ŒåŠ å¤§é–“è·ä»¥é¿é–‹é¸å–® (é¸å–®å¯¬åº¦ç´„ 130px å·¦å³ï¼Œè¨­ 85 å®‰å…¨)
                            if (isMenuTarget) {
                                const mode = state.interactionMenu.mode;
                                // æ ¹æ“šé¸å–®æ¨¡å¼çš„å¯¬åº¦è¨­å®šé‚Šç•Œï¼Œç¢ºä¿ä¸é‡ç–Š
                                if (mode === 'triage') {
                                    // æª¢å‚·æ¨¡å¼ (2x2 Grid)
                                    // å·¦é‚Šç•Œç´„ç‚º -65 (s.x - 65)ï¼Œæˆ‘å€‘è¨­ 75 ç•™ç·©è¡
                                    // å³é‚Šç•Œç´„ç‚º +15 (s.x + 15)ï¼Œæˆ‘å€‘è¨­ 25 ç•™ç·©è¡
                                    leftOffset = 75;
                                    rightOffset = 25;
                                } else if (mode === 'treatment') {
                                    // æ²»ç™‚æ¨¡å¼ (å¯¬æ¢ç‹€)
                                    // å·¦å³é‚Šç•Œè¼ƒå¯¬ (-65 ~ +65)
                                    leftOffset = 75;
                                    rightOffset = 75;
                                } else {
                                    // ä¸»é¸å–® (Main)
                                    // å·¦é‚Šç•Œ -40, å³é‚Šç•Œ +85 (å«å³å´é†«ç™‚æŒ‰éˆ•)
                                    leftOffset = 50;
                                    rightOffset = 90;
                                }
                            }

                            // --- ä¿®æ”¹é–‹å§‹: åˆ¤æ–·é¡¯ç¤ºä½ç½® ---
                            let infoX;
                            // å¦‚æœå‚·æ‚£åœ¨ç©å®¶çš„å·¦é‚Š (s.x < player.x)ï¼Œè³‡è¨Šæ¬„é¡¯ç¤ºåœ¨å‚·æ‚£å³é‚Š
                            if (s.x < player.x) {
                                infoX = s.x + rightOffset;
                            } else {
                                // å¦‚æœå‚·æ‚£åœ¨ç©å®¶çš„å³é‚Š (s.x > player.x)ï¼Œè³‡è¨Šæ¬„é¡¯ç¤ºåœ¨å‚·æ‚£å·¦é‚Š
                                // æ¸›å»å¯¬åº¦ (w) å’Œåç§»é‡ (20)
                                infoX = s.x - leftOffset - w;
                            }
                            // Y è»¸ç¶­æŒåŸæ¨£ (é¡¯ç¤ºåœ¨ä¸Šæ–¹)
                            const infoY = s.y - 40;
                            drawRoundedRect(infoX, infoY, w, h, 5, 'rgba(0, 0, 0, 0.8)');
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(infoX, infoY, w, h);
                            ctx.font = '10px "Segoe UI"'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';

                            const d = s.data;
                            let yOffset = infoY + 8; const lineHeight = 16;
                            ctx.fillStyle = '#ecf0f1';
                            ctx.fillText(`æ€§åˆ¥: ${d.sex}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`å¹´é½¡: ${d.age} æ­²`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`å‚·æƒ…: ${d.injuryText}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`å‘¼å¸: ${d.resp}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`è„ˆæ: ${d.pulse}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`æ„è­˜: ${d.consciousness}`, infoX + 8, yOffset); yOffset += lineHeight;
                            ctx.fillText(`å¤§å‡ºè¡€: ${d.isBleeding ? 'æ˜¯' : 'å¦'}`, infoX + 8, yOffset);
                            yOffset += lineHeight;


                            ctx.fillText(`æ±™æŸ“: ${d.isContaminated ? 'æ˜¯ (éœ€é™¤æ±™)' : 'å¦'}`, infoX + 8, yOffset);
                        }
                    });
                };

                const drawNPCGroups = (groups) => {
                    groups.forEach(group => {
                        drawFirefighterHighRes(group.followerX, group.followerY, 0, '#1a253a', state.frameCount, true);
                        drawFirefighterHighRes(group.leaderX, group.leaderY, 0, '#1a253a', state.frameCount, true);
                        ctx.save();
                        ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 6; ctx.lineCap = 'round';
                        ctx.beginPath(); ctx.moveTo(group.followerX, group.followerY - 5); ctx.lineTo(group.leaderX, group.leaderY - 5); ctx.stroke();
                        ctx.restore();
                        if (group.carrying && group.target) {
                            const midX = (group.leaderX + group.followerX) / 2;
                            const midY = (group.leaderY + group.followerY) / 2 - 5;
                            drawRoundedRect(midX - 5, midY - 12, 10, 24, 3, group.target.data.clothColor);
                            drawCircle(midX, midY - 15, 6, '#f5cba7');
                        }
                    });
                };

                const drawFirefighters = (squads) => {
                    squads.forEach(s => {
                        drawFirefighterHighRes(s.x, s.y, 0, '#e67e22', state.frameCount, s.state === 'moving_to_fire');
                        drawFirefighterHighRes(s.x - 20, s.y + 10, 0, '#e67e22', state.frameCount, s.state === 'moving_to_fire');
                        if (s.state === 'extinguishing') {
                            ctx.strokeStyle = 'rgba(52, 152, 219, 0.7)'; ctx.lineWidth = 4;
                            ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.target.x, s.target.y); ctx.stroke();
                        }
                    });
                };
                // æ–°å¢: ç¹ªè£½ç ´å£å°çµ„ (å«ç ´å£å‰ªå‹•ç•«)
                const drawRescueSquads = (squads) => {
                    if (!squads) return; // â˜…â˜…â˜… ä¿®æ­£ 3: åŠ å…¥å®‰å…¨æª¢æŸ¥ï¼Œé˜²æ­¢ squads ç‚º undefined æ™‚å°è‡´é»‘ç•«é¢ â˜…â˜…â˜…
                    squads.forEach(s => {
                        if (!s.target) return; // â˜…â˜…â˜… ä¿®æ­£ 4: ç¢ºä¿ç›®æ¨™å­˜åœ¨ï¼Œé¿å…è®€å– s.target.y æ™‚å ±éŒ¯ â˜…â˜…â˜…
                        // 1. ä¸»æ“ä½œæ‰‹
                        drawFirefighterHighRes(s.x, s.y, 0, '#e67e22', state.frameCount, s.state !== 'breaking');

                        // 2. å‰¯æ‰‹ (ç¨å¾®è·Ÿåœ¨å¾Œé¢)
                        drawFirefighterHighRes(s.x - 20, s.y + 15, 0, '#e67e22', state.frameCount, s.state !== 'breaking');

                        // 3. ç¹ªè£½ç ´å£å™¨æ (åƒ…åœ¨ç ´å£ç‹€æ…‹æ™‚é¡¯ç¤ºä½œå‹•)
                        if (s.state === 'breaking') {
                            ctx.save();
                            // å°‡åº§æ¨™åŸé»ç§»åˆ°ä¸»æ“ä½œæ‰‹å‰æ–¹
                            ctx.translate(s.x + 10, s.y);

                            // è¨ˆç®—ç›®æ¨™è»Šè¼›æ–¹å‘
                            const angle = Math.atan2(s.target.y - s.y, s.target.x - s.x);
                            ctx.rotate(angle);

                            // æ¨¡æ“¬æ²¹å£“å‰ªé–‹åˆå‹•ä½œ
                            const bite = Math.sin(state.frameCount * 0.5) * 0.5; // é–‹åˆå¹…åº¦

                            // å™¨ææ©Ÿèº« (æ·±ç°è‰²)
                            ctx.fillStyle = '#555';
                            ctx.fillRect(0, -4, 25, 8);
                            // æŠŠæ‰‹
                            ctx.fillStyle = '#222';
                            ctx.fillRect(5, -8, 4, 16);

                            // å‰ªåˆ€é ­ (æ©˜è‰²) - ä¸Šé¡
                            ctx.save();
                            ctx.translate(25, -2);
                            ctx.rotate(-0.5 + bite); // åŸºç¤è§’åº¦ + å‹•æ…‹
                            ctx.fillStyle = '#d35400';
                            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(15, -4); ctx.lineTo(12, 4); ctx.fill();
                            ctx.restore();

                            // å‰ªåˆ€é ­ (æ©˜è‰²) - ä¸‹é¡
                            ctx.save();
                            ctx.translate(25, 2);
                            ctx.rotate(0.5 - bite);
                            ctx.fillStyle = '#d35400';
                            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(15, 4); ctx.lineTo(12, -4); ctx.fill();
                            ctx.restore();

                            // ç ´å£ç«èŠ±ç‰¹æ•ˆ
                            if (Math.random() > 0.7) {
                                ctx.fillStyle = '#f1c40f';
                                ctx.fillRect(38 + Math.random() * 10, (Math.random() - 0.5) * 10, 2, 2);
                            }
                            ctx.restore();
                        }
                    });
                };
                const drawStaticNpcs = (npcs) => {
                    npcs.forEach(npc => { drawFirefighterHighRes(npc.x, npc.y, 0, '#1a253a', state.frameCount, false); });
                    state.decorations.forEach(d => {
                        if (d.type === 'stretcher') {
                            ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 6;
                            ctx.beginPath(); ctx.moveTo(d.x - 10, d.y); ctx.lineTo(d.x + 10, d.y); ctx.stroke();
                        }
                    });
                };


                const drawTriageMats = (mats) => {
                    mats.forEach(m => {
                        ctx.save();
                        const colors = {
                            'green': 'rgba(46, 204, 113, 0.4)', 'yellow': 'rgba(241, 196, 15, 0.4)', 'red': 'rgba(231, 76, 60, 0.4)', 'black': 'rgba(44, 62, 80, 0.6)', 'command_post': 'rgba(255, 255, 255, 0.4)',
                            'ambulance_staging': 'rgba(52, 152, 219, 0.4)', 'decon': 'rgba(149, 165, 166, 0.4)'
                        };
                        ctx.fillStyle = colors[m.color] || 'rgba(255,255,255,0.2)';
                        ctx.fillRect(m.x, m.y, m.w, m.h);
                        const borderColors = { 'green': '#2ecc71', 'yellow': '#f1c40f', 'red': '#e74c3c', 'black': '#2c3e50' };
                        ctx.strokeStyle = borderColors[m.color] || '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(m.x, m.y, m.w, m.h);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        const labels = { 'green': 'è¼•å‚·å€', 'yellow': 'ä¸­å‚·å€', 'red': 'é‡å‚·å€', 'black': 'è‡¨æ™‚åœå±é–“', 'command_post': 'æŒ‡æ®ç«™', 'ambulance_staging': 'æ•‘è­·è»Šå¾…å‘½å€', 'decon': 'é™¤æ±™å€' };
                        ctx.fillText(labels[m.color], m.x + m.w / 2, m.y + m.h / 2);
                        // å¦‚æœæ˜¯æŒ‡æ®ç«™ï¼Œé¡å¤–ç¹ªè£½ä¸€å€‹æ¢å¾©åœ–ç¤º (ä¾‹å¦‚ +HP)
                        if (m.color === 'command_post') {
                            const blink = Math.sin(state.frameCount * 0.1) * 3;
                            ctx.fillStyle = '#2ecc71'; // ç¶ è‰²
                            ctx.font = 'bold 20px Arial';
                            ctx.fillText('+', m.x + m.w / 2 - 10, m.y + m.h / 2 + 30 + blink);
                            ctx.fillText('HP', m.x + m.w / 2 + 5, m.y + m.h / 2 + 30 + blink);
                        }
                        ctx.restore();
                    });
                };
                // â˜…â˜…â˜… æ–°å¢ï¼šç¹ªè£½äº’å‹•æç¤ºç®­é ­ (èˆ‡è¨­ç½®å€åŸŸé¢¨æ ¼ä¸€è‡´) â˜…â˜…
                const drawPlacementPreview = (mode) => {
                    if (!mode.active) return;

                    const p = state.player; // å–å¾—ç©å®¶åƒè€ƒ

                    ctx.save();


                    // --- è¨ˆç®—è·Ÿéš¨ç©å®¶é ­ä¸Šçš„åº§æ¨™ ---
                    // ä¸å†ä½¿ç”¨ mode.x/mode.y (åœ°å¢Šåº§æ¨™)ï¼Œè€Œæ˜¯ç›´æ¥é–å®šç©å®¶åº§æ¨™ (p.x, p.y)
                    const cx = p.x;
                    const cy = p.y - 50; // åŸºç¤é«˜åº¦ (è§’è‰²é ­é ‚ä¸Šæ–¹)

                    // --- 1. ç®­é ­ (æŒ‡å‘è§’è‰²é ­é ‚) ---
                    const bounce = Math.sin(state.frameCount * 0.2) * 5; // ä¸Šä¸‹æµ®å‹•å‹•ç•«
                    const arrowY = cy + bounce;

                    ctx.fillStyle = '#f1c40f';
                    ctx.beginPath();
                    ctx.moveTo(cx - 10, arrowY - 15); // å·¦ä¸Š
                    ctx.lineTo(cx + 10, arrowY - 15); // å³ä¸Š
                    ctx.lineTo(cx, arrowY);           // ä¸‹å°–ç«¯ (æŒ‡å‘è§’è‰²)
                    ctx.closePath();

                    ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
                    ctx.fill();
                    ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.stroke();
                    ctx.shadowBlur = 0;

                    // --- 2. æ–‡å­—è¨­å®š ---
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = 'rgba(0,0,0,0.8)'; // æ–‡å­—é»‘é‚Š

                    // --- 3. æ“ä½œæç¤º "æŒ‰ [E]..." (åœ¨ç®­é ­ä¸Šæ–¹) ---
                    const promptText = "æŒ‰ [E] è¨­ç½® æˆ– [é»æ“Šå·¦éµ]";
                    const promptY = arrowY - 20;

                    ctx.font = 'bold 14px "Segoe UI"';
                    ctx.strokeText(promptText, cx, promptY);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(promptText, cx, promptY);

                    // --- 4. å€åŸŸåç¨± (å¦‚ï¼šè¼•å‚·å€) (åœ¨æ“ä½œæç¤ºä¸Šæ–¹) ---
                    const labels = {
                        'green': 'è¼•å‚·å€', 'yellow': 'ä¸­å‚·å€', 'red': 'é‡å‚·å€', 'black': 'è‡¨æ™‚åœå±é–“',
                        'command_post': 'æŒ‡æ®ç«™', 'ambulance_staging': 'æ•‘è­·è»Šå¾…å‘½å€', 'decon': 'é™¤æ±™å€'
                    };
                    const labelText = labels[mode.color] || '';
                    const labelY = promptY - 20;

                    // æ ¹æ“šå€åŸŸé¡å‹è¨­å®šæ–‡å­—é¡è‰²
                    const labelColors = {
                        'green': '#2ecc71', 'yellow': '#f1c40f', 'red': '#e74c3c', 'black': '#bdc3c7',
                        'command_post': '#ffffff', 'ambulance_staging': '#3498db', 'decon': '#95a5a6'
                    };

                    ctx.font = 'bold 18px "Segoe UI"'; // æ¨™é¡Œå­—å¤§ä¸€é»
                    ctx.strokeText(labelText, cx, labelY);
                    ctx.fillStyle = labelColors[mode.color] || '#fff';
                    ctx.fillText(labelText, cx, labelY);

                    ctx.restore();
                };
                // â˜…â˜…â˜… æ–°å¢ï¼šç¹ªè£½äº’å‹•æç¤ºç®­é ­ (èˆ‡è¨­ç½®å€åŸŸé¢¨æ ¼ä¸€è‡´) â˜…â˜…â˜…
                const drawInteractionIndicators = () => {
                    // å¦‚æœæ­£åœ¨æ”¾ç½®æ¨¡å¼ã€é¸å–®é–‹å•Ÿä¸­æˆ–éŠæˆ²çµæŸï¼Œä¸é¡¯ç¤ºæç¤ºä»¥å…é›œäº‚
                    if (state.placementMode.active || state.interactionMenu.active || state.isGameOver) return;

                    const p = state.player;
                    const interactRadius = 60; // èˆ‡ handleCanvasClick ä¸­çš„åˆ¤å®šè·é›¢ä¸€è‡´

                    // å…±ç”¨çš„ç¹ªè£½ç®­é ­å‡½å¼
                    const drawArrow = (x, y, label) => {
                        ctx.save();
                        const bounce = Math.sin(state.frameCount * 0.2) * 5; // ä¸Šä¸‹æµ®å‹•
                        const arrowY = y - 40 + bounce; // é¡¯ç¤ºåœ¨ç‰©ä»¶ä¸Šæ–¹

                        // 1. ç¹ªè£½ç®­é ­
                        ctx.fillStyle = '#f1c40f';
                        ctx.beginPath();
                        ctx.moveTo(x - 10, arrowY - 15);
                        ctx.lineTo(x + 10, arrowY - 15);
                        ctx.lineTo(x, arrowY);
                        ctx.closePath();

                        ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
                        ctx.fill();
                        ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.stroke();
                        ctx.shadowBlur = 0;

                        // 2. ç¹ªè£½æ–‡å­—
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'rgba(0,0,0,0.8)';

                        const promptText = "æŒ‰ [E] äº’å‹• æˆ– [é»æ“Šå·¦éµ]";
                        const promptY = arrowY - 20;

                        // æ“ä½œæç¤º
                        ctx.font = 'bold 12px "Segoe UI"';
                        ctx.strokeText(promptText, x, promptY);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(promptText, x, promptY);

                        // ç‰©ä»¶åç¨± (é¸å¡«)
                        if (label) {
                            ctx.font = 'bold 16px "Segoe UI"';
                            ctx.strokeText(label, x, promptY - 15);
                            ctx.fillStyle = '#f1c40f';
                            ctx.fillText(label, x, promptY - 15);
                        }
                        ctx.restore();
                    };

                    // 1. æª¢æŸ¥ç«ç„° (Fire)
                    state.hazards.forEach(h => {
                        if (!h.beingExtinguished) {
                            const dist = Math.hypot(p.x - h.x, p.y - h.y);
                            if (dist < interactRadius + 50) { // é…åˆé»æ“Šåˆ¤å®šç¯„åœ
                                drawArrow(h.x, h.y - h.r, "è«‹æ±‚æ»…ç«");
                            }
                        }
                    });

                    // 2. æª¢æŸ¥è»Šè¼› (Vehicle) - åªæç¤ºæœ‰äººçš„è»Š
                    state.obstacles.forEach(o => {
                        if (o.type !== 'guardrail' && o.type !== 'wall' && o.type !== 'vehicle_block' && o.type !== 'metal_debris') {
                            const dist = Math.hypot(p.x - (o.x + o.w / 2), p.y - (o.y + o.h / 2));
                            if (dist < interactRadius + 40) {
                                // æª¢æŸ¥æ˜¯å¦å—å›°ä¸”æœªç ´å£
                                const survivorInside = state.survivors.find(s => s.trappedInVehicle === o);
                                if (survivorInside && !o.isBreached && o.breakTimer === 0) {
                                    drawArrow(o.x + o.w / 2, o.y, "ç ´å£è»Šé«”");
                                }
                            }
                        }
                    });

                    // 3. æª¢æŸ¥å‚·æ‚£ (Survivor)
                    state.survivors.forEach(s => {
                        // æ’é™¤å—å›°ä¸­(ç”±è»Šè¼›è™•ç†)ã€å·²æ­»äº¡è½‰é»‘å¡ä¸”ä¸åœ¨é¸å–®ç›®æ¨™ã€æ­£åœ¨ç§»å‹•æˆ–è¢«æ¬é‹çš„
                        if (s.trappedInVehicle && !s.trappedInVehicle.isBreached) return;
                        if (s.isEvacuating || s.isBeingCarried || s.onAmbulance) return;

                        const dist = Math.hypot(p.x - s.x, p.y - s.y);
                        if (dist < interactRadius) {
                            let label = "é€²è¡Œæª¢å‚·";
                            if (s.triageTag) label = "æŸ¥çœ‹è³‡è¨Š"; // å·²æª¢å‚·æ”¹é¡¯ç¤ºæŸ¥çœ‹
                            drawArrow(s.x, s.y - 15, label);
                        }
                    });
                };

                const update = () => {

                    const p = state.player;
                    state.frameCount++;
                    // â˜…â˜…â˜… æ–°å¢ï¼šèƒ½é‡é£²æ–™ç”Ÿæˆé‚è¼¯ (æ¯30ç§’ = 1800 frames) â˜…â˜…â˜…
                    state.energySpawnTimer++;
                    if (state.energySpawnTimer > 1800) {
                        state.energySpawnTimer = 0;
                        // æœ€å¤šåŒæ™‚å­˜åœ¨ 3 ç½
                        if (state.energyDrinks.length < 3) {
                            // æ¶ˆé˜²è»Šä½æ–¼ 50 + LEFT_EXPANSION (ç´„ 750)ï¼Œå¯¬ 140
                            // ç”Ÿæˆæ–¼æ¶ˆé˜²è»Šå³å´å€åŸŸ (ç´„ X: 950 ~ 1150)
                            const spawnX = (50 + 700) + 200 + Math.random() * 200;
                            const spawnY = 200 + Math.random() * (1200 - 400); // éš¨æ©Ÿé«˜åº¦

                            // ç°¡å–®é¿é–‹éšœç¤™ç‰©æª¢æŸ¥
                            let safe = true;
                            for (let o of state.obstacles) {
                                if (spawnX > o.x && spawnX < o.x + o.w && spawnY > o.y && spawnY < o.y + o.h) {
                                    safe = false; break;
                                }
                            }

                            if (safe) {
                                state.energyDrinks.push({
                                    x: spawnX, y: spawnY, w: 20, h: 30,
                                    floatOffset: Math.random() * Math.PI * 2
                                });
                                addFeedback(spawnX, spawnY - 40, "èƒ½é‡é£²æ–™å‡ºç¾!", "#00ffff");
                            }
                        }
                    }

                    // â˜…â˜…â˜… æ–°å¢ï¼šæª¢æŸ¥ç©å®¶æ˜¯å¦åƒåˆ°èƒ½é‡é£²æ–™ â˜…â˜…â˜…
                    for (let i = state.energyDrinks.length - 1; i >= 0; i--) {
                        const drink = state.energyDrinks[i];
                        // ç¢°æ’è·é›¢åˆ¤å®š
                        if (Math.hypot(p.x - drink.x, p.y - drink.y) < 40) {
                            state.energyDrinks.splice(i, 1); // ç§»é™¤é£²æ–™
                            state.spBuffTimer = 1800; // çµ¦äºˆ 30ç§’ (1800 frames) Buff
                            addFeedback(p.x, p.y - 60, "âš¡ SPç„¡é™ (30s) âš¡", "#00ffff");
                        }
                    }

                    // â˜…â˜…â˜… æ–°å¢ï¼šBuff è¨ˆæ™‚å™¨å€’æ•¸ â˜…â˜…â˜…
                    if (state.spBuffTimer > 0) {
                        state.spBuffTimer--;
                    }

                    // â˜…â˜…â˜… æ–°å¢ï¼šæ¬é‹ç³»çµ±å†·å»å€’æ•¸ (æ”¾åœ¨ update å‡½å¼å‰æ–¹) â˜…â˜…â˜…
                    if (state.carrySystemCooldown > 0) {
                        state.carrySystemCooldown--;
                    }
                    // â˜…â˜…â˜… æ–°å¢ï¼šæ•‘è­·è»Šå†·å»æ™‚é–“å€’æ•¸ â˜…â˜…â˜…
                    if (state.ambulanceCooldown > 0) {
                        state.ambulanceCooldown--;
                    }
                    // â˜…â˜…â˜… æ–°å¢ï¼šå¤§è²å…¬å†·å»å€’æ•¸ â˜…â˜…â˜…
                    if (state.megaphoneCooldown > 0) {
                        state.megaphoneCooldown--;
                    }
                    // --- æ–°å¢ï¼šè¨ˆç®—ç›®çš„åœ° (åœ°å¢Šä¸­å¿ƒéš¨æ©Ÿé» æˆ– æ¶ˆé˜²è»Šå¾Œæ–¹) ---
                    const getTriageDest = (tag) => {
                        const mat = state.triageMats.find(m => m.color === tag);
                        if (mat) {
                            // è‹¥æœ‰å°æ‡‰é¡è‰²çš„åœ°å¢Šï¼Œå›å‚³åœ°å¢Šç¯„åœå…§çš„éš¨æ©Ÿé»
                            return {
                                x: mat.x + 10 + Math.random() * (mat.w - 20),
                                y: mat.y + 10 + Math.random() * (mat.h - 20)
                            };
                        }
                        // è‹¥ç„¡è¨­ç½®åœ°å¢Šï¼Œé è¨­å‰å¾€æ¶ˆé˜²è»Šå¾Œæ–¹å¾…å‘½ (æ¶ˆé˜²è»Š X ç´„åœ¨ 50 + LEFT_EXPANSION)
                        return {
                            x: (50 + LEFT_EXPANSION) - 80 + Math.random() * 40,
                            y: WORLD_HEIGHT / 2 - 50 + Math.random() * 100
                        };
                    };

                    // --- æ–°å¢ï¼šåœ°å¢Šä½ç½®è‡ªå‹•æ›´æ–° (é¡¯ç¤ºåœ¨è§’è‰²å‰æ–¹) ---
                    if (state.placementMode.active) {
                        const pm = state.placementMode;


                        let targetX = p.x;
                        let targetY = p.y;



                        // æ›´æ–°åœ°å¢Šåº§æ¨™ (ç½®ä¸­)
                        pm.x = targetX - pm.w / 2;
                        pm.y = targetY - pm.h / 2;

                        // é©—è­‰ä½ç½®æ˜¯å¦åˆæ³• (æª¢æŸ¥éšœç¤™ç‰©ã€å…¶ä»–åœ°å¢Šã€å‚·æ‚£)
                        let valid = true;
                        // 0. ã€æ–°å¢ã€‘æª¢æŸ¥æ˜¯å¦åœ¨å®‰å…¨å€åŸŸ (æ¶ˆé˜²è»Šå·¦å´)
                        // æ¶ˆé˜²è»Š X = 50 + LEFT_EXPANSIONï¼Œæˆ‘å€‘ä»¥æ­¤ä½œç‚ºé‚Šç•Œ
                        const safeZoneLimit = 50 + LEFT_EXPANSION;
                        if (pm.x + pm.w > safeZoneLimit) {
                            valid = false;
                        }
                        // 1. æª¢æŸ¥éšœç¤™ç‰©
                        for (let o of state.obstacles) {
                            if (pm.x < o.x + o.w && pm.x + pm.w > o.x && pm.y < o.y + o.h && pm.y + pm.h > o.y) {
                                valid = false; break;
                            }
                        }
                        // 2. æª¢æŸ¥é‡ç–Šåœ°å¢Š
                        if (valid) {
                            for (let m of state.triageMats) {
                                if (pm.x < m.x + m.w && pm.x + pm.w > m.x && pm.y < m.y + m.h && pm.y + pm.h > m.y) {
                                    valid = false; break;
                                }
                            }
                        }
                        // 3. æª¢æŸ¥æ˜¯å¦å£“åˆ°å‚·æ‚£
                        if (valid) {
                            for (let s of state.survivors) {
                                if (Math.hypot(pm.x + pm.w / 2 - s.x, pm.y + pm.h / 2 - s.y) < 20) {
                                    valid = false; break;
                                }
                            }
                        }
                        pm.valid = valid;
                    }
                    p.moving = false;
                    let nextX = p.x;
                    let nextY = p.y;

                    if (state.stats.hp <= 0) {
                        state.isGameOver = true;
                        setGameOver(true);
                        return;
                    }

                    if (state.interactionMenu.active && state.interactionMenu.target) {
                        const target = state.interactionMenu.target;

                        let targetX = target.x;
                        let targetY = target.y;
                        if (target.w) { targetX += target.w / 2; targetY += target.h / 2; }
                        const dist = Math.hypot(p.x - targetX, p.y - targetY);
                        if (dist > 80) {
                            state.interactionMenu.active = false;
                            state.interactionMenu.target = null;
                            state.interactionMenu.mode = 'main';
                        }
                    }

                    for (let i = state.firefightingSquads.length - 1; i >= 0; i--) {
                        let s = state.firefightingSquads[i];
                        if (s.state === 'moving_to_fire') {
                            const dx = s.target.x - s.x;
                            const dy = s.target.y - s.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist < 100) {
                                s.state = 'extinguishing';
                            } else {
                                s.x += (dx / dist) * 2;
                                s.y += (dy / dist) * 2;
                            }
                        } else if (s.state === 'extinguishing') {
                            s.target.life--;
                            if (s.target.life <= 0) {
                                const hzIndex = state.hazards.indexOf(s.target);
                                if (hzIndex > -1) state.hazards.splice(hzIndex, 1);
                                s.state = 'leaving';
                            }
                        } else if (s.state === 'leaving') {
                            s.x -= 2;
                            if (s.x < -50) state.firefightingSquads.splice(i, 1);
                        }
                    }
                    // æ–°å¢: ç ´å£å°çµ„æ›´æ–°é‚è¼¯
                    for (let i = state.rescueSquads.length - 1; i >= 0; i--) {
                        let s = state.rescueSquads[i];
                        if (s.state === 'moving_to_vehicle') {
                            // ç§»å‹•åˆ°è»Šè¼›å·¦å´ä¸€é»çš„ä½ç½®
                            let tx = s.target.x - 40;
                            let ty = s.target.y + s.target.h / 2;
                            const dx = tx - s.x;
                            const dy = ty - s.y;
                            const dist = Math.hypot(dx, dy);

                            if (dist < 10) {
                                s.state = 'breaking';
                                // è¨­å®š 600 frames = ç´„ 10 ç§’
                                s.target.breakTimer = 600;
                                addFeedback(s.target.x + s.target.w / 2, s.target.y - 20, "ç ´å£ä½œæ¥­é–‹å§‹...", "#f39c12");
                            } else {
                                // ç§»å‹•é€Ÿåº¦
                                s.x += (dx / dist) * 2.5;
                                s.y += (dy / dist) * 2.5;
                            }
                        } else if (s.state === 'breaking') {
                            // ç ´å£ä¸­ï¼šbreakTimer æœƒåœ¨ä¸‹æ–¹çš„ obstacles è¿´åœˆä¸­è‡ªå‹•å€’æ•¸
                            // é€™è£¡åªéœ€è¦æª¢æŸ¥æ˜¯å¦å®Œæˆ
                            if (s.target.isBreached) {
                                s.state = 'leaving';
                                addFeedback(s.target.x + s.target.w / 2, s.target.y - 20, "ä½œæ¥­å®Œæˆï¼Œæ’¤æ”¶!", "#2ecc71");
                            }
                        } else if (s.state === 'leaving') {
                            // è¿”å›å‡ºç™¼é»
                            let tx = 50 + 700;
                            let ty = 540 / 2 - 150;
                            const dx = tx - s.x;
                            const dy = ty - s.y;
                            const dist = Math.hypot(dx, dy);

                            if (dist < 10) {
                                state.rescueSquads.splice(i, 1); // ç§»é™¤å°çµ„
                            } else {
                                s.x += (dx / dist) * 2;
                                s.y += (dy / dist) * 2;
                            }
                        }
                    }
                    state.obstacles.forEach(o => {
                        if (o.breakTimer > 0) {
                            o.breakTimer--;
                            if (o.breakTimer <= 0) {
                                o.isBreached = true;
                                addFeedback(o.x + o.w / 2, o.y, "ç ´å£å®Œæˆ", "#2ecc71");
                                // --- ä¿®æ”¹é–‹å§‹ï¼šå°‡å‚·æ‚£ç§»å‡ºè»Šå¤– ---
                                // æœå°‹å—å›°æ–¼æ­¤è»Šè¼›çš„å‚·æ‚£
                                const survivor = state.survivors.find(s => s.trappedInVehicle === o);
                                if (survivor) {
                                    // å°‡å‚·æ‚£ä½ç½®è¨­å®šåˆ°è»Šè¼›ä¸‹æ–¹ (Yè»¸å¢åŠ )ï¼Œç¢ºä¿å®Œå…¨éœ²å‡º
                                    // åç§»é‡è¨­ç‚ºè»Šé«˜ + 50pxï¼Œç¢ºä¿æœ‰è¶³å¤ é»æ“Šç©ºé–“
                                    survivor.x = o.x + o.w / 2; // æ°´å¹³ç½®ä¸­
                                    survivor.y = o.y + o.h + 50;

                                    // ç°¡å–®é‚Šç•Œæª¢æŸ¥ï¼Œå¦‚æœå¤ªä¸‹é¢å°±æ”¹ç§»åˆ°ä¸Šé¢
                                    if (survivor.y > WORLD_HEIGHT - 30) {
                                        survivor.y = o.y - 50;
                                    }

                                    addFeedback(survivor.x, survivor.y, "å‚·æ‚£å·²ç§»å‡º", "#3498db");
                                }
                            }
                        }
                    });

                    // æ–°ç¨‹å¼ç¢¼ï¼šæª¢æŸ¥å ´ä¸Šæ˜¯å¦æœ‰ã€Œç„¡äººè™•ç†ã€çš„é‡å‚·æ‚£
                    const unassignedTargets = state.survivors.filter(s =>
                        s.triageTag &&
                        (s.triageTag === 'red' || s.triageTag === 'yellow' || s.triageTag === 'black') && // é‡å°ç´…/é»ƒ/é»‘å¡
                        !s.isEvacuating &&      // éè‡ªè¡Œç§»å‹•ä¸­
                        !s.hasArrived &&        // å°šæœªæŠµé”å®‰ç½®å€
                        !s.isBeingCarried &&    // å°šæœªè¢«æ¬èµ·
                        !state.npcGroups.some(g => g.target === s) && // ç›®å‰æ²’æœ‰ä»»ä½•å°çµ„é–å®šä»–
                        (!s.trappedInVehicle || s.trappedInVehicle.isBreached) && // æ²’æœ‰å—å›°
                        !state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30) // å‘¨åœç„¡ç«
                    );

                    // é™åˆ¶å ´ä¸ŠåŒæ™‚å­˜åœ¨çš„æ¬é‹çµ„ä¸Šé™ (ä¾‹å¦‚ 5 çµ„)ï¼Œé¿å…å¤ªäº‚
                    if (unassignedTargets.length > 0 && state.npcGroups.length < 1) {
                        // ç°¡å–®çš„å†·å»æ™‚é–“ï¼Œé¿å…åŒä¸€å¹€ç”Ÿæˆæ‰€æœ‰äºº (åˆ©ç”¨ frameCount)
                        if (state.frameCount % 60 === 0) {
                            // å„ªå…ˆè™•ç†ç´…å¡ (é›–ç„¶ filter å·²ç¶“ç¯©é¸éï¼Œé€™è£¡å–ç¬¬ä¸€å€‹å³å¯)
                            // æ ¹æ“šåš´é‡ç¨‹åº¦æ’åºï¼šé»‘ > ç´… > é»ƒ (æˆ–ä¾éœ€æ±‚èª¿æ•´)
                            unassignedTargets.sort((a, b) => {
                                const p = { 'black': 3, 'red': 2, 'yellow': 1 };
                                return p[b.triageTag] - p[a.triageTag];
                            });

                            const target = unassignedTargets[0];

                            state.npcGroups.push({
                                leaderX: 20 + LEFT_EXPANSION, leaderY: 600, // å¾ç•«é¢é‚Šç·£å‡ºç¾
                                followerX: 0 + LEFT_EXPANSION, followerY: 600,
                                target: target,           // ç›´æ¥é–å®šç›®æ¨™
                                state: 'moving_to_target', // ç›´æ¥å‰å¾€ï¼Œä¸ç¶“é searching
                                carrying: false
                            });
                        }
                    }

                    for (let i = state.npcGroups.length - 1; i >= 0; i--) {
                        let group = state.npcGroups[i];
                        const speed = 1.0;
                        if (group.state === 'searching') {
                            // é é˜²è¬ä¸€ï¼šå¦‚æœè™•æ–¼ searching ç‹€æ…‹ä½†æ²’ç›®æ¨™ï¼Œç›´æ¥æ’¤é›¢
                            group.state = 'leaving';

                        }

                        else if (group.state === 'moving_to_target') {
                            // (é€™æ®µä¿æŒä¸è®Š)
                            const dx = group.target.x - group.leaderX;
                            const dy = group.target.y - group.leaderY;
                            const dist = Math.hypot(dx, dy);
                            if (dist < 10) {
                                group.state = 'carrying';
                                group.carrying = true;
                                addFeedback(group.leaderX, group.leaderY, "é–‹å§‹æ¬é‹", "#fff");
                            } else {
                                group.leaderX += (dx / dist) * speed;
                                group.leaderY += (dy / dist) * speed;
                            }
                        } else if (group.state === 'carrying') {
                            // --- ä¿®æ”¹ï¼šæ¬é‹é‚è¼¯ (åŒ…å«é™¤æ±™å€åˆ¤æ–·) ---
                            let targetTag = group.target.triageTag;
                            let isGoingToDecon = false;

                            // åˆ¤æ–·æ˜¯å¦éœ€è¦å…ˆå»é™¤æ±™
                            // æ¢ä»¶ 1: å‚·æ‚£è™•æ–¼æ±™æŸ“ç‹€æ…‹ (isContaminated ç‚º true)
                            // æ¢ä»¶ 2: å ´æ™¯ä¸­æœ‰è¨­ç½®é™¤æ±™å€ (decon)
                            // æ¢ä»¶ 3: é™¤æ±™å€ä½æ–¼ç›®æ¨™æª¢å‚·å€çš„ã€Œå³æ–¹ã€ (deconMat.x > targetMat.x)
                            if (group.target.data.isContaminated) {
                                const deconMat = state.triageMats.find(m => m.color === 'decon');
                                const targetMat = state.triageMats.find(m => m.color === targetTag);

                                // è‹¥æ»¿è¶³æ‰€æœ‰æ¢ä»¶ï¼Œå¼·åˆ¶å…ˆå‰å¾€é™¤æ±™å€
                                if (deconMat && targetMat && deconMat.x > targetMat.x) {
                                    targetTag = 'decon';
                                    isGoingToDecon = true;
                                }
                            }

                            // å–å¾—ç›®çš„åœ°åº§æ¨™ (å¯èƒ½æ˜¯åŸæœ¬çš„æª¢å‚·å€ï¼Œæˆ–æ˜¯æš«æ™‚çš„é™¤æ±™å€)
                            const dest = getTriageDest(targetTag);
                            const dx = dest.x - group.leaderX;
                            const dy = dest.y - group.leaderY;
                            const dist = Math.hypot(dx, dy);

                            if (dist < 10) {
                                if (isGoingToDecon) {
                                    if (group.target.data.isContaminated) {
                                        statsTracker.current.deconCount++;
                                    }
                                    // --- Case A: æŠµé”é™¤æ±™å€ ---
                                    group.target.data.isContaminated = false; // æ¸…é™¤æ±™æŸ“ç‹€æ…‹
                                    addFeedback(group.leaderX, group.leaderY, "å·²é™¤æ±™", "#95a5a6");

                                    // é‡è¦ï¼šé€™è£¡ä¸åŸ·è¡Œæ”¾ä¸‹å‚·æ‚£ (drop) çš„å‹•ä½œ
                                    // å› ç‚º isContaminated å·²è¢«è¨­ç‚º falseï¼Œä¸‹ä¸€å¹€æ›´æ–°æ™‚ï¼Œ
                                    // ä¸Šæ–¹çš„ if åˆ¤æ–·æœƒä¸æˆç«‹ï¼Œç›®çš„åœ°æœƒè‡ªå‹•åˆ‡æ›å›åŸæœ¬çš„æª¢å‚·å€ (targetTag)ï¼Œ
                                    // NPC å°±æœƒå¸¶è‘—å‚·æ‚£ç¹¼çºŒå¾€æ­£ç¢ºå€åŸŸå‰é€²ã€‚
                                } else {
                                    // --- Case B: æŠµé”æœ€çµ‚å®‰ç½®å€åŸŸ ---
                                    group.target.x = dest.x;
                                    group.target.y = dest.y;
                                    group.target.isBeingCarried = false;
                                    group.target.hasArrived = true; // æ¨™è¨˜ç‚ºå·²å®‰ç½®
                                    // æª¢æŸ¥æª¢å‚·åˆ†é¡æ˜¯å¦èˆ‡å¯¦éš›å‚·æƒ…ç›¸ç¬¦
                                    if (group.target.triageTag === group.target.data.severity) {
                                        if (!group.target.hasBeenMovedScored) {
                                            setScore(prev => prev + 100);
                                            addFeedback(group.leaderX, group.leaderY - 50, "ç§»å‹•æ­£ç¢º +100", "#f1c40f");
                                            group.target.hasBeenMovedScored = true; // æ¨™è¨˜å·²åŠ éç§»å‹•åˆ†
                                        }
                                    }

                                    // NPC é‡ç½®ç‹€æ…‹ï¼Œæº–å‚™å»æœå°‹ä¸‹ä¸€å€‹å‚·æ‚£
                                    group.target = null;
                                    group.carrying = false;
                                    group.state = 'searching';
                                    checkTriageCounts(); // æ¬é‹å®Œæˆå¾Œæª¢æŸ¥è¨ˆæ•¸ 
                                    state.carrySystemCooldown = 1200;
                                }
                            } else {
                                // ç§»å‹•é‚è¼¯ (ä¿æŒä¸è®Š)
                                group.leaderX += (dx / dist) * speed;
                                group.leaderY += (dy / dist) * speed;
                                if (group.target) {
                                    // å‚·æ‚£ä½ç½®è·Ÿéš¨ NPC éšŠä¼ä¸­å¿ƒ
                                    group.target.x = (group.leaderX + group.followerX) / 2;
                                    group.target.y = (group.leaderY + group.followerY) / 2;
                                }
                            }

                        }
                        // ... leaving ç‹€æ…‹ä¿æŒä¸è®Š ...
                        else if (group.state === 'leaving') {
                            group.leaderX -= speed;
                            if (group.leaderX < -50 + LEFT_EXPANSION) state.npcGroups.splice(i, 1);
                        }

                        // ... è·Ÿéš¨è€…é‚è¼¯ä¿æŒä¸è®Š ...
                        if (group.state !== 'searching' || group.leaderX > 0) {
                            const fdx = group.leaderX - group.followerX;
                            const fdy = group.leaderY - group.followerY;
                            const fdist = Math.hypot(fdx, fdy);
                            if (fdist > 25) {
                                group.followerX += (fdx / fdist) * speed;
                                group.followerY += (fdy / fdist) * speed;
                            }
                        } else {
                            group.followerX = group.leaderX - 20;
                            group.followerY = group.leaderY;
                        }
                    }

                    // --- ä¿®æ”¹ï¼šå‚·æ‚£è‡ªè¡Œç§»å‹•é‚è¼¯ (å–ä»£åŸæœ¬çš„ splice ç§»é™¤) ---
                    for (let i = state.survivors.length - 1; i >= 0; i--) {
                        let s = state.survivors[i];
                        if (s.isEvacuating && !s.hasArrived) { // åªæœ‰å°šæœªæŠµé”çš„æ‰éœ€è¦ç§»å‹•
                            const dest = getTriageDest('green'); // ç¶ è‰²æ¨™ç±¤å»ç¶ è‰²å€æˆ–å¾…å‘½å€

                            const dx = dest.x - s.x;
                            const dy = dest.y - s.y;
                            const dist = Math.hypot(dx, dy);

                            if (dist < 10) {
                                s.isEvacuating = false;
                                s.hasArrived = true; // æ¨™è¨˜å·²æŠµé”
                                addFeedback(s.x, s.y, "æŠµé”å¾…å‘½å€", "#2ecc71");
                                // ç¶ è‰²å‚·æ‚£è‡ªè¡Œç§»å‹•åˆ°ç¶ è‰²å€ï¼Œä¸”å¯¦éš›å‚·æƒ…ç¢ºå¯¦ç‚ºç¶ è‰²
                                if (s.triageTag === 'green' && s.data.severity === 'green') {
                                    if (!s.hasBeenMovedScored) {
                                        setScore(prev => prev + 100);
                                        addFeedback(s.x, s.y - 50, "ç§»å‹•æ­£ç¢º +100", "#f1c40f");
                                        s.hasBeenMovedScored = true; // æ¨™è¨˜å·²åŠ éç§»å‹•åˆ†
                                    }
                                }
                                checkTriageCounts(); // è‡ªè¡Œç§»å‹•æŠµé”å¾Œæª¢æŸ¥è¨ˆæ•¸
                            } else {
                                s.x += (dx / dist) * 0.4; // è¼•å‚·ç§»å‹•é€Ÿåº¦
                                s.y += (dy / dist) * 0.4;
                            }
                        }
                    }
                    // --- ä¿®æ­£ï¼šæ•‘è­·è»Šé€²å ´èˆ‡é›¢é–‹é‚è¼¯ (æ•´åˆåœ¨ update è¿´åœˆå…§) ---
                    for (let i = state.emergencyVehicles.length - 1; i >= 0; i--) {
                        let v = state.emergencyVehicles[i];

                        // 1. é€²å ´é‚è¼¯ (arriving) - è¨­å®šç´„ 10 ç§’ (600 frames) æŠµé”
                        if (['ambulance', 'mini_bus'].includes(v.type) && v.state === 'arriving') {
                            const dx = v.targetX - v.x;
                            const dy = v.targetY - v.y;
                            const dist = Math.hypot(dx, dy);

                            // è‹¥å°šæœªè¨­å®šé€Ÿåº¦ï¼Œæ ¹æ“šè·é›¢è¨ˆç®—é€Ÿåº¦ (Distance / 600 frames)
                            // 600 frames / 60fps = 10ç§’
                            if (!v.speed) {
                                // é™åˆ¶æœ€å°é€Ÿåº¦ 0.5 é¿å…è·é›¢éè¿‘æ™‚åœæ»¯
                                v.speed = Math.max(0.5, dist / 600);
                            }

                            if (dist <= v.speed) {
                                v.x = v.targetX;
                                v.y = v.targetY;
                                v.state = 'waiting'; // æŠµé”å¾Œè½‰ç‚ºå¾…å‘½
                                v.angle = 0; // è½‰æ­£
                            } else {
                                v.x += (dx / dist) * v.speed;
                                v.y += (dy / dist) * v.speed;
                            }
                        }
                        // 2. é›¢å ´é‚è¼¯ (departing)
                        else if (['ambulance', 'mini_bus'].includes(v.type) && v.state === 'departing') {
                            const oldX = v.x;
                            v.x -= 5; // å‘å·¦å¿«é€Ÿç§»å‹• (é›¢å ´é€Ÿåº¦è¼ƒå¿«)

                            // åŒæ­¥ç§»å‹•å°æ‡‰çš„é˜»æ“‹å¡Šï¼Œé¿å…ç•™ä¸‹éš±å½¢ç‰†
                            const block = state.obstacles.find(o =>
                                o.type === 'vehicle_block' &&
                                Math.abs(o.x - oldX) < 10 &&
                                Math.abs(o.y - v.y) < 10
                            );
                            if (block) {
                                block.x = v.x; // è·Ÿè‘—è»Šå­ç§»å‹•
                            }

                            if (v.x < -200) {
                                // é›¢é–‹ç•«é¢å¾Œç§»é™¤
                                state.emergencyVehicles.splice(i, 1);
                                // åŒæ™‚ç§»é™¤å°æ‡‰çš„é˜»æ“‹å¡Š (å¦‚æœæœ‰)
                                const blockIndex = state.obstacles.findIndex(o => o.type === 'vehicle_block' && Math.abs(o.x - v.x) < 20 && Math.abs(o.y - v.y) < 20);
                                if (blockIndex > -1) state.obstacles.splice(blockIndex, 1);
                            }
                        }
                    }
                    state.survivors.forEach(s => {
                        if (s.tourniquetTimer !== null && s.tourniquetTimer > 0) {
                            s.tourniquetTimer -= 1 / 240;
                            if (s.tourniquetTimer <= 0) {
                                s.tourniquetTimer = 0;
                                s.isDead = true;
                                //s.triageTag = 'black';
                                s.data.consciousness = 'ç„¡æ„è­˜';
                                s.data.resp = 'ç„¡';
                                s.data.pulse = 'ç„¡';
                                s.data.injuryText = 'å¤±è¡€éå¤šæ­»äº¡';
                                s.data.severity = 'black';
                                addFeedback(s.x, s.y, "å‚·æ‚£æ­»äº¡", "#000");
                                checkTriageCounts(); // å‚·æ‚£æ­»äº¡è½‰é»‘å¡å¾Œæª¢æŸ¥è¨ˆæ•¸
                            }
                        }
                    });

                    const isTryingToMove = state.keys.w || state.keys.s || state.keys.a || state.keys.d;
                    let speed = p.speed;

                    if (isTryingToMove) {
                        // â˜…â˜…â˜… ä¿®æ”¹ï¼šè‹¥æœ‰ SP Buff (spBuffTimer > 0) å‰‡ä¸æ‰£ SP â˜…â˜…â˜…
                        if (state.spBuffTimer <= 0) {
                            state.stats.sp = Math.max(0, state.stats.sp - 0.2);
                        } else {
                            // Buff æœŸé–“ SP ç¶­æŒå…¨æ»¿æˆ–ç·©æ…¢æ¢å¾©
                            state.stats.sp = Math.min(state.stats.maxSp, state.stats.sp + 1);
                        }
                        if (state.stats.sp <= 0) speed = speed * 0.5;
                    } else {
                        state.stats.sp = Math.min(state.stats.maxSp, state.stats.sp + 0.1);
                    }
                    // ====== æ–°å¢ï¼šæŒ‡æ®ç«™ HP æ¢å¾©é‚è¼¯ ======
                    let isInCommandPost = false;
                    const commandPost = state.triageMats.find(m => m.color === 'command_post');
                    if (commandPost) {
                        // æª¢æŸ¥ç©å®¶æ˜¯å¦åœ¨æŒ‡æ®ç«™å€åŸŸå…§
                        if (p.x > commandPost.x && p.x < commandPost.x + commandPost.w &&
                            p.y > commandPost.y && p.y < commandPost.y + commandPost.h) {
                            isInCommandPost = true;
                        }
                    }
                    if (isInCommandPost) {
                        // æ¯ 30 å¹€ (ç´„ 0.5 ç§’) æ¢å¾©ä¸€æ¬¡ HPï¼Œæ¯æ¬¡æ¢å¾© 1 é»
                        if (state.frameCount % 30 === 0) {
                            const newHp = Math.min(state.stats.maxHp, state.stats.hp + 1);
                            if (newHp > state.stats.hp) {
                                state.stats.hp = newHp;
                                addFeedback(p.x, p.y - 60, "+1 HP (æŒ‡æ®ç«™)", "#2ecc71");

                            }

                        }
                        // 2. â˜…â˜…â˜… æ–°å¢ MP æ¢å¾©ï¼šæ¯ 60 å¹€ (ç´„ 1 ç§’) æ¢å¾© 1 é» â˜…â˜…â˜…
                        if (state.frameCount % 60 === 0) {
                            const newMp = Math.min(state.stats.maxMp, state.stats.mp + 1);
                            if (newMp > state.stats.mp) {
                                state.stats.mp = newMp;
                                // æç¤ºä½ç½®ç¨å¾®å¾€ä¸Š (y - 80)ï¼Œé¿å…èˆ‡ HP æç¤ºé‡ç–Šï¼Œä½¿ç”¨è—è‰² (#3498db)
                                addFeedback(p.x, p.y - 80, "+1 MP (æŒ‡æ®ç«™)", "#3498db");
                            }
                        }
                        // ä¸¦ä¸”åŠ é€Ÿæ¢å¾© SP (è€åŠ›)
                        state.stats.sp = Math.min(state.stats.maxSp, state.stats.sp + 0.5);
                    }
                    // ========================================

                    if (state.keys.w) { nextY -= speed; p.dir = 1; p.moving = true; }
                    if (state.keys.s) { nextY += speed; p.dir = 0; p.moving = true; }
                    if (state.keys.a) { nextX -= speed; p.dir = 2; p.moving = true; }
                    if (state.keys.d) { nextX += speed; p.dir = 3; p.moving = true; }
                    // åªæœ‰åœ¨æ²’æœ‰æŒ‰éµç›¤çš„æ™‚å€™ï¼Œæ‰åŸ·è¡Œæ»‘é¼ å°èˆª
                    if (p.movingToTarget && !isTryingToMove) {
                        const dx = p.targetX - p.x;
                        const dy = p.targetY - p.y;
                        const dist = Math.hypot(dx, dy);

                        // å¦‚æœè·é›¢å°æ–¼ç§»å‹•é€Ÿåº¦ï¼Œç›´æ¥æŠµé”
                        if (dist <= speed) {
                            nextX = p.targetX;
                            nextY = p.targetY;
                            p.movingToTarget = false; // åœæ­¢ç§»å‹•
                            // p.moving = false; // é€™è£¡ä¸è¨­ç‚º falseï¼Œè®“ä¸‹æ–¹ç¢°æ’åµæ¸¬å¾Œçš„è³¦å€¼å»è™•ç†
                        } else {
                            // è¨ˆç®—ç§»å‹•å‘é‡
                            nextX += (dx / dist) * speed;
                            nextY += (dy / dist) * speed;
                            p.moving = true;

                            // æ ¹æ“šç§»å‹•æ–¹å‘æ›´æ–°è§’è‰²é¢å‘ (dir)
                            if (Math.abs(dx) > Math.abs(dy)) {
                                p.dir = dx > 0 ? 3 : 2; // å³ : å·¦
                            } else {
                                p.dir = dy > 0 ? 0 : 1; // ä¸‹ : ä¸Š
                            }
                        }
                    }
                    state.camera.x = p.x - GAME_WIDTH / 2;
                    state.camera.y = p.y - GAME_HEIGHT / 2;
                    state.camera.x = Math.max(0, Math.min(state.camera.x, WORLD_WIDTH - GAME_WIDTH)); // æ›´æ–°é‚Šç•Œ
                    state.camera.y = Math.max(0, Math.min(state.camera.y, 1200 - GAME_HEIGHT));
                    // â˜…â˜…â˜… Joystick ç§»å‹•é‚è¼¯æ•´åˆ â˜…â˜…â˜…
                    if (joystickRef.current.active) {
                        const { vecX, vecY } = joystickRef.current;
                        if (Math.abs(vecX) > 0.1 || Math.abs(vecY) > 0.1) {
                            // æ ¹æ“šæ¨å‹•å¹…åº¦æ±ºå®šé€Ÿåº¦ (0.5 ~ 1.0 å€é€Ÿ)
                            const pushStrength = Math.min(1, Math.hypot(vecX, vecY));
                            const currentSpeed = speed * (0.5 + 0.5 * pushStrength);

                            nextX += vecX * currentSpeed;
                            nextY += vecY * currentSpeed;
                            p.moving = true;

                            // æ›´æ–°é¢å‘
                            if (Math.abs(vecX) > Math.abs(vecY)) {
                                p.dir = vecX > 0 ? 3 : 2;
                            } else {
                                p.dir = vecY > 0 ? 0 : 1;
                            }
                            // æ–æ¡¿æ“ä½œæ™‚å–æ¶ˆæ»‘é¼ é»æ“Šç§»å‹•
                            p.movingToTarget = false;
                        }
                    }
                    state.decorations.forEach(d => {
                        if (d.type === 'oil') {
                            const dist = Math.hypot(p.x - d.x, p.y - d.y);
                            if (dist < d.r) {
                                state.stats.hp = Math.max(0, state.stats.hp - 0.05);
                                if (state.frameCount % 60 === 0) {
                                    addFeedback(p.x, p.y - 30, "å—å‚·! (æ²¹æ¼¬)", "#e74c3c");
                                }
                            }
                        }
                    });

                    let pBox = { x: nextX - 5, y: nextY - 5, w: 10, h: 10 };
                    let collide = false;

                    // --- ç«ç„°ç¢°æ’é‚è¼¯ ---
                    for (let h of state.hazards) {
                        const dist = Math.hypot(nextX - h.x, nextY - h.y);
                        // å¦‚æœè·é›¢å°æ–¼ç«ç„°åŠå¾‘ (ç¨å¾®å¯¬ä¸€é»ï¼Œè®“è¦–è¦ºä¸Šç¢°åˆ°é¡è‰²å°±æ“‹ä½)
                        if (dist < h.r + 10) {
                            collide = true; // è¦–ç‚ºç¢°æ’ï¼Œç„¡æ³•å‰é€²
                            // æ‰£è¡€
                            state.stats.hp = Math.max(0, state.stats.hp - 0.5);
                            if (state.frameCount % 30 === 0) {
                                addFeedback(p.x, p.y - 40, "é«˜æº«! ç„¡æ³•é è¿‘!", "#e74c3c");
                            }
                            break;
                        }
                    }

                    for (let o of state.obstacles) {
                        if (o.type === 'metal_debris') {
                            if (pBox.x < o.x + o.w && pBox.x + 10 > o.x && pBox.y < o.y + o.h && pBox.y + 10 > o.y) {
                                state.stats.hp = Math.max(0, state.stats.hp - 0.1);
                                if (state.frameCount % 45 === 0) addFeedback(p.x, p.y - 30, "å‰²å‚·! (é‡‘å±¬)", "#e74c3c");
                            }
                        }

                        let obBox = o.type === 'guardrail' ? { x: o.x, y: o.y, w: o.w, h: o.h } : o.hitbox;
                        if (!obBox) obBox = { x: o.x, y: o.y, w: o.w, h: o.h };
                        if (pBox.x < obBox.x + obBox.w && pBox.x + pBox.w > obBox.x && pBox.y < obBox.y + obBox.h && pBox.y + pBox.h > obBox.y) {
                            collide = true; break;
                        }
                    }
                    if (!collide) {
                        p.x = nextX; p.y = nextY;
                    } else {
                        // â˜…â˜…â˜… æ–°å¢ï¼šè‹¥ç™¼ç”Ÿç¢°æ’ï¼Œåœæ­¢æ»‘é¼ è‡ªå‹•ç§»å‹•ï¼Œé¿å…å¡ä½ â˜…â˜…â˜…
                        if (p.movingToTarget) {
                            p.movingToTarget = false;
                            p.moving = false;
                        }
                    }
                    if (p.moving) { p.animTimer++; p.frame = Math.floor(p.animTimer / 5); }
                    state.hazards.forEach(h => {
                        // åªæœ‰æœªè¢«æ»…ç«çš„ç«ç„°æœƒæŒçºŒç”¢ç”Ÿç…™éœ§
                        if (h.type === 'fire' && !h.beingExtinguished) {
                            // æ§åˆ¶ç…™éœ§ç”¢ç”Ÿé »ç‡ (0.7 = 30% æ©Ÿç‡æ¯å¹€ç”¢ç”Ÿ)
                            if (Math.random() > 0.7) {
                                state.particles.push({
                                    x: h.x + (Math.random() - 0.5) * h.r,   // åœ¨ç«ç„°ç¯„åœå…§éš¨æ©Ÿä½ç½®
                                    y: h.y - h.r * 0.5,                     // å¾ç«ç„°ä¸ŠåŠéƒ¨å†’å‡º
                                    vx: 0.5 + (Math.random() - 0.5) * 0.5,  // å¾®å¾®å‘å³é£„ (æ¨¡æ“¬é¢¨å‘)
                                    vy: -1.5 - Math.random(),               // å‘ä¸Šå‡èµ·
                                    life: 100 + Math.random() * 60,         // ç…™éœ§å£½å‘½è¼ƒé•·
                                    size: 5 + Math.random() * 8,            // åˆå§‹å¤§å°
                                    // éš¨æ©Ÿæ·±ç°è‰²å¸¶é€æ˜åº¦
                                    color: `rgba(${60 + Math.random() * 40}, ${60 + Math.random() * 40}, ${60 + Math.random() * 40}, ${0.3 + Math.random() * 0.2})`,
                                    type: 'smoke' // æ¨™è¨˜ç‚ºç…™éœ§
                                });
                            }
                        }
                    });

                    state.survivors.forEach(s => {
                        if (s.data.isBleeding && Math.random() > 0.8) {
                            state.particles.push({
                                x: s.x + (Math.random() - 0.5) * 8,
                                y: s.y + (Math.random() - 0.5) * 8,
                                vx: (Math.random() - 0.5) * 0.1,
                                vy: (Math.random() - 0.5) * 0.1,
                                life: 15 + Math.random() * 10,
                                size: 1.5,
                                color: 'rgba(231, 76, 60, 0.9)',
                                type: 'blood',
                            });
                        }
                    });

                    for (let i = state.particles.length - 1; i >= 0; i--) {
                        let pt = state.particles[i];
                        pt.x += pt.vx; pt.y += pt.vy;
                        pt.life--;
                        if (pt.type === 'smoke') {
                            pt.size += 0.15; // ç…™éœ§éš¨æ™‚é–“æ“´æ•£è®Šå¤§
                            pt.vx += 0.005;  // éš¨é¢¨åŠ é€Ÿ (å¯é¸)
                        } else {
                            if (!pt.color.includes('150')) pt.size = Math.max(0, pt.size - 0.05);
                            else pt.size += 0.1;
                        }
                        if (pt.life <= 0) {
                            if (pt.color.includes('150')) {
                                let car = state.obstacles[Math.floor(Math.random() * state.obstacles.length)];
                                if (car && car.type !== 'guardrail' && car.type !== 'wall') {
                                    pt.x = car.x + car.w / 2; pt.y = car.y + car.h / 2; pt.life = rand(50, 150); pt.size = rand(2, 5);
                                }
                            } else {
                                state.particles.splice(i, 1);
                            }
                        }
                    }

                    for (let i = state.feedbacks.length - 1; i >= 0; i--) {
                        let f = state.feedbacks[i];
                        f.y += f.vy; f.life--;
                        if (f.life <= 0) state.feedbacks.splice(i, 1);
                    }

                    if (state.frameCount % 10 === 0) {
                        setPlayerStatsUI({ ...state.stats });
                        // checkTriageCounts() // å·²ç¶“åœ¨ç‹€æ…‹æ”¹è®Šæ™‚å‘¼å«ï¼Œé€™è£¡å¯ä»¥çœç•¥ä»¥æ¸›å°‘ä¸å¿…è¦çš„æ¸²æŸ“
                    }
                };

                const draw = () => {
                    ctx.save();
                    ctx.translate(-state.camera.x, -state.camera.y);

                    // èƒŒæ™¯æ›´æ–°å¯¬åº¦
                    drawRect(0, 0, WORLD_WIDTH, 1200, PALETTE.asphalt);

                    if (state.placementMode.active) {
                        const zoneWidth = 50 + LEFT_EXPANSION; // æ¶ˆé˜²è»Šä½ç½®

                        ctx.save();
                        // 1. åŠé€æ˜ç¶ è‰²èƒŒæ™¯
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.1)';
                        ctx.fillRect(0, 0, zoneWidth, 1200);

                        // 2. é‚Šç•Œè™›ç·š
                        ctx.strokeStyle = '#2ecc71';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([15, 10]); // è™›ç·šæ¨£å¼
                        ctx.beginPath();
                        ctx.moveTo(zoneWidth, 0);
                        ctx.lineTo(zoneWidth, 1200);
                        ctx.stroke();

                        // 3. æ–‡å­—æç¤º
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.6)';
                        ctx.font = 'bold 30px "Segoe UI"';
                        ctx.textAlign = 'center';
                        ctx.fillText("å®‰å…¨ä½œæ¥­å€åŸŸ (ç”±æ­¤è™•é–‹å§‹éƒ¨ç½²)", zoneWidth / 2, 200);

                        ctx.restore();
                    }
                    // â†‘â†‘â†‘â†‘â†‘â†‘ ç¶ è‰²åŠé€æ˜å€åŸŸç¨‹å¼ç¢¼ä½ç½® (ç”±æ­¤çµæŸ) â†‘â†‘â†‘â†‘â†‘â†‘

                    ctx.fillStyle = PALETTE.markingWhite;
                    const laneCount = 8;
                    const laneH = (1200 - 80) / laneCount;
                    for (let l = 1; l < laneCount; l++) {
                        let ly = 40 + l * laneH;
                        for (let lx = 0; lx < WORLD_WIDTH; lx += 80) ctx.fillRect(lx, ly - 2, 40, 4);
                    }
                    ctx.fillStyle = PALETTE.markingYellow;
                    ctx.fillRect(0, 40, WORLD_WIDTH, 4);
                    ctx.fillRect(0, 1200 - 44, WORLD_WIDTH, 4);

                    drawTriageMats(state.triageMats);

                    state.decorations.forEach(d => {
                        if (d.type === 'skid') {
                            ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.angle); drawRect(0, 0, d.w, d.h, 'rgba(0,0,0,0.6)'); ctx.restore();
                        } else if (d.type === 'oil') {
                            ctx.fillStyle = PALETTE.oil; ctx.beginPath(); ctx.ellipse(d.x, d.y, d.r, d.r * 0.6, 0, 0, Math.PI * 2); ctx.fill();
                        } else if (d.type === 'glass') { drawRect(d.x, d.y, d.size, d.size, PALETTE.glass); }
                    });

                    state.hazards.forEach(h => drawFire(h));

                    state.emergencyVehicles.forEach(v => drawEmergencyVehicle(v));
                    drawFirefighters(state.firefightingSquads);
                    drawRescueSquads(state.rescueSquads); // æ–°å¢é€™è¡Œ
                    const renderList = [];
                    state.obstacles.forEach(o => {
                        if (o.type !== 'vehicle_block') renderList.push({ type: 'obstacle', obj: o, y: o.y + o.h })
                    });

                    state.survivors.forEach(s => {
                        let isLifted = false;
                        if (s.isBeingCarried) {
                            const carrierGroup = state.npcGroups.find(g => g.target === s && g.state === 'carrying');
                            if (carrierGroup) isLifted = true;
                        }

                        // â˜…â˜…â˜… å¦‚æœå·²ç¶“ä¸Šæ•‘è­·è»Š (onAmbulance)ï¼Œå°±ä¸å†ç¹ªè£½ â˜…â˜…â˜…
                        if ((!isLifted || s.isEvacuating) && !s.onAmbulance) {
                            renderList.push({ type: 'survivor', obj: s, y: s.y })
                        }
                    });
                    // â˜…â˜…â˜… å°‡èƒ½é‡é£²æ–™åŠ å…¥ç¹ªè£½åˆ—è¡¨ (Render List) â˜…â˜…â˜…
                    state.energyDrinks.forEach(d => {
                        renderList.push({ type: 'energy_drink', obj: d, y: d.y });
                    });

                    renderList.push({ type: 'player', y: state.player.y });
                    renderList.sort((a, b) => a.y - b.y);

                    renderList.forEach(item => {
                        if (item.type === 'obstacle') {
                            let o = item.obj;
                            if (o.type === 'metal_debris') {
                                ctx.save(); ctx.translate(o.x + o.w / 2, o.y + o.h / 2); ctx.rotate(o.angle);
                                ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.moveTo(-o.w / 2, -o.h / 2); ctx.lineTo(o.w / 2, -o.h / 4); ctx.lineTo(0, o.h / 2); ctx.fill();
                                ctx.restore();
                            } else if (o.type === 'guardrail') {
                                drawRect(o.x, o.y, o.w, o.h, '#7f8c8d'); drawRect(o.x, o.y + 5, o.w, 10, '#95a5a6');
                                for (let gx = 0; gx < WORLD_WIDTH; gx += 100) drawRect(gx, o.y, 10, o.h, '#555');
                            } else if (o.type !== 'wall') {
                                drawRect(o.x + 5, o.y + 5, o.w, o.h, 'rgba(0,0,0,0.5)'); drawRect(o.x, o.y, o.w, o.h, o.color);
                                ctx.fillStyle = '#2c3e50';
                                if (o.isBreached) {
                                    ctx.fillStyle = '#555';
                                }
                                let cabinW = o.rotated ? o.w * 0.6 : o.w - 4; let cabinH = o.rotated ? o.h - 4 : o.h * 0.5;
                                let cabinX = o.rotated ? o.x + (o.w - cabinW) / 2 : o.x + 2; let cabinY = o.rotated ? o.y + 2 : o.y + (o.h - cabinH) / 2;
                                drawRect(cabinX, cabinY, cabinW, cabinH, o.color);
                                ctx.fillStyle = '#2c3e50';
                                if (o.rotated) { drawRect(cabinX, cabinY, 4, cabinH); drawRect(cabinX + cabinW - 4, cabinY, 4, cabinH); }
                                else { drawRect(cabinX, cabinY, cabinW, 4); drawRect(cabinX, cabinY + cabinH - 4, cabinW, 4); }

                                if (o.isBreached) {
                                    ctx.fillStyle = '#000';
                                    ctx.fillText("ç ´å£", o.x + o.w / 2 - 10, o.y + o.h / 2);
                                } else if (o.breakTimer > 0) {
                                    ctx.fillStyle = '#e67e22';
                                    ctx.fillText(`${Math.ceil(o.breakTimer / 60)}s`, o.x + o.w / 2 - 5, o.y + o.h / 2);
                                }
                            }
                        } else if (item.type === 'survivor') {
                            drawSurvivorHighRes(item.obj);
                            let s = item.obj;
                            ctx.fillStyle = '#fff'; ctx.font = '10px Arial';
                            if (s.tourniquetTimer !== null && s.tourniquetTimer > 0) {
                                ctx.fillStyle = '#e74c3c'; ctx.font = 'bold 12px Arial'; ctx.fillText(Math.ceil(s.tourniquetTimer) + "s", s.x - 10, s.y - 25);
                            } else if (s.isDead) {
                                ctx.fillStyle = '#666'; ctx.font = 'bold 10px Arial'; ctx.fillText("DEAD", s.x - 12, s.y - 15);
                            } else if (s.triageTag) {
                                let tagText = "UNK";
                                if (s.triageTag === 'green') tagText = "III";
                                if (s.triageTag === 'yellow') tagText = "II";
                                if (s.triageTag === 'red') tagText = "I";
                                if (s.triageTag === 'black') tagText = "0";
                                ctx.fillText(tagText, s.x - 4, s.y - 10);
                            } else {
                                if (Math.floor(Date.now() / 600) % 2 === 0) { ctx.fillText('HELP', s.x - 10, s.y - 15); }
                            }
                        }
                        // â˜…â˜…â˜… æ–°å¢ï¼šèƒ½é‡é£²æ–™ç¹ªè£½é‚è¼¯ â˜…â˜…â˜…
                        else if (item.type === 'energy_drink') {
                            const d = item.obj;
                            ctx.save();
                            // æµ®å‹•å‹•ç•«
                            const floatY = Math.sin(state.frameCount * 0.1 + d.floatOffset) * 5;
                            ctx.translate(d.x, d.y + floatY);

                            // é™°å½±
                            ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            ctx.beginPath(); ctx.ellipse(0, 15 - floatY, 10, 4, 0, 0, Math.PI * 2); ctx.fill();

                            // ç½èº«
                            drawRoundedRect(-10, -15, 20, 30, 4, '#3498db'); // è—è‰²ç½é«”
                            // ç½è“‹
                            ctx.fillStyle = '#bdc3c7';
                            ctx.fillRect(-10, -15, 20, 4);
                            // é–ƒé›»æ¨™èªŒ
                            ctx.fillStyle = '#f1c40f';
                            ctx.beginPath();
                            ctx.moveTo(2, -8); ctx.lineTo(-6, 2); ctx.lineTo(0, 2);
                            ctx.lineTo(-2, 10); ctx.lineTo(6, 0); ctx.lineTo(0, 0);
                            ctx.closePath(); ctx.fill();

                            // ç™¼å…‰ç‰¹æ•ˆ
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 10;
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(-10, -15, 20, 30);

                            ctx.restore();
                        }
                        else if (item.type === 'player') {
                            drawFirefighterHighRes(state.player.x, state.player.y, 0, '#1a253a', state.frameCount, state.player.moving);

                            // â˜…â˜…â˜… æ–°å¢ï¼šSP Buff è¦–è¦ºç‰¹æ•ˆ (è…³ä¸‹å…‰ç’°) â˜…â˜…â˜…
                            if (state.spBuffTimer > 0) {
                                ctx.save();
                                ctx.translate(state.player.x, state.player.y);
                                ctx.globalCompositeOperation = 'lighter';
                                ctx.fillStyle = `rgba(0, 255, 255, ${0.3 + Math.sin(state.frameCount * 0.2) * 0.2})`;
                                ctx.beginPath();
                                ctx.ellipse(0, 5, 20, 10, 0, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }

                        }

                    });

                    drawNPCGroups(state.npcGroups);
                    drawStaticNpcs(state.staticNpcs);

                    state.particles.forEach(pt => {
                        ctx.fillStyle = pt.color || 'rgba(150, 150, 150, 0.3)';
                        ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI * 2); ctx.fill();
                    });

                    drawPlacementPreview(state.placementMode);

                    // â˜…â˜…â˜… åœ¨æ­¤è™•å‘¼å«æ–°å¢çš„å‡½å¼ (å»ºè­°æ”¾åœ¨ drawPlacementPreview ä¹‹å¾Œï¼Œé¸å–®ä¹‹å‰) â˜…â˜…â˜…
                    drawInteractionIndicators();
                    drawMenu(state.interactionMenu);
                    drawSurvivorInfo(state.player);

                    state.feedbacks.forEach(f => {
                        ctx.fillStyle = f.color;
                        ctx.font = 'bold 14px "Courier New"';
                        ctx.shadowColor = 'black';
                        ctx.shadowBlur = 2;
                        ctx.fillText(f.text, f.x - 20, f.y);
                        ctx.shadowBlur = 0;
                    });

                    ctx.restore();

                    ctx.save();
                    let time = Date.now();
                    let policeAlpha = (Math.sin(time / 200) + 1) / 2 * 0.1;
                    ctx.fillStyle = `rgba(0, 0, 255, ${policeAlpha})`; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                    if (Math.sin(time / 200 + Math.PI) > 0) { ctx.fillStyle = `rgba(255, 0, 0, ${policeAlpha})`; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); }
                    ctx.restore();
                };

                const loop = () => {
                    update();
                    draw();
                    if (!gameState.current.isGameOver) {
                        state.animationFrameId = requestAnimationFrame(loop);
                    }
                };
                loop();

                return () => {
                    window.removeEventListener('resize', resize);
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                    canvas.removeEventListener('click', handleCanvasClick);
                    window.removeEventListener('contextmenu', handleContextMenu);
                    // ç§»é™¤ç›£è½ // ç§»é™¤ mousemove
                    window.removeEventListener('mousemove', handleMouseMove);
                    cancelAnimationFrame(state.animationFrameId);
                };
           }, [gameOver, gameStarted]); 
            useEffect(() => {
                if (gameOver) return;

                // è¨ˆç®—ç›®å‰å„é …é€²åº¦
                const placedCount = Object.values(triageCounts).reduce((a, b) => a + b, 0);
                const currentEvacuatedCount = gameState.current.survivors.filter(s => s.onAmbulance).length;
                const deadCount = gameState.current.survivors.filter(s => s.triageTag === 'black').length;

                // åˆ¤æ–·æ¢ä»¶ï¼š
                // 1. æª¢å‚·äººæ•¸ = ç¸½äººæ•¸
                // 2. å®‰ç½®äººæ•¸ = ç¸½äººæ•¸
                // 3. å¾Œé€äººæ•¸ + æ­»äº¡äººæ•¸ = ç¸½äººæ•¸ (å› é»‘å¡ç„¡æ³•å¾Œé€ï¼Œæ•…å°‡æ­»äº¡è¦–ç‚ºæ­¤é …å·²è™•ç†)
                const isTriageDone = survivorCount >= totalSurvivors;
                const isPlacementDone = placedCount >= totalSurvivors;
                const isEvacDone = (currentEvacuatedCount + deadCount) >= totalSurvivors;

                // åªè¦ä¸‰å€‹ OBJ éƒ½å®Œæˆï¼Œå°±è§¸ç™¼ Mission Complete
                if (isTriageDone && isPlacementDone && isEvacDone) {
                    setMissionComplete(true);

                    // --- è¨ˆç®—è©³ç´°çµç®—æ•¸æ“š ---
                    const survivors = gameState.current.survivors;

                    // 1. æª¢å‚·æ­£ç¢ºç‡
                    const triageStats = {
                        green: { correct: 0, total: 0 },
                        yellow: { correct: 0, total: 0 },
                        red: { correct: 0, total: 0 },
                        black: { correct: 0, total: 0 }
                    };

                    // 4. é™¤æ±™çµ±è¨ˆ
                    let totalContaminated = 0;

                    // 5. ç´…è‰²å„ªå…ˆå¾Œé€çµ±è¨ˆ
                    let totalInitialReds = 0;
                    let evacuatedReds = 0;

                    survivors.forEach(s => {
                        // æª¢å‚·çµ±è¨ˆ (æ¯”è¼ƒ æœ€çµ‚è²¼çš„æ¨™ç±¤ vs ç•¶å‰å¯¦éš›å‚·æƒ…)
                        // æ³¨æ„ï¼šå¦‚æœå‚·æ‚£æ­»äº¡ï¼Œå¯¦éš›å‚·æƒ…æœƒè®Šç‚º blackï¼Œè‹¥ç©å®¶è²¼ black ç®—æ­£ç¢º
                        const actual = s.data.severity;
                        const tagged = s.triageTag;

                        if (triageStats[actual]) {
                            triageStats[actual].total++;
                            if (tagged === actual) {
                                triageStats[actual].correct++;
                            }
                        }

                        // é™¤æ±™çµ±è¨ˆ
                        if (s.data.wasContaminated) {
                            totalContaminated++;
                        }

                        // ç´…è‰²å„ªå…ˆçµ±è¨ˆ
                        // é‚è¼¯ï¼šè¨ˆç®—æœ‰å¤šå°‘ã€Œåˆå§‹ç‚ºç´…è‰²ã€çš„å‚·æ‚£ï¼Œæœ€çµ‚æˆåŠŸè¢«å¾Œé€
                        if (s.data.initialSeverity === 'red') {
                            totalInitialReds++;
                            if (s.onAmbulance) {
                                evacuatedReds++;
                            }
                        }
                    });

                    // 2. éŠæˆ²æ™‚é–“
                    const timeSeconds = Math.floor(gameState.current.frameCount / 60);

                    // 3. æ²»ç™‚æ­£ç¢ºç‡ (æ­¢è¡€ + å‘¼å¸é“ åˆä½µè¨ˆç®—)
                    const treatTotal = statsTracker.current.tourniquet.total + statsTracker.current.airway.total;
                    const treatCorrect = statsTracker.current.tourniquet.correct + statsTracker.current.airway.correct;

                    setResultStats({
                        triage: triageStats,
                        timeSeconds: timeSeconds,
                        treatment: { correct: treatCorrect, total: treatTotal },
                        decon: { correct: statsTracker.current.deconCount, total: totalContaminated },
                        redEvac: { correct: evacuatedReds, total: totalInitialReds }
                    });
                }
            }, [survivorCount, triageCounts, evacuatedCount, gameOver, updateCount]); // ç•¶æª¢å‚·æ•¸æˆ–å®‰ç½®æ•¸è®ŠåŒ–æ™‚æª¢æŸ¥

            const getPct = (correct, total) => {
                if (total === 0) return "100%"; // è‹¥ç„¡è©²é¡åˆ¥å‚·æ‚£ï¼Œè¦–ç‚ºæ»¿åˆ†
                return Math.round((correct / total) * 100) + "%";
            };
            // å¦‚æœéŠæˆ²é‚„æ²’é–‹å§‹ï¼Œåªæ¸²æŸ“é–‹é ­å‹•ç•«
            if (!gameStarted) {
                return <IntroScreen onStart={() => setGameStarted(true)} />;
            }
            return (
                <div className="flex justify-center items-center h-screen bg-[#050505] text-white overflow-hidden font-mono relative">
                    <div className="relative shadow-[0_0_50px_rgba(0,0,20,0.5)] border-2 border-[#333] bg-[#111]">
                        <canvas ref={canvasRef} className="block image-pixelated cursor-default" />

                        {gameOver && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-50 animate-fade-in">
                                <h1 className="text-5xl text-red-600 font-bold mb-8 tracking-widest drop-shadow-[0_0_10px_rgba(255,0,0,0.8)] animate-pulse">
                                    GAME OVER
                                </h1>
                                <div className="text-gray-400 mb-8 text-center text-sm">
                                    ä»»å‹™å¤±æ•—ï¼šç”Ÿå‘½è·¡è±¡æ¶ˆå¤±<br />
                                    ç¸½è¨ˆæª¢å‚·ï¼š{survivorCount}/{totalSurvivors}
                                </div>
                                <button
                                    onClick={handleRestart}
                                    className="px-8 py-3 bg-white text-black font-bold text-lg hover:bg-gray-300 hover:scale-105 transition transform rounded shadow-lg border-2 border-transparent hover:border-gray-500"
                                >
                                    é‡æ–°éŠæˆ²
                                </button>
                            </div>
                        )}
                        {/* â˜…â˜…â˜… ä¿®æ”¹ï¼šMission Complete çµç®—ç•«é¢ â˜…â˜…â˜… */}
                        {missionComplete && resultStats && (
                            <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center z-[100] animate-fade-in backdrop-blur-md p-8">
                                <h1 className="text-5xl text-yellow-400 font-bold mb-2 tracking-widest drop-shadow-[0_0_20px_rgba(253,224,71,0.6)]" style={{ fontFamily: 'Impact, sans-serif' }}>
                                    MISSION COMPLETE
                                </h1>
                                <div className="text-gray-400 mb-6 text-sm">ä»»å‹™è€—æ™‚: {Math.floor(resultStats.timeSeconds / 60)}åˆ† {resultStats.timeSeconds % 60}ç§’</div>

                                <div className="grid grid-cols-2 gap-x-12 gap-y-6 w-full max-w-4xl">
                                    {/* 1. æª¢å‚·æ­£ç¢ºç‡é¢æ¿ */}
                                    <div className="bg-gray-800/50 p-6 rounded-lg border border-gray-700">
                                        <h3 className="text-xl font-bold text-blue-400 mb-4 border-b border-gray-600 pb-2">æª¢å‚·æ­£ç¢ºç‡</h3>
                                        <div className="space-y-3">
                                            <div className="flex justify-between items-center">
                                                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-green-500"></span> ç¶ è‰²è¼•å‚·</div>
                                                <div className="font-mono text-lg">{getPct(resultStats.triage.green.correct, resultStats.triage.green.total)} <span className="text-xs text-gray-500">({resultStats.triage.green.correct}/{resultStats.triage.green.total})</span></div>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-yellow-500"></span> é»ƒè‰²ä¸­å‚·</div>
                                                <div className="font-mono text-lg">{getPct(resultStats.triage.yellow.correct, resultStats.triage.yellow.total)} <span className="text-xs text-gray-500">({resultStats.triage.yellow.correct}/{resultStats.triage.yellow.total})</span></div>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-red-600"></span> ç´…è‰²é‡å‚·</div>
                                                <div className="font-mono text-lg">{getPct(resultStats.triage.red.correct, resultStats.triage.red.total)} <span className="text-xs text-gray-500">({resultStats.triage.red.correct}/{resultStats.triage.red.total})</span></div>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-gray-500"></span> é»‘è‰²æ­»äº¡</div>
                                                <div className="font-mono text-lg">{getPct(resultStats.triage.black.correct, resultStats.triage.black.total)} <span className="text-xs text-gray-500">({resultStats.triage.black.correct}/{resultStats.triage.black.total})</span></div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* å³å´æ¬„ï¼šå…¶ä»–çµ±è¨ˆ */}
                                    <div className="space-y-6">
                                        {/* 3. è™•ç½®æ­£ç¢ºç‡ */}
                                        <div className="bg-gray-800/50 p-4 rounded-lg border border-gray-700">
                                            <h3 className="text-lg font-bold text-yellow-400 mb-2">æ€¥æ•‘è™•ç½®æ­£ç¢ºç‡</h3>
                                            <div className="text-sm text-gray-400 mb-1">(æ­¢è¡€å¸¶ / æš¢é€šå‘¼å¸é“)</div>
                                            <div className="flex justify-between items-end">
                                                <div className="text-3xl font-bold text-white">{getPct(resultStats.treatment.correct, resultStats.treatment.total)}</div>
                                                <div className="text-gray-500">æ“ä½œ: {resultStats.treatment.correct}/{resultStats.treatment.total}</div>
                                            </div>
                                        </div>

                                        {/* 4. é™¤æ±™æ­£ç¢ºç‡ */}
                                        <div className="bg-gray-800/50 p-4 rounded-lg border border-gray-700">
                                            <h3 className="text-lg font-bold text-purple-400 mb-2">å‚·æ‚£é™¤æ±™å®Œæˆç‡</h3>
                                            <div className="flex justify-between items-end">
                                                <div className="text-3xl font-bold text-white">{getPct(resultStats.decon.correct, resultStats.decon.total)}</div>
                                                <div className="text-gray-500">å·²é™¤æ±™: {resultStats.decon.correct}/{resultStats.decon.total}</div>
                                            </div>
                                        </div>

                                        {/* 5. ç´…è‰²å„ªå…ˆå¾Œé€ç‡ */}
                                        <div className="bg-gray-800/50 p-4 rounded-lg border border-gray-700">
                                            <h3 className="text-lg font-bold text-red-400 mb-2">ç´…è‰²å‚·æ‚£å„ªå…ˆå¾Œé€ç‡</h3>
                                            <div className="text-sm text-gray-400 mb-1">(æˆåŠŸå­˜æ´»ä¸¦é€é†«çš„é‡å‚·æ‚£)</div>
                                            <div className="flex justify-between items-end">
                                                <div className="text-3xl font-bold text-white">{getPct(resultStats.redEvac.correct, resultStats.redEvac.total)}</div>
                                                <div className="text-gray-500">æˆåŠŸå¾Œé€: {resultStats.redEvac.correct}/{resultStats.redEvac.total}</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* å®ŒæˆæŒ‰éˆ•  */}

                                <button
                                    onClick={handleRestart}
                                    className="px-12 py-4 bg-yellow-500 hover:bg-yellow-400 text-black text-2xl font-black rounded shadow-[0_0_30px_rgba(234,179,8,0.4)] transform hover:scale-105 transition-all duration-200"
                                >
                                    é‡æ–°é–‹å§‹
                                </button>
                            </div>
                        )}
                        {/* â˜…â˜…â˜… 4. æ–°å¢ï¼šç„¡ç·šé›» UI é¢æ¿ (ä»¿å¹³æ¿é¢¨æ ¼) â˜…â˜…â˜… */}
                        {showRadioPanel && (
                            <div className="absolute top-[210px] left-3 w-72 bg-slate-900/95 border-2 border-blue-500 rounded-lg shadow-[0_0_30px_rgba(59,130,246,0.3)] p-4 text-white z-50 animate-fade-in font-sans custom-scrollbar">
                                <div className="flex justify-between items-center mb-4 border-b border-blue-500/50 pb-2">
                                    <h2 className="text-lg font-bold text-blue-400 flex items-center gap-2">
                                        ğŸ“» ç„¡ç·šé›»æŒ‡æ®
                                    </h2>
                                    <span className="text-xs text-gray-400">MP: {Math.floor(playerStatsUI.mp)}</span>
                                </div>
                                <div className="space-y-3">
                                    {/* 1. è«‹æ±‚æ•‘è­·è»Š */}
                                    <button
                                        onClick={() => {
                                            const state = gameState.current;
                                            if (state.ambulanceCooldown > 0) {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: `å†·å»ä¸­ (${Math.ceil(state.ambulanceCooldown / 60)}s)`, color: "#bdc3c7", life: 60, vy: -0.5 });
                                                return;
                                            }
                                            const stagingArea = state.triageMats.find(m => m.color === 'ambulance_staging');
                                            if (!stagingArea) {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "ç„¡è¨­ç½®æ•‘è­·è»Šå¾…å‘½å€", color: "#e74c3c", life: 60, vy: -0.5 });
                                                return;
                                            }
                                            if (state.stats.mp >= 10) {
                                                state.stats.mp -= 10;
                                                state.ambulanceCooldown = 3600;
                                                const ambCount = Math.floor(Math.random() * 3) + 1;
                                                for (let k = 0; k < ambCount; k++) {
                                                    const ax = stagingArea.x + 10 + Math.random() * (stagingArea.w - 90);
                                                    const ay = stagingArea.y + 10 + Math.random() * (stagingArea.h - 60);
                                                    state.emergencyVehicles.push({
                                                        id: Math.random(), type: 'ambulance', passengers: [], state: 'arriving',
                                                        x: state.camera.x - 150 - (k * 100), y: ay, targetX: ax, targetY: ay, w: 80, h: 40, angle: 0
                                                    });
                                                }
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "æ•‘è­·è»Šè¶•å¾€ä¸­...", color: "#3498db", life: 60, vy: -0.5 });
                                                forceUpdate(n => n + 1);
                                            } else {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "MPä¸è¶³!", color: "#e74c3c", life: 60, vy: -0.5 });
                                            }
                                        }}
                                        className="w-full bg-slate-800 hover:bg-slate-700 border border-slate-600 p-3 rounded flex justify-between items-center transition group"
                                    >
                                        <span className="font-bold text-blue-300 group-hover:text-blue-200">è«‹æ±‚æ•‘è­·è»Š</span>
                                        <span className="text-xs bg-blue-900 text-blue-200 px-2 py-1 rounded">-10 MP</span>
                                    </button>

                                    {/* 2. è«‹æ±‚æ¶ˆé˜²è»Š */}
                                    <button
                                        onClick={() => {
                                            const state = gameState.current;
                                            const target = state.hazards.find(h => !h.beingExtinguished);
                                            if (target) {
                                                if (state.stats.mp >= 10) {
                                                    state.stats.mp -= 10;
                                                    target.beingExtinguished = true;
                                                    state.firefightingSquads.push({
                                                        x: 50 + 700, y: 540 / 2 - 150, target: target, state: 'moving_to_fire'
                                                    });
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "æ´¾é£æ¶ˆé˜²è»Šæ”¯æ´", color: "#e74c3c", life: 60, vy: -0.5 });
                                                    forceUpdate(n => n + 1);
                                                } else {
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "MPä¸è¶³!", color: "#e74c3c", life: 60, vy: -0.5 });
                                                }
                                            } else {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "ç›®å‰ç„¡ç«ç½éœ€è™•ç†", color: "#2ecc71", life: 60, vy: -0.5 });
                                            }
                                        }}
                                        className="w-full bg-slate-800 hover:bg-slate-700 border border-slate-600 p-3 rounded flex justify-between items-center transition group"
                                    >
                                        <span className="font-bold text-red-400 group-hover:text-red-300">è«‹æ±‚æ¶ˆé˜²è»Š</span>
                                        <span className="text-xs bg-red-900 text-red-200 px-2 py-1 rounded">-10 MP</span>
                                    </button>

                                    {/* 3. è«‹æ±‚ç ´å£å°çµ„ */}
                                    <button
                                        onClick={() => {
                                            const state = gameState.current;
                                            const target = state.obstacles.find(o =>
                                                ['sedan', 'truck'].includes(o.type) && !o.isBreached && o.breakTimer === 0 &&
                                                state.survivors.some(s => s.trappedInVehicle === o) &&
                                                !state.rescueSquads.some(sq => sq.target === o)
                                            );
                                            if (target) {
                                                if (state.stats.mp >= 10) {
                                                    state.stats.mp -= 10;
                                                    state.rescueSquads.push({
                                                        x: 50 + 700, y: 540 / 2 - 100, target: target, state: 'moving_to_vehicle'
                                                    });
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "æ´¾é£ç ´å£å°çµ„", color: "#e67e22", life: 60, vy: -0.5 });
                                                    forceUpdate(n => n + 1);
                                                } else {
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "MPä¸è¶³!", color: "#e74c3c", life: 60, vy: -0.5 });
                                                }
                                            } else {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "ç„¡å—å›°è»Šè¼›éœ€è™•ç†", color: "#bdc3c7", life: 60, vy: -0.5 });
                                            }
                                        }}
                                        className="w-full bg-slate-800 hover:bg-slate-700 border border-slate-600 p-3 rounded flex justify-between items-center transition group"
                                    >
                                        <span className="font-bold text-orange-400 group-hover:text-orange-300">è«‹æ±‚ç ´å£å°çµ„</span>
                                        <span className="text-xs bg-orange-900 text-orange-200 px-2 py-1 rounded">-10 MP</span>
                                    </button>

                                    {/* 4. è«‹æ±‚æ¬é‹äººå“¡ */}
                                    <button
                                        onClick={() => {
                                            const state = gameState.current;
                                            if (state.npcGroups.length >= 2) {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "æ¬é‹äººåŠ›å·²é”ä¸Šé™", color: "#e74c3c", life: 60, vy: -0.5 });
                                                return;
                                            }
                                            const unassignedTargets = state.survivors.filter(s =>
                                                s.triageTag && ['red', 'yellow', 'black'].includes(s.triageTag) &&
                                                !s.isEvacuating && !s.hasArrived && !s.isBeingCarried &&
                                                !state.npcGroups.some(g => g.target === s) &&
                                                (!s.trappedInVehicle || s.trappedInVehicle.isBreached) &&
                                                !state.hazards.some(h => Math.hypot(s.x - h.x, s.y - h.y) < h.r + 30)
                                            );
                                            if (unassignedTargets.length > 0) {
                                                if (state.stats.mp >= 10) {
                                                    state.stats.mp -= 10;
                                                    unassignedTargets.sort((a, b) => {
                                                        const p = { 'black': 3, 'red': 2, 'yellow': 1 };
                                                        return p[b.triageTag] - p[a.triageTag];
                                                    });
                                                    state.npcGroups.push({
                                                        leaderX: 20 + 700, leaderY: 600, followerX: 0 + 700, followerY: 600,
                                                        target: unassignedTargets[0], state: 'moving_to_target', carrying: false
                                                    });
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "å¢æ´¾æ¬é‹äººå“¡", color: "#9b59b6", life: 60, vy: -0.5 });
                                                    forceUpdate(n => n + 1);
                                                } else {
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "MPä¸è¶³!", color: "#e74c3c", life: 60, vy: -0.5 });
                                                }
                                            } else {
                                                state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "ç›®å‰ç„¡å‚·æ‚£éœ€æ¬é‹", color: "#bdc3c7", life: 60, vy: -0.5 });
                                            }
                                        }}
                                        className="w-full bg-slate-800 hover:bg-slate-700 border border-slate-600 p-3 rounded flex justify-between items-center transition group"
                                    >
                                        <span className="font-bold text-purple-400 group-hover:text-purple-300">è«‹æ±‚æ¬é‹äººå“¡</span>
                                        <span className="text-xs bg-purple-900 text-purple-200 px-2 py-1 rounded">-10 MP</span>
                                    </button>
                                </div>
                            </div>
                        )}


                        {/* â˜…â˜…â˜… æª¢å‚·å¹³æ¿æµ®å‹•è¦–çª— (é å³é¡¯ç¤º) â˜…â˜…â˜… */}
                        {showTabletUI && (
                            <>
                                {/* å·¦å´ï¼šæ•‘è­·è»Šèª¿åº¦åˆ—è¡¨ */}
                                <div className="absolute top-16 right-80 w-72 bg-slate-900/95 border-2 border-blue-500 rounded-lg shadow-[0_0_30px_rgba(59,130,246,0.3)] p-4 text-white z-50 max-h-[80vh] overflow-y-auto font-sans animate-fade-in custom-scrollbar">
                                    <div className="flex justify-between items-center mb-4 border-b border-blue-500/50 pb-2">
                                        <h2 className="text-lg font-bold text-blue-400 flex items-center gap-2">
                                            ğŸš‘ æ•‘è­·è»Šèª¿åº¦
                                        </h2>
                                        {/* --- æ–°å¢ï¼šä¿®æ”¹ï¼šå‘¼å«å°å·´æŒ‰éˆ• (MP-30)--- */}
                                        <button
                                            onClick={() => {
                                                const state = gameState.current;
                                                // 1. æª¢æŸ¥å†·å»
                                                if (state.ambulanceCooldown > 0) {
                                                    alert(`èª¿åº¦å†·å»ä¸­ (${Math.ceil(state.ambulanceCooldown / 60)}s)`);
                                                    return;
                                                }
                                                // 2. æª¢æŸ¥å¾…å‘½å€
                                                const stagingArea = state.triageMats.find(m => m.color === 'ambulance_staging');
                                                if (!stagingArea) {
                                                    alert("è«‹å…ˆè¨­ç½®æ•‘è­·è»Šå¾…å‘½å€ï¼");
                                                    return;
                                                }
                                                // 3. æª¢æŸ¥ MP ä¸¦æ‰£é™¤
                                                if (state.stats.mp >= 30) {
                                                    state.stats.mp -= 30;
                                                    state.ambulanceCooldown = 3600; // è¨­å®š 60ç§’å†·å»

                                                    // â˜…â˜…â˜… ä¿®æ”¹ï¼šç”Ÿæˆ 1 å°å°å·´ â˜…â˜…â˜…
                                                    let destX, destY;
                                                    let isSafe = false;
                                                    let attempts = 0;
                                                    while (!isSafe && attempts < 10) {
                                                        destX = stagingArea.x + 10 + Math.random() * (stagingArea.w - 90);
                                                        destY = stagingArea.y + 10 + Math.random() * (stagingArea.h - 60);

                                                        const dist = Math.hypot(state.player.x - (destX + 40), state.player.y - (destY + 20));
                                                        if (dist > 80) isSafe = true;
                                                        attempts++;
                                                    }

                                                    state.emergencyVehicles.push({
                                                        id: Math.random(),
                                                        type: 'mini_bus', // é¡å‹è¨­ç‚ºå°å·´
                                                        passengers: [],
                                                        state: 'arriving',
                                                        x: state.camera.x - 150,
                                                        y: destY,
                                                        targetX: destX,
                                                        targetY: destY,
                                                        w: 100, h: 50, angle: 0
                                                    });

                                                    forceUpdate(prev => prev + 1); // å¼·åˆ¶é‡ç¹ª
                                                    state.feedbacks.push({ x: state.player.x, y: state.player.y - 50, text: "-30 MP (å°å·´æ”¯æ´)", color: "#f1c40f", life: 60, vy: -0.5 });
                                                } else {
                                                    alert("MPä¸è¶³ (éœ€ 30)ï¼");
                                                }
                                            }}
                                            className="px-2 py-1 bg-yellow-600 hover:bg-yellow-500 text-white text-xs rounded shadow transition border border-yellow-400"
                                        >
                                            å‘¼å«å°å·´æ”¯æ´ (-30MP)
                                        </button>
                                    </div>
                                    <div className="space-y-3">
                                        {(() => {
                                            const staging = gameState.current.triageMats.find(m => m.color === 'ambulance_staging');
                                            let vehicles = [];
                                            if (staging) {
                                                // â˜…â˜…â˜… ä¿®æ”¹ï¼šç¯©é¸ ambulance å’Œ mini_bus â˜…â˜…â˜…
                                                vehicles = gameState.current.emergencyVehicles.filter(v =>
                                                    ['ambulance', 'mini_bus'].includes(v.type) && v.state !== 'departing' &&
                                                    v.x >= staging.x && v.x <= staging.x + staging.w &&
                                                    v.y >= staging.y && v.y <= staging.y + staging.h
                                                );
                                            } else {
                                                vehicles = gameState.current.emergencyVehicles.filter(v => ['ambulance', 'mini_bus'].includes(v.type) && v.state !== 'departing');
                                            }

                                            if (vehicles.length === 0) {
                                                return <div className="text-gray-500 text-center py-4">å¾…å‘½å€ç„¡è»Šè¼›</div>;
                                            }

                                            return vehicles.map((veh, idx) => {
                                                // â˜…â˜…â˜… ä¿®æ”¹ï¼šè¼‰é€è¦å‰‡æª¢æŸ¥ (å€åˆ†å°å·´èˆ‡æ•‘è­·è»Š) â˜…â˜…â˜…
                                                const canLoad = (patientTag) => {
                                                    const p = veh.passengers;

                                                    // (1) å°å·´è¦å‰‡: åªè¼‰ç¶ è‰²ï¼Œä¸Šé™ 8 äºº
                                                    if (veh.type === 'mini_bus') {
                                                        if (patientTag !== 'green') return false;
                                                        if (p.length >= 8) return false;
                                                        return true;
                                                    }

                                                    // (2) æ•‘è­·è»Šè¦å‰‡: 1ç´… OR 1é»ƒ1ç¶  OR 2ç¶ 
                                                    if (p.length === 0) return true;
                                                    const hasRed = p.includes('red');
                                                    const hasYellow = p.includes('yellow');
                                                    const greens = p.filter(c => c === 'green').length;

                                                    if (hasRed) return false;
                                                    if (patientTag === 'red') return false;
                                                    if (patientTag === 'yellow') return greens === 1 && !hasYellow;
                                                    if (patientTag === 'green') {
                                                        if (hasYellow) return true;
                                                        if (greens === 1) return true;
                                                        return false;
                                                    }
                                                    return false;
                                                };

                                                const handleVehicleClick = () => {
                                                    if (!selectedPatient) return;

                                                    if (canLoad(selectedPatient.triageTag)) {
                                                        if (selectedPatient.triageTag === 'red') {
                                                            setScore(prev => prev + 500);
                                                            // æ‰‹å‹•æ¨å…¥ feedback (å› ç‚ºæ­¤è™•åœ¨ useEffect å¤–)
                                                            gameState.current.feedbacks.push({
                                                                x: gameState.current.player.x,
                                                                y: gameState.current.player.y - 50,
                                                                text: "å„ªå…ˆå¾Œé€ç´…è‰² +500",
                                                                color: "#f1c40f",
                                                                life: 60,
                                                                vy: -0.5
                                                            });
                                                        }

                                                        veh.passengers.push(selectedPatient.triageTag);
                                                        selectedPatient.onAmbulance = true;
                                                        setSelectedPatient(null);

                                                        const p = veh.passengers;

                                                        // â˜…â˜…â˜… ä¿®æ”¹ï¼šè‡ªå‹•å‡ºç™¼é‚è¼¯ â˜…â˜…â˜…
                                                        let shouldDepart = false;
                                                        if (veh.type === 'mini_bus') {
                                                            if (p.length >= 8) shouldDepart = true;
                                                        } else {
                                                            const hasRed = p.includes('red');
                                                            const hasYellow = p.includes('yellow');
                                                            const greens = p.filter(c => c === 'green').length;
                                                            if (hasRed || (hasYellow && greens >= 1) || greens >= 2) {
                                                                shouldDepart = true;
                                                            }
                                                        }

                                                        if (shouldDepart) {
                                                            veh.state = 'departing';
                                                        }
                                                        forceUpdate(prev => prev + 1);
                                                    } else {
                                                        if (veh.type === 'mini_bus') {
                                                            alert("å°å·´åªèƒ½è¼‰é€ç¶ è‰²è¼•å‚·æ‚£è€… (ä¸Šé™8äºº)ï¼");
                                                        } else {
                                                            alert("ä¸ç¬¦åˆè¼‰é€è¦å‰‡æˆ–è»Šä½å·²æ»¿ï¼\nè¦å‰‡: 1ç´… æˆ– 1é»ƒ1ç¶  æˆ– 2ç¶ ");
                                                        }
                                                    }
                                                };

                                                const handleManualDepart = (e) => {
                                                    e.stopPropagation();
                                                    if (veh.passengers.length > 0) {
                                                        veh.state = 'departing';
                                                        forceUpdate(prev => prev + 1);
                                                    }
                                                };

                                                // é¡¯ç¤ºåç¨±èˆ‡é¡è‰²
                                                const vehName = veh.type === 'mini_bus' ? `å°å·´ #${idx + 1}` : `æ•‘è­·è»Š #${idx + 1}`;
                                                const vehColor = veh.type === 'mini_bus' ? 'text-yellow-400' : 'text-gray-300';

                                                return (
                                                    <div
                                                        key={veh.id || idx}
                                                        onClick={handleVehicleClick}
                                                        className={`bg-slate-800/50 p-3 rounded border border-slate-700 hover:bg-slate-700 cursor-pointer transition
                                                    ${selectedPatient ? (canLoad(selectedPatient.triageTag) ? 'ring-2 ring-green-500' : 'opacity-50 cursor-not-allowed') : ''}
                                                `}
                                                    >
                                                        <div className="flex justify-between mb-2">
                                                            <span className={`font-bold ${vehColor}`}>{vehName}</span>
                                                            <span className="text-xs text-blue-400">é»æ“Šè¼‰å…¥</span>
                                                            <button
                                                                onClick={handleManualDepart}
                                                                disabled={veh.passengers.length === 0}
                                                                className={`px-3 py-1 text-xs rounded font-bold transition-colors z-10
                                                            ${veh.passengers.length > 0
                                                                        ? 'bg-blue-600 hover:bg-blue-500 text-white shadow-md'
                                                                        : 'bg-gray-700 text-gray-500 cursor-not-allowed'}
                                                        `}
                                                            >
                                                                å‡ºç™¼
                                                            </button>
                                                        </div>
                                                        {/* â˜…â˜…â˜… ä¿®æ”¹ï¼šä¹˜å®¢é¡¯ç¤ºæ ¼ (æ”¯æ´å°å·´å¤šæ ¼) â˜…â˜…â˜… */}
                                                        <div className="flex gap-1 h-4 bg-slate-900 rounded overflow-hidden flex-wrap">
                                                            {veh.passengers.length === 0 && <div className="w-full text-[10px] text-center text-gray-600 leading-4">ç©ºè»Š</div>}
                                                            {veh.passengers.map((tag, pi) => (
                                                                <div key={pi} className={`h-full ${veh.type === 'mini_bus' ? 'w-[11%]' : 'flex-1'} ${tag === 'red' ? 'bg-red-500' :
                                                                    tag === 'yellow' ? 'bg-yellow-500' : 'bg-green-500'
                                                                    } border-r border-slate-800`}></div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                );
                                            });
                                        })()}
                                    </div>
                                </div>
                                {/* â˜…â˜…â˜… è£œå›ï¼šå³å´ æª¢å‚·è³‡è¨Šåˆ—è¡¨ (é€™æ®µæ¶ˆå¤±äº†ï¼Œè«‹è£œä¸Š) â˜…â˜…â˜… */}
                                <div className="absolute top-16 right-4 w-72 bg-slate-900/95 border-2 border-green-500 rounded-lg shadow-[0_0_30px_rgba(34,197,94,0.3)] p-4 text-white z-50 max-h-[80vh] overflow-y-auto font-sans animate-fade-in custom-scrollbar">
                                    <div className="flex justify-between items-center mb-4 border-b border-green-500/50 pb-2">
                                        <h2 className="text-lg font-bold text-green-400 flex items-center gap-2">
                                            ğŸ“‹ å‚·æ‚£åå–®
                                        </h2>
                                        <span className="text-xs text-gray-400">é»æ“Šé¸æ“‡å‚·æ‚£</span>
                                    </div>
                                    <div className="space-y-2">
                                        {gameState.current.survivors.filter(s => s.triageTag).length === 0 ? (
                                            <div className="text-center text-gray-500 py-4">å°šç„¡æª¢å‚·ç´€éŒ„</div>
                                        ) : (
                                            gameState.current.survivors.map((s, idx) => {
                                                if (!s.triageTag) return null; // åªé¡¯ç¤ºå·²æª¢å‚·çš„
                                                // å¦‚æœå·²ä¸Šè»Šæˆ–å·²æ­»äº¡(è½‰é»‘å¡)é€šå¸¸é‚„æ˜¯é¡¯ç¤ºï¼Œæ–¹ä¾¿æŸ¥çœ‹ï¼Œä½†å¯æ ¹æ“šéœ€æ±‚éæ¿¾
                                                return (
                                                    <div
                                                        key={idx}
                                                        onClick={() => !s.onAmbulance && setSelectedPatient(s)}
                                                        className={`p-2 rounded border cursor-pointer transition flex justify-between items-center
                                                    ${selectedPatient === s ? 'bg-green-900/50 border-green-400 ring-1 ring-green-400' : 'bg-slate-800/50 border-slate-700 hover:bg-slate-700'}
                                                    ${s.onAmbulance ? 'opacity-50 cursor-not-allowed' : ''}
                                                `}
                                                    >
                                                        <div className="flex items-center gap-3">
                                                            <span className={`w-3 h-3 rounded-full ${s.triageTag === 'red' ? 'bg-red-500' :
                                                                s.triageTag === 'yellow' ? 'bg-yellow-500' :
                                                                    s.triageTag === 'green' ? 'bg-green-500' : 'bg-gray-600'
                                                                }`}></span>
                                                            <div>
                                                                <div className="text-sm font-bold text-gray-200">
                                                                    å‚·æ‚£ #{idx + 1} <span className="text-xs text-gray-400">({s.data.sex}, {s.data.age})</span>
                                                                </div>
                                                                <div className="text-xs text-gray-500">{s.data.injuryText}</div>
                                                            </div>
                                                        </div>
                                                        {s.onAmbulance ? (
                                                            <span className="text-[10px] bg-blue-900 text-blue-300 px-1 py-0.5 rounded">å·²ä¸Šè»Š</span>
                                                        ) : s.hasArrived ? (
                                                            <span className="text-[10px] bg-gray-700 text-gray-300 px-1 py-0.5 rounded">å·²å®‰ç½®</span>
                                                        ) : (
                                                            <span className="text-[10px] bg-gray-800 text-gray-500 px-1 py-0.5 rounded">å¾…è™•ç†</span>
                                                        )}
                                                    </div>
                                                );
                                            })
                                        )}
                                    </div>
                                </div>
                                {/* --- æ–°å¢ï¼šæª¢å‚·çµ±è¨ˆé¢æ¿ (ç•«é¢æ­£ä¸Šæ–¹ç½®ä¸­) --- */}
                                <div className="absolute top-0 left-1/2 -translate-x-1/2 pointer-events-none select-none z-50">
                                    <div className="flex gap-4 bg-black/80 p-2 px-4 border-b-2 border-gray-600 rounded-b-lg shadow-xl">
                                        {/* ç¶ è‰² */}
                                        <div className="flex items-center gap-1">
                                            <span className="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_5px_rgba(34,197,94,0.8)]"></span>
                                            <span className="text-xs text-gray-300">ç¶ è‰²:</span>
                                            <span className="text-sm font-bold text-green-400">{triageCounts.green}</span>
                                        </div>
                                        {/* é»ƒè‰² */}
                                        <div className="flex items-center gap-1">
                                            <span className="w-2 h-2 rounded-full bg-yellow-500 shadow-[0_0_5px_rgba(234,179,8,0.8)]"></span>
                                            <span className="text-xs text-gray-300">é»ƒè‰²:</span>
                                            <span className="text-sm font-bold text-yellow-400">{triageCounts.yellow}</span>
                                        </div>
                                        {/* ç´…è‰² */}
                                        <div className="flex items-center gap-1">
                                            <span className="w-2 h-2 rounded-full bg-red-600 shadow-[0_0_5px_rgba(220,38,38,0.8)]"></span>
                                            <span className="text-xs text-gray-300">ç´…è‰²:</span>
                                            <span className="text-sm font-bold text-red-500">{triageCounts.red}</span>
                                        </div>
                                        {/* é»‘è‰² */}
                                        <div className="flex items-center gap-1">
                                            <span className="w-2 h-2 rounded-full bg-gray-600 shadow-[0_0_5px_rgba(107,114,128,0.8)]"></span>
                                            <span className="text-xs text-gray-300">é»‘è‰²:</span>
                                            <span className="text-sm font-bold text-gray-400">{triageCounts.black}</span>
                                        </div>
                                    </div>
                                </div>
                            </>
                        )}
                        {/* åœ°å¢Šé¸æ“‡é¸å–® */}
                        {showMatSelector && (
                            <div className="absolute bottom-16 left-1/2 -translate-x-1/2 bg-black/90 p-4 rounded-lg border border-gray-500 shadow-xl flex gap-4 z-50">
                                {[
                                    { id: 'green', label: 'è¼•å‚·å€', bg: 'bg-green-500', hover: 'hover:bg-green-400', text: 'text-black' },
                                    { id: 'yellow', label: 'ä¸­å‚·å€', bg: 'bg-yellow-500', hover: 'hover:bg-yellow-400', text: 'text-black' },
                                    { id: 'red', label: 'é‡å‚·å€', bg: 'bg-red-600', hover: 'hover:bg-red-500', text: 'text-white' },
                                    { id: 'black', label: 'é»‘å¡å€', bg: 'bg-gray-800', hover: 'hover:bg-gray-700', text: 'text-white' }
                                ].map(btn => {
                                    // æª¢æŸ¥è©²é¡è‰²æ˜¯å¦å·²å­˜åœ¨æ–¼å ´æ™¯ä¸­
                                    const isUsed = gameState.current.triageMats.some(m => m.color === btn.id);

                                    return (
                                        <button
                                            key={btn.id}
                                            onClick={() => !isUsed && handleSelectMatColor(btn.id)}
                                            disabled={isUsed}
                                            className={`
                                                w-16 h-10 font-bold text-xs rounded shadow relative transition-all
                                                ${isUsed
                                                    ? 'bg-gray-700 text-gray-500 cursor-not-allowed border border-gray-600'
                                                    : `${btn.bg} ${btn.hover} ${btn.text}`
                                                }
                                            `}
                                        >
                                            {btn.label}
                                            {isUsed && (
                                                <span className="absolute inset-0 flex items-center justify-center text-red-500/80 text-lg font-bold">âœ•</span>
                                            )}
                                        </button>
                                    );
                                })}
                            </div>
                        )}
                        {/* --- ä¿®æ”¹çµæŸ --- */}

                        <div className="absolute top-3 left-3 pointer-events-none select-none">
                            <div className="bg-black/60 p-1.5 mb-1 backdrop-blur-sm border-l-2 border-[#e74c3c] inline-block">
                                <h1 className="text-sm m-0 text-[#e74c3c] font-bold flex items-center gap-2 tracking-wide">
                                    <IconAlert /> MCI æ¨¡æ“¬æ¼”ç·´
                                    <span className="text-yellow-400 ml-4 font-mono text-base">Score: {score}</span>
                                </h1>
                            </div>
                            <div className="bg-black/80 p-2 border-l-2 border-orange-500 text-gray-200 text-xs w-[220px] shadow-lg">
                                <div className="grid grid-cols-[auto_1fr] gap-x-2 gap-y-1">
                                    {/* ç¬¬ä¸€åˆ—ï¼šOBJ æ¨™ç±¤ èˆ‡ æª¢å‚·äººæ•¸ */}
                                    <div className="flex items-center gap-2 text-gray-400">
                                        <IconActivity /> <span>OBJ:</span>
                                    </div>
                                    <div>æª¢å‚·äººæ•¸ ({survivorCount}/{totalSurvivors})</div>

                                    {/* ç¬¬äºŒåˆ—ï¼šç·¨è™Ÿ 1. èˆ‡ å®‰ç½®äººæ•¸ */}
                                    <div className="text-right text-gray-400">1.</div>
                                    <div>å®‰ç½®äººæ•¸ ({Object.values(triageCounts).reduce((a, b) => a + b, 0)}/{totalSurvivors})</div>

                                    {/* ç¬¬ä¸‰åˆ—ï¼šç·¨è™Ÿ 2. èˆ‡ å¾Œé€äººæ•¸ */}
                                    <div className="text-right text-gray-400">2.</div>
                                    <div>å¾Œé€äººæ•¸ ({gameState.current.survivors.filter(s => s.onAmbulance).length}/{totalSurvivors})</div>

                                </div>
                            </div>
                            <div className="mt-2 w-[150px] flex flex-col gap-1">
                                <div className="flex items-center gap-1 bg-black/60 p-1 rounded-sm">
                                    <span className="text-[10px] font-bold text-red-400 w-4">HP</span>
                                    <div className="h-2 flex-1 bg-gray-700 relative overflow-hidden rounded-sm">
                                        <div className="absolute top-0 left-0 h-full bg-red-600" style={{ width: `${(playerStatsUI.hp / playerStatsUI.maxHp) * 100}%` }}></div>
                                    </div>
                                </div>
                                <div className="flex items-center gap-1 bg-black/60 p-1 rounded-sm">
                                    <span className="text-[10px] font-bold text-blue-400 w-4">MP</span>
                                    <div className="h-2 flex-1 bg-gray-700 relative overflow-hidden rounded-sm">
                                        <div className="absolute top-0 left-0 h-full bg-blue-600" style={{ width: `${(playerStatsUI.mp / playerStatsUI.maxMp) * 100}%` }}></div>
                                    </div>
                                </div>
                                <div className="flex items-center gap-1 bg-black/60 p-1 rounded-sm">
                                    <span className={`text-[10px] font-bold w-4 ${gameState.current.spBuffTimer > 0 ? 'text-cyan-400 animate-pulse' : 'text-yellow-400'}`}>SP</span>
                                    <div className="h-2 flex-1 bg-gray-700 relative overflow-hidden rounded-sm">
                                        <div className="absolute top-0 left-0 h-full bg-yellow-600" style={{ width: `${(playerStatsUI.sp / playerStatsUI.maxSp) * 100}%` }}></div>
                                        <div style={{ width: `${(playerStatsUI.sp / playerStatsUI.maxSp) * 100}%` }}></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        {/* â˜…â˜…â˜… æ–°å¢ï¼šå³ä¸Šè§’éŠæˆ²éŸ³æ¨‚æ··éŸ³å™¨/é–‹é—œ â˜…â˜…â˜… */}
                        <div className="absolute top-3 right-3 z-50 pointer-events-auto flex items-center gap-4">
                            {/* â˜…â˜…â˜… æ“ä½œèªªæ˜æ–‡å­— (é€æ˜èƒŒæ™¯) â˜…â˜…â˜… */}
                            <div className="text-white/90 text-xs font-bold tracking-wide select-none drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)] hidden xl:block">
                                æ“ä½œèªªæ˜:éµç›¤â†â†“ â†‘â†’ &nbsp;&nbsp; äº’å‹•:Eéµæˆ–æ»‘é¼ å·¦éµ &nbsp;&nbsp; é“å…·æ¬„:Iéµ &nbsp;&nbsp; å–æ¶ˆ:Céµæˆ–æ»‘é¼ å³éµ
                            </div>
                            <button
                                onClick={toggleAudio}
                                className={`
                                    flex items-center gap-2 px-3 py-2 rounded-full border-2 transition-all shadow-lg backdrop-blur-md
                                    ${isMuted
                                        ? 'bg-gray-800/80 border-gray-600 text-gray-400 hover:bg-gray-700'
                                        : 'bg-green-900/80 border-green-500 text-green-400 hover:bg-green-800 playing-wave'
                                    }
                                `}
                            >
                                <IconVolume muted={isMuted} />
                                <span className="text-xs font-bold tracking-wider hidden sm:inline">
                                    {isMuted ? 'MUTE' : 'BGM ON'}
                                </span>
                                {/* éŸ³è¨Šè¦–è¦ºåŒ–æ¢ (åƒ…åœ¨æ’­æ”¾æ™‚é¡¯ç¤º) */}
                                {!isMuted && (
                                    <div className="flex gap-[2px] items-end h-4 ml-1">
                                        <div className="bar w-1 bg-green-400"></div>
                                        <div className="bar w-1 bg-green-400"></div>
                                        <div className="bar w-1 bg-green-400"></div>
                                        <div className="bar w-1 bg-green-400"></div>
                                    </div>
                                )}
                            </button>
                        </div>
                        {/* --- é“å…·æ¬„ (ä¿®æ”¹å¾Œï¼šå·¦ä¸‹è§’æ‘ºç–Šå¼) --- */}
                        <div className="absolute bottom-4 left-4 pointer-events-auto select-none z-50">
                            {!showInventory ? (
                                // æ‘ºç–Šç‹€æ…‹ï¼šé¡¯ç¤ºèƒŒåŒ…åœ–ç¤º
                                <div
                                    onClick={() => setShowInventory(true)}
                                    className="w-12 h-12 border border-gray-500 bg-black/80 hover:bg-gray-700/80 rounded-md cursor-pointer flex items-center justify-center shadow-lg group transition-transform hover:scale-105"
                                    title="æ‰“é–‹é“å…·æ¬„ (I)"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-300 group-hover:text-white">
                                        <path d="M3 7v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7" /><path d="M3 7l9-4 9 4" /><path d="M12 3v4" />
                                    </svg>
                                    {/* æç¤ºæ–‡å­— */}
                                    <div className="absolute left-14 top-1/2 -translate-y-1/2 bg-black text-white text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 whitespace-nowrap pointer-events-none transition-opacity">
                                        èƒŒåŒ… (I)
                                    </div>
                                </div>
                            ) : (
                                // å±•é–‹ç‹€æ…‹ï¼šé¡¯ç¤ºé“å…·åˆ—è¡¨ (ç”±å·¦å‘å³å»¶ä¼¸)
                                <div className="flex items-end gap-1">
                                    {/* é—œé–‰æŒ‰éˆ• (X) */}
                                    <div
                                        onClick={() => setShowInventory(false)}
                                        className="w-8 h-8 mb-1 mr-1 border border-red-500/50 bg-red-900/30 hover:bg-red-900/50 rounded cursor-pointer flex items-center justify-center text-red-400 font-bold"
                                        title="æ”¶èµ·"
                                    >
                                        âœ•
                                    </div>
                                    {/* --- é“å…·æ¬„ç§»è‡³æ­¤è™• (å¤–å±¤é»‘è‰²å€åŸŸ) --- */}

                                    <div className="flex gap-1 bg-black/80 p-2 border border-gray-600 rounded-md shadow-[0_0_15px_rgba(0,0,0,0.8)]">
                                        {items.map((item, i) => (
                                            <div
                                                key={i}
                                                onClick={() => handleSlotClick(i)}
                                                className={`w-10 h-10 border bg-gray-900/50 hover:bg-gray-700/50 transition-colors relative cursor-pointer group
                                        ${selectedSlot === i ? 'border-yellow-400 shadow-[0_0_10px_rgba(253,224,71,0.5)]' : 'border-gray-600 hover:border-gray-400'}
                                    `}
                                                title={item.name}
                                            >
                                                <span className="absolute bottom-0.5 right-1 text-[8px] text-gray-500 group-hover:text-gray-300 font-bold">{i === 9 ? 0 : i + 1}</span>
                                                <div className="w-full h-full flex items-center justify-center p-1">
                                                    <img
                                                        src={item.imgSrc}
                                                        alt={item.name}
                                                        className="w-full h-full object-contain drop-shadow-md"
                                                        draggable="false"
                                                        onError={(e) => {
                                                            // å¦‚æœåœ–ç‰‡è®€å–å¤±æ•—ï¼Œè‡ªå‹•è®Šå›é¡¯ç¤ºè‰²å¡Š (fallback)
                                                            e.target.style.display = 'none';
                                                            e.target.nextSibling.style.display = 'block';
                                                        }}
                                                    />
                                                    {/* å‚™ç”¨è‰²å¡Š (é è¨­éš±è—ï¼Œåœ–ç‰‡æ›æ‰æ™‚é¡¯ç¤º) */}
                                                    <div
                                                        className="w-full h-full rounded-sm opacity-80 hidden"
                                                        style={{ backgroundColor: item.color }}
                                                    ></div>
                                                </div>
                                                <div className="absolute -top-8 left-1/2 -translate-x-1/2 bg-black text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 whitespace-nowrap pointer-events-none transition-opacity">
                                                    {item.name}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                        {/* â˜…â˜…â˜… æ‰‹æ©Ÿç‰ˆ UI æ§åˆ¶å±¤ (æ–°å¢) â˜…â˜…â˜… */}
                        <div className="absolute inset-0 pointer-events-none z-[60]">
                            {/* è™›æ“¬æ–æ¡¿ (å·¦ä¸‹) */}
                            {/*<div
                                className="joystick-zone pointer-events-auto"
                                onTouchStart={handleJoystickTouchStart}
                                onTouchMove={handleJoystickTouchMove}
                                onTouchEnd={handleJoystickTouchEnd}
                                onTouchCancel={handleJoystickTouchEnd}
                            >
                                <div className="joystick-base">
                                    <div
                                        className="joystick-knob"
                                        style={{ transform: `translate(calc(-50% + ${joystickUI.x}px), calc(-50% + ${joystickUI.y}px))` }}
                                    ></div>
                                </div>
                            </div>
                            */}
                            {/* äº’å‹•æŒ‰éˆ• (Interact - E) - å³ä¸‹ */}
                            {/*<div
                                className="mobile-btn btn-interact pointer-events-auto"
                                onTouchStart={(e) => { e.preventDefault(); triggerKey('e'); }}
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0" /><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2" /><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" /><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" /></svg>
                            </div>
                            */}
                            {/* å–æ¶ˆæŒ‰éˆ• (Cancel - C) - å³ä¸Š */}
                            {/*<div
                                className="mobile-btn btn-cancel pointer-events-auto"
                                onTouchStart={(e) => { e.preventDefault(); triggerCancel(); }}
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18" /><path d="m6 6 12 12" /></svg>
                            </div>

                            {/* é“å…·æ¬„é–‹é—œ (Inventory - I) - ä¸­ä¸‹ */}
                            {/* <div
                                className="mobile-btn btn-inventory pointer-events-auto"
                                onTouchStart={(e) => { e.preventDefault(); setShowInventory(prev => !prev); }}
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7" /><path d="M3 7l9-4 9 4" /><path d="M12 3v4" /></svg>
                            </div>
                            */}
                        </div>

                    </div>

                </div >

            );

        }




        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>
